<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>南京大学《Web前端开发》课程复习</title>
      <link href="/2023/02/22/NJU-Web/"/>
      <url>/2023/02/22/NJU-Web/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于该课程任课老师过于抽象，课程考试本身涉及内容又多又杂，尝试体验使用 chatGPT 依据给定的复习提纲生成复习资料，作为考前速通参考</p></blockquote><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/web.webp" alt="web" style="zoom:50%;" /><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/html-final.webp" alt="html-final" style="zoom:50%;" /><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/css-final.webp" alt="css-final" style="zoom:50%;" /><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/js-final%20-%20%E5%89%AF%E6%9C%AC.webp" alt="js-final - 副本" style="zoom:100%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/js-final%20-%20%E5%89%AF%E6%9C%AC%20(2).webp" alt="js-final - 副本 (2)" style="zoom:100%;" /><h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/nodejs-final.webp" alt="nodejs-final" style="zoom:50%;" /><h1 id="性能-amp-鉴权-amp-HTTP-amp-RIA"><a href="#性能-amp-鉴权-amp-HTTP-amp-RIA" class="headerlink" title="性能 &amp; 鉴权 &amp; HTTP &amp; RIA"></a>性能 &amp; 鉴权 &amp; HTTP &amp; RIA</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/many.webp" alt="many" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 前端 </tag>
            
            <tag> Web </tag>
            
            <tag> chatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EASIEST（ing）</title>
      <link href="/2023/02/17/SentiStrength++/"/>
      <url>/2023/02/17/SentiStrength++/</url>
      
        <content type="html"><![CDATA[<h1 id="基于-SentiStrength-的面向开发协作网络的软件工程文本情绪分析应用"><a href="#基于-SentiStrength-的面向开发协作网络的软件工程文本情绪分析应用" class="headerlink" title="基于 SentiStrength 的面向开发协作网络的软件工程文本情绪分析应用"></a>基于 SentiStrength 的面向开发协作网络的软件工程文本情绪分析应用</h1><h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><ul><li><p>团队使用螺旋模型</p></li><li><p>高质量的完成⼀个系统的设计与开发工作</p><ul><li><p>团队合作</p></li><li><p>迭代开发</p></li><li><p>质量控制</p></li></ul></li></ul><h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ul><li><p>开源领域的软件工程实践（12k代码）</p><ul><li>项目名称：面向开发协作网络的软件⼯程⽂本情绪分析与应用<ul><li>（EASIEST：Sentiment Analysis and Related Application on Software Engineering Texts from Collaborative Social Networks）</li><li>基于开源项目 SentiStrength 的源码进行迭代开发<ul><li>SentiStrength 为 Mike Thelwall 等人根据 MySpace 网站数据开发的社交文本情绪分析工具，<br>  其官网地址为：<a href="http://sentistrength.wlv.ac.uk/">http://sentistrength.wlv.ac.uk</a></li><li>官网提供了该工具的原版 jar 包，各种使用手册，以及可以试运行的 demo 等</li><li>除此之外，它还罗列了与该工具有关的若干论文，并提供了工具开发过程中标注的数据集</li><li>官网 jar 包的反编译结果以发布于：<a href="https://github.com/skx980810/SentiStrength">https://github.com/skx980810/SentiStrength</a></li></ul></li></ul></li></ul></li><li><p>三次迭代，每⼀次迭代都有不同的目标</p><ul><li><p>迭代1：阅读、标注和部署/使用开源软件（JavaDoc，代码-需求矩阵） </p></li><li><p>迭代2：分析、维护开源软件（Run 数据集，纠正代码缺陷） </p></li><li><p>迭代3：维护开源软件（完善、扩充开源软件的功能）</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 迭代开发 </tag>
            
            <tag> 文本情绪分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《数据库开发》课程笔记（ing）</title>
      <link href="/2023/02/17/NJU-Database-Development/"/>
      <url>/2023/02/17/NJU-Database-Development/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库开发"><a href="#数据库开发" class="headerlink" title="数据库开发"></a>数据库开发</h1>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《服务端开发》课程笔记（ing）</title>
      <link href="/2023/02/17/NJU-Service-Side-Development/"/>
      <url>/2023/02/17/NJU-Service-Side-Development/</url>
      
        <content type="html"><![CDATA[<h1 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h1><h2 id="建立开发环境"><a href="#建立开发环境" class="headerlink" title="建立开发环境"></a>建立开发环境</h2><h3 id="Spring-Boot-开发框架"><a href="#Spring-Boot-开发框架" class="headerlink" title="Spring Boot 开发框架"></a>Spring Boot 开发框架</h3><p><strong>框架特征</strong></p><ul><li>可以创建独立的 Spring 应用程序，基于 Maven 或 Gradle 构建，可创建可执行的 JARs 或 WARs</li><li>内嵌 Tomcat 或 Jetty 等 Servlet 容器</li><li>提供自动配置的 starter 项目对象模型以简化 Maven 配置</li><li>尽可能自动配置 Spring 容器</li><li>提供准备好的特性，如指标、健康检查和外部化配置</li><li>绝对没有代码生成，不需要 XML 配置</li></ul><h3 id="一个简单-Spring-Boot-应用程序的开发与运行"><a href="#一个简单-Spring-Boot-应用程序的开发与运行" class="headerlink" title="一个简单 Spring Boot 应用程序的开发与运行"></a>一个简单 Spring Boot 应用程序的开发与运行</h3><ul><li><p>生成初始框架代码</p><ul><li>Spring initializer： <a href="https://start.spring.io/">https://start.spring.io/</a> 或在 IDE 中创建 Maven 项目</li><li>依赖：spring-boot-devtools，spring-boot-starter-web，spring-boot-starter-thymeleaf</li></ul></li><li><p>添加 HomeController.java 处理 Web 请求</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230218003147354.webp" alt="image-20230218003147354" style="zoom:50%;" /></li><li><p>添加视图模板 home.html 定义视图</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230218003221693.webp" alt="image-20230218003221693" style="zoom:50%;" /></li><li><p>文件结构</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230218003350458.webp" alt="image-20230218003350458" style="zoom:50%;" /></li><li><p>构建并运行应用</p><ul><li>插件：spring-boot-maven-plugin</li><li>mvn spring-boot:run</li></ul></li><li><p>访问 <a href="http://localhost:8080/">http://localhost:8080/</a></p></li></ul><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><strong>Spring 的两个核心技术</strong></p><ul><li><p>DI 依赖注入：</p><ul><li>保留抽象接口，让组件（Component）依赖于抽象接口，当组件要与其他实际的对象发生依赖关系时，由抽象接口来注入依赖的实际对象</li></ul></li><li><p>AOP 面向切面编程：</p><ul><li><p>通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术</p></li><li><p>利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率</p></li></ul></li></ul><p><strong>Spring 配置方案</strong></p><ul><li>自动化配置<ul><li>组件扫描：@Configuration，@ComponentScan</li><li>自动装配：@Component，@Autowired</li></ul></li><li>JavaConfig（@Configuration，@Bean）<ul><li>自动化配置有时会行不通，如使用第三方库</li><li>注入：调用方法；通过方法参数自动装配（其它配置类、其它方式创建的Bean）</li><li>注意与业务逻辑和领域代码分开</li></ul></li><li>XML 配置（不常用，略）</li></ul><p><strong>根配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configeration</span></span><br><span class="line"><span class="meta">@ComponetScan</span></span><br><span class="line"><span class="meta">@Import(其它配置类…)</span></span><br><span class="line"><span class="meta">@ImportResource(其它xml文件）</span></span><br><span class="line"><span class="meta">class BootConfig() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>@Profile</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(“dev”)</span></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(“prov”)</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line"><span class="comment">// 命令行方式：spring.profiles.default/spring.profiles.active</span></span><br><span class="line"><span class="meta">@ActiveProfiles(“dev”)</span> <span class="comment">// 代码方式</span></span><br></pre></td></tr></table></figure><p><strong>@Conditional</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional(**.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要实现的接口</span></span><br><span class="line">Condition &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoVE-Test（ing）</title>
      <link href="/2023/02/15/RoVE-Test/"/>
      <url>/2023/02/15/RoVE-Test/</url>
      
        <content type="html"><![CDATA[<h1 id="基于视觉理解的非侵入软件测试技术——RoVE-Test"><a href="#基于视觉理解的非侵入软件测试技术——RoVE-Test" class="headerlink" title="基于视觉理解的非侵入软件测试技术——RoVE-Test"></a>基于视觉理解的非侵入软件测试技术——RoVE-Test</h1>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> NJU-iSE </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> 图像理解 </tag>
            
            <tag> 机械臂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《机器学习》课程笔记（ing）</title>
      <link href="/2023/02/14/NJU-Machine-Learning/"/>
      <url>/2023/02/14/NJU-Machine-Learning/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="机器学习概论"><a href="#机器学习概论" class="headerlink" title="机器学习概论"></a>机器学习概论</h2><h3 id="机器学习系统"><a href="#机器学习系统" class="headerlink" title="机器学习系统"></a>机器学习系统</h3><p>人工智能的三大基石：推理，知识，学习（利用经验改善系统性能）</p><p>任何通过数据训练的学习算法都属于机器学习：</p><ul><li>线性回归</li><li>K-means</li><li>PCA</li><li>决策树</li><li>……</li></ul><p><strong>学习系统</strong></p><p>模型空间（模型层面），数据（数据层面） -&gt; 学习算法（学习层面） -&gt; 学得模型（学习结果）</p><p>优化目标函数，在很大的模型空间找到目标函数，SGD学习算法</p><p>数据层面：数据类型</p><p>模型层面：线性/非线性，浅层/深度/递归</p><p>学习层面：经典/现代/混合</p><p>经典学习方法：机械/归纳/类比/解释/决策树&amp;森林/贝叶斯分类器/聚类</p><p>现代学习方法：监督学习/弱监督学习/无监督学习/统计学习/集成学习/强化学习/…</p><p>常规术语及标记</p><p>输入：x，输出：y，权重：w，误差：E，目标：t</p><p>数据集划分：训练集，测试集，验证集（留出法，交叉验证）</p><h3 id="系统建模和模型选择"><a href="#系统建模和模型选择" class="headerlink" title="系统建模和模型选择"></a>系统建模和模型选择</h3><p>建模</p><p>模型/映射函数刻画</p><p>确定目标/损失函数（凸与非凸）并优化获得模型</p><p>泛化性能：欠拟合/过拟合</p><p>评价指标：混淆矩阵（分类，TP,FN,FP,TN:二分类），精度，错误率，查准率，查全率，F1度量</p><p>ROC曲线</p><p>正则化方法，约束选择空间，吉洪诺夫正则化</p><h3 id="统计学基本概念"><a href="#统计学基本概念" class="headerlink" title="统计学基本概念"></a>统计学基本概念</h3><p>均值，期望，方差，协方差</p><p>欧氏距离，余弦距离，…</p><h3 id="机器学习技术新进展"><a href="#机器学习技术新进展" class="headerlink" title="机器学习技术新进展"></a>机器学习技术新进展</h3>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《商务智能》复习笔记</title>
      <link href="/2022/12/31/NJU-Business-Intelligence-Review/"/>
      <url>/2022/12/31/NJU-Business-Intelligence-Review/</url>
      
        <content type="html"><![CDATA[<h1 id="商务智能复习"><a href="#商务智能复习" class="headerlink" title="商务智能复习"></a>商务智能复习</h1><p><strong>什么是商务智能</strong></p><ul><li>商务智能完成数据到信息的转变，将不同系统的数据汇聚成一个单一且可获取的数据源（数据仓库），向客户提供工具包对数据仓库中的数据进行分析并可视化展示</li><li>商务智能通过访问、钻研、分析和挖掘数据获取启发和了解，（改善数据访问），从而提供更完善、更全面考虑的决策支持（提供决策支持）</li></ul><p><strong>事务处理环境不适宜分析型应用的原因</strong></p><ul><li>事务处理和分析处理的性能特性不同<ul><li>事务处理每次操作时间短，数据量小，频率高，并发度大</li><li>分析处理每次运行时间长，数据量大，频率低，没有并发要求</li></ul></li><li>数据集成问题<ul><li>分析处理的数据源广泛，事务处理只关注业务相关的细节数据</li><li>数据集成中会遇到“蜘蛛网”问题，数据不一致性问题，缺少外部数据等</li><li>分散而复杂的数据会造成重复计算，降低分析处理效率，也加重程序员负担</li></ul></li><li>数据的动态集成问题<ul><li>用于决策的数据必须动态集成，事务处理环境不支持</li></ul></li><li>历史数据问题<ul><li>分析处理更看重历史数据，事务处理只需要当前数据</li><li>事务处理环境无法保留所有历史数据记录</li></ul></li><li>数据的综合问题<ul><li>事务处理系统含有大量细节数据，不具备对数据进行综合的能力</li></ul></li><li>数据的访问问题<ul><li>事务处理需要提供多种数据访问操作，需要实时更新</li><li>分析处理以读操作为主，不需要实时更新，需要定期刷新</li></ul></li></ul><p><strong>什么是数据仓库</strong></p><ul><li>数据仓库就是一个面向主题的、集成的、非易失的、时变的数据集合，用于支持经营管理过程中的决策制定<ul><li>面向主题：数据仓库内的信息是按主题进行组织的，为按主题进行决策的过程提供信息</li><li>集成的：数据仓库的数据必须从多个数据源中获取</li><li>非易失的：数据仓库的数据与操作性数据环境隔离</li><li>时变的：数据仓库中的数据通常都带有时间属性，必须以一定时间段为单位进行统一更新</li></ul></li></ul><p><strong>数据刷新的方法</strong></p><ul><li>时间戳：数据库中的记录有时间属性时可使用</li><li>DELTA 文件：使用基于 OLTP 数据库的操作型应用程序在工作过程中形成的 DELTA 文件，效率高</li><li>建立映象文件：比较数据库快照，占用大量系统资源</li><li>日志文件：使用 OLTP 数据库的日志信息，效率更高</li></ul><p><strong>ETL 技术是什么，在数据仓库架构中完成了什么任务</strong></p><ul><li>数据的抽取/转换/装载技术</li><li>将各种数据源中的数据经过处理后集成到数据仓库中</li></ul><p><strong>什么是数据仓库的粒度，为什么使用多重粒度</strong></p><ul><li>对数据仓库中数据的综合程度的一个度量</li><li>使用多重粒度，应对不同级别的粒度要求<ul><li>大粒度数据：快速存储设备，提高性能</li><li>小粒度数据：低速存储设备，满足细节查询</li></ul></li></ul><p><strong>数据仓库有哪些数据组织形式</strong></p><ul><li>简单堆积文件</li><li>轮转综合文件</li><li>简化直接文件</li><li>连续文件</li></ul><p><strong>为什么要建立数据集市，如何建立数据集市</strong></p><ul><li><p>全局性数据仓库往往太大，在实际应用中将它们按部门或个人分别建立反映各个子主题与区域的局部性数据组织，即数据集市</p></li><li><p>数据集市的数据来源于数据仓库，专门用以满足特定商务单元、商务程序、或商务应用的需求</p></li><li><p>自顶向下的结构</p><ul><li>建立数据集市能够减轻 DW 访问负载</li><li>各部门可以任意处理数据</li><li>数据转换和整合在 DW 阶段统一完成</li><li>具备数据缓冲功能</li><li>成本高、见效慢、数据集市间不共享资源</li></ul></li><li><p>自底向上的结构</p><ul><li>见效快、启动资金少</li><li>各个部门都要进行数据清理整合</li><li>可能造成“蜘蛛网”、数据不一致等问题</li><li>并且总体上没有节约资金</li></ul></li><li><p>总线结构的数据集市</p><ul><li>共享维表和事实表，解决了建立数据集市的许多问题</li><li>这种结构基于多维模型，应用限制于OLAP</li><li>多个数据源直接影响多个集市，造成数据仓库结构不十分稳定</li></ul></li><li><p>企业级数据集市结构</p><ul><li>略</li></ul></li></ul><p><strong>如何提高 ROLAP 中的处理效率</strong></p><ul><li>采用物化视图方式</li><li>采用特殊的索引与集簇方式，以加速星型模式内表的连接速度</li><li>尽量采用并行操作方式</li><li>采用 OLAP 中的查询优化技术，如共享排序技术等</li><li>采用增量技术，在 OLAP 数据更新时保留不变的数据，仅更改变动的数据以加快数据更新速度</li></ul><p><strong>数据仓库物理模型设计的优化技术</strong></p><ul><li>合并表</li><li>建立数据序列</li><li>引入冗余</li><li>表的物理分割</li><li>生成导出数据</li><li>建立广义索引</li></ul><p><strong>数据仓库设计的原则</strong></p><ul><li>面向主题原则<ul><li>从用户决策的主观需求（主题）开始</li><li>以主题为起始点，进行相关数据的设计，最终建立起一个面向主题的分析型环境</li></ul></li><li>数据驱动原则<ul><li>从已有的数据库系统出发</li><li>按照分析领域对数据及数据间的联系重新考察</li><li>利用数据模型有效识别原有数据库中的数据和数据仓库中主题的数据的“共同性”</li></ul></li><li>原型法设计原则<ul><li>从构建系统的基本框架着手，不断丰富与完善整个系统</li><li>数据仓库系统的开发是一个经过不断循环、反馈而使系统不断增长与完善的过程</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 商务智能 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《编译原理》课程笔记</title>
      <link href="/2022/12/04/NJU-Compiler-Principle/"/>
      <url>/2022/12/04/NJU-Compiler-Principle/</url>
      
        <content type="html"><![CDATA[<p>课程内容链接：<a href="https://space.bilibili.com/479141149/channel/collectiondetail?sid=837891">https://space.bilibili.com/479141149/channel/collectiondetail?sid=837891</a></p><p>课程实验代码：<a href="https://github.com/Ling-Yuchen/compiler-hw">https://github.com/Ling-Yuchen/compiler-hw</a></p><h1 id="00-编译原理概述"><a href="#00-编译原理概述" class="headerlink" title="00 - 编译原理概述"></a>00 - 编译原理概述</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282053376.png" alt="image-20221128205347262" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282055145.png" alt="image-20221128205501109" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282055462.png" alt="image-20221128205542408" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282057868.png" alt="image-20221128205745813" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282058394.png" alt="image-20221128205833346" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282059066.png" alt="image-20221128205905002" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282059640.png" alt="image-20221128205957585" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282100571.png" alt="image-20221128210026532" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282101881.png" alt="image-20221128210102832" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282101118.png" alt="image-20221128210144056" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282102388.png" alt="image-20221128210257332" style="zoom:50%;" /><h1 id="01-词法分析器生成器"><a href="#01-词法分析器生成器" class="headerlink" title="01 - 词法分析器生成器"></a>01 - 词法分析器生成器</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282108315.png" alt="image-20221128210809272" style="zoom:50%;" /><p>使用 ANTLR 工具编写词法分析器生成器：</p><ul><li>输入：词法单元的归约 <code>SysYLexer.g4</code></li><li>输出：词法分析器 <code>SysYLexer.tokens</code>，<code>SysYLexer.interp</code>，<code>SysYLexer.java</code></li></ul><p>样例：（来自 lab1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar SysYLexer;</span><br><span class="line"></span><br><span class="line">CONST : &#x27;const&#x27;;</span><br><span class="line">INT : &#x27;int&#x27;;</span><br><span class="line">VOID : &#x27;void&#x27;;</span><br><span class="line">IF : &#x27;if&#x27;;</span><br><span class="line">ELSE : &#x27;else&#x27;;</span><br><span class="line">WHILE : &#x27;while&#x27;;</span><br><span class="line">BREAK : &#x27;break&#x27;;</span><br><span class="line">CONTINUE : &#x27;continue&#x27;;</span><br><span class="line">RETURN : &#x27;return&#x27;;</span><br><span class="line">MUL : &#x27;*&#x27;;</span><br><span class="line">DIV : &#x27;/&#x27;;</span><br><span class="line">MOD : &#x27;%&#x27;;</span><br><span class="line">PLUS : &#x27;+&#x27;;</span><br><span class="line">MINUS : &#x27;-&#x27;;</span><br><span class="line">ASSIGN : &#x27;=&#x27;;</span><br><span class="line">EQ : &#x27;==&#x27;;</span><br><span class="line">NEQ : &#x27;!=&#x27;;</span><br><span class="line">LT : &#x27;&lt;&#x27;;</span><br><span class="line">GT : &#x27;&gt;&#x27;;</span><br><span class="line">LE : &#x27;&lt;=&#x27;;</span><br><span class="line">GE : &#x27;&gt;=&#x27;;</span><br><span class="line">NOT : &#x27;!&#x27;;</span><br><span class="line">AND : &#x27;&amp;&amp;&#x27;;</span><br><span class="line">OR : &#x27;||&#x27;;</span><br><span class="line">L_PAREN : &#x27;(&#x27;;</span><br><span class="line">R_PAREN : &#x27;)&#x27;;</span><br><span class="line">L_BRACE : &#x27;&#123;&#x27;;</span><br><span class="line">R_BRACE : &#x27;&#125;&#x27;;</span><br><span class="line">L_BRACKT : &#x27;[&#x27;;</span><br><span class="line">R_BRACKT : &#x27;]&#x27;;</span><br><span class="line">COMMA : &#x27;,&#x27;;</span><br><span class="line">SEMICOLON : &#x27;;&#x27;;</span><br><span class="line">IDENT : ([_a-zA-Z])([_a-zA-Z0-9])*;</span><br><span class="line">INTEGR_CONST : [1-9][0-9]*</span><br><span class="line">               | &#x27;0&#x27;</span><br><span class="line">               | &#x27;0&#x27;([0-7])+</span><br><span class="line">               | &#x27;0&#x27;(&#x27;x&#x27;|&#x27;X&#x27;)[0-9a-fA-F]+;</span><br><span class="line">WS : [ \r\n\t]+ -&gt; skip;</span><br><span class="line">LINE_COMMENT :  &#x27;//&#x27; .*? &#x27;\n&#x27; -&gt; skip;</span><br><span class="line">MULTILINE_COMMENT : &#x27;/*&#x27; .*? &#x27;*/&#x27; -&gt; skip;</span><br></pre></td></tr></table></figure><p>一些定义：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282125772.png" alt="image-20221128212525749" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282126328.png" alt="image-20221128212605291" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282126735.png" alt="image-20221128212645712" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282127006.png" alt="image-20221128212712972" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282127118.png" alt="image-20221128212748099" style="zoom:50%;" /><p>能够在语言（集合）上进行的操作：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282129204.png" alt="image-20221128212950178" style="zoom:50%;" /><p>正则表达式：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282137348.png" alt="image-20221128213723288" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282139380.png" alt="image-20221128213934333" style="zoom:50%;" /><h1 id="02-手写词法分析器"><a href="#02-手写词法分析器" class="headerlink" title="02 - 手写词法分析器"></a>02 - 手写词法分析器</h1><p>略</p><h1 id="03-自动机理论与词法分析器生成器"><a href="#03-自动机理论与词法分析器生成器" class="headerlink" title="03 - 自动机理论与词法分析器生成器"></a>03 - 自动机理论与词法分析器生成器</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282143290.png" alt="image-20221128214349235" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282144646.png" alt="image-20221128214448586" style="zoom:50%;" /><h2 id="目标：RE-to-Lexer"><a href="#目标：RE-to-Lexer" class="headerlink" title="目标：RE to Lexer"></a>目标：RE to Lexer</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282146730.png" alt="image-20221128214604688" style="zoom:50%;" /><p>RE：正则表达式</p><p><strong>NFA：不确定的有穷自动机（简洁易于理解，便于描述语言 L(A)）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282200473.png" alt="image-20221128220050425" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282201287.png" alt="image-20221128220127256" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291448454.png" alt="image-20221129144808425" style="zoom:50%;" /><p>其不确定性在于：</p><ul><li>在同一状态下，看到相同的字符，可以转移到不同的状态</li><li>没有看到任何字符（看到 ε），也有可以发生状态的转移</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291442048.png" alt="image-20221129144244929" style="zoom:50%;" /><p><strong>DFA：确定的有穷自动机（易于判断 x ∈ L(A)，适合产生词法分析器）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291450677.png" alt="image-20221129145044628" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291451092.png" alt="image-20221129145111066" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291457324.png" alt="image-20221129145709299" style="zoom:50%;" /><p><strong>约定</strong>：所有没有对应出边的字符默认指向一个<strong>“死状态”</strong>（不可能再被接收）</p><p>其确定性在于：</p><ul><li>只对字符表中的字符做状态转移</li><li>每个状态下对每个字符都有唯一的状态转移</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291501221.png" alt="image-20221129150132187" style="zoom:67%;" /><h3 id="Thompson-构造法（RE-to-NFA）"><a href="#Thompson-构造法（RE-to-NFA）" class="headerlink" title="Thompson 构造法（RE to NFA）"></a>Thompson 构造法（RE to NFA）</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291502065.png" alt="image-20221129150222036" style="zoom:50%;" /><p>依据<strong>正则表达式的定义</strong>，分步处理：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291505728.png" alt="image-20221129150515701" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291505372.png" alt="image-20221129150548348" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291507400.png" alt="image-20221129150700360" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291508066.png" alt="image-20221129150811023" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291508063.png" alt="image-20221129150848024" style="zoom:60%;" /><p>分析：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291510172.png" alt="image-20221129151046116" style="zoom:50%;" /><p>例子：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291511497.png" alt="image-20221129151138451" style="zoom:70%;" /><h3 id="子集构造法（NFA-to-DFA）"><a href="#子集构造法（NFA-to-DFA）" class="headerlink" title="子集构造法（NFA to DFA）"></a>子集构造法（NFA to DFA）</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291538851.png" alt="image-20221129153848792" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291544262.png" alt="image-20221129154444220" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291551492.png" alt="image-20221129155102446" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291552560.png" alt="image-20221129155217511" style="zoom:50%;" /><h3 id="DFA-最小化（DFA-to-最简等价DFA）"><a href="#DFA-最小化（DFA-to-最简等价DFA）" class="headerlink" title="DFA 最小化（DFA to 最简等价DFA）"></a>DFA 最小化（DFA to 最简等价DFA）</h3><p>DFA 最小化的基本思想：等价的状态可以合并</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291557771.png" alt="image-20221129155713732" style="zoom:50%;" /><p>出发点：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291600819.png" alt="image-20221129160003787" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291600681.png" alt="image-20221129160054643" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291601749.png" alt="image-20221129160129715" style="zoom:50%;" /><p>DFA 最小化算法总结：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291602641.png" alt="image-20221129160220576" style="zoom:50%;" /><p>算法要在严格定义的 DFA 上执行，<strong>注意</strong>要先检查是否需要补全“死状态”</p><h3 id="Kleene-构造法（DFA-to-RE）"><a href="#Kleene-构造法（DFA-to-RE）" class="headerlink" title="Kleene 构造法（DFA to RE）"></a>Kleene 构造法（DFA to RE）</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281129810.png" alt="image-20221228112928764" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281130112.png" alt="image-20221228113052063" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281138528.png" alt="image-20221228113839478" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281140716.png" alt="image-20221228114004685" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281142943.png" alt="image-20221228114257896" style="zoom:50%;" /><h2 id="词法分析器生成"><a href="#词法分析器生成" class="headerlink" title="词法分析器生成"></a>词法分析器生成</h2><p><strong>遵循规则：最前优先匹配，最长优先匹配</strong></p><ul><li><p>根据正则表达式构造相应的 NFA</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220092340899.webp" alt="image-20230220092340899" style="zoom:50%;" /></li><li><p>合并 NFA，构造完整词法规则的 NFA</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220092435146.webp" style="zoom:50%;" /></li><li><p>使用<strong>子集构造法</strong>将 NFA 转化为等价 DFA（并消除“死状态”）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220092904184.webp" alt="image-20230220092904184" style="zoom:50%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220093007486.webp" alt="image-20230220093007486" style="zoom:50%;" /></li><li><p>特定于词法分析器的 DFA 最小化（可选）</p><p>  初始划分不能把所有终止状态笼统地分成一类，需要考虑不同的词法单元，按照识别不同词法单元规约分成不同的类，并补全“死状态”（然后再正常根据 DFA 最小化算法进行处理）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220094124812.webp" alt="image-20230220094124812" style="zoom:50%;" /></li><li><p>模拟运行该 DFA，直到无法继续运行为止（输入结束或状态无法转移）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220093337028.webp" alt="image-20230220093337028" style="zoom:50%;" /></li></ul><h1 id="04-语法分析器"><a href="#04-语法分析器" class="headerlink" title="04 - 语法分析器"></a>04 - 语法分析器</h1><h2 id="ANTLR-v4-生成语法分析器"><a href="#ANTLR-v4-生成语法分析器" class="headerlink" title="ANTLR v4 生成语法分析器"></a>ANTLR v4 生成语法分析器</h2><p>（已通过<code>SysYLexer.g4</code>生成对应的词法分析器）</p><ul><li>输入：语法归约 <code>SysYParser.g4</code></li><li>输出：语法分析器及访问生成的语法树的辅助类 <code>SysYParser.tokens</code>，<code>SysYParser.interp</code>，<code>SysYParser.java</code>，<code>SysYParserBaseListener.java</code>，<code>SysYParserBaseVisitor.java</code>，<code>SysYParserListener.java</code>，<code>SysYParserVisitor.java</code><ul><li>ANTLR 提供了 Visitor 和 Listener 两种访问语法树节点的方式，即访问者模式和观察者模式</li></ul></li></ul><p>样例：（来自 lab2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">parser grammar SysYParser;</span><br><span class="line"></span><br><span class="line">options &#123;</span><br><span class="line">    tokenVocab = SysYLexer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">program : compUnit EOF ;</span><br><span class="line"></span><br><span class="line">compUnit : (decl | funcDef)+ ;</span><br><span class="line"></span><br><span class="line">decl : constDecl | varDecl ;</span><br><span class="line"></span><br><span class="line">constDecl : CONST bType constDef (COMMA constDef)* SEMICOLON ;</span><br><span class="line"></span><br><span class="line">bType : INT ;</span><br><span class="line"></span><br><span class="line">constDef : IDENT (L_BRACKT constExp R_BRACKT)* ASSIGN constInitVal ;</span><br><span class="line"></span><br><span class="line">constInitVal : constExp | L_BRACE (constInitVal (COMMA constInitVal)*)? R_BRACE ;</span><br><span class="line"></span><br><span class="line">varDecl : bType varDef (COMMA varDef)* SEMICOLON ;</span><br><span class="line"></span><br><span class="line">varDef : IDENT (L_BRACKT constExp R_BRACKT)* (ASSIGN initVal)? ;</span><br><span class="line"></span><br><span class="line">initVal : exp | L_BRACE (initVal (COMMA initVal)*)? R_BRACE ;</span><br><span class="line"></span><br><span class="line">funcDef : funcType IDENT L_PAREN funcFParams? R_PAREN block ;</span><br><span class="line"></span><br><span class="line">funcType : VOID | INT ;</span><br><span class="line"></span><br><span class="line">funcFParams : funcFParam (COMMA funcFParam)* ;</span><br><span class="line"></span><br><span class="line">funcFParam : bType IDENT (L_BRACKT R_BRACKT (L_BRACKT exp R_BRACKT)*)? ;</span><br><span class="line"></span><br><span class="line">block : L_BRACE blockItem* R_BRACE ;</span><br><span class="line"></span><br><span class="line">blockItem : decl | stmt ;</span><br><span class="line"></span><br><span class="line">stmt : lVal ASSIGN exp SEMICOLON</span><br><span class="line">     | exp? SEMICOLON</span><br><span class="line">     | block</span><br><span class="line">     | IF L_PAREN cond R_PAREN stmt (ELSE stmt)?</span><br><span class="line">     | WHILE L_PAREN cond R_PAREN stmt</span><br><span class="line">     | BREAK SEMICOLON</span><br><span class="line">     | CONTINUE SEMICOLON</span><br><span class="line">     | RETURN exp? SEMICOLON</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">exp : L_PAREN exp R_PAREN</span><br><span class="line">   | lVal</span><br><span class="line">   | number</span><br><span class="line">   | IDENT L_PAREN funcRParams? R_PAREN</span><br><span class="line">   | unaryOp exp</span><br><span class="line">   | exp (MUL | DIV | MOD) exp</span><br><span class="line">   | exp (PLUS | MINUS) exp</span><br><span class="line">   ;</span><br><span class="line"></span><br><span class="line">cond : exp</span><br><span class="line">   | cond (LT | GT | LE | GE) cond</span><br><span class="line">   | cond (EQ | NEQ) cond</span><br><span class="line">   | cond AND cond</span><br><span class="line">   | cond OR cond</span><br><span class="line">   ;</span><br><span class="line"></span><br><span class="line">lVal : IDENT (L_BRACKT exp R_BRACKT)* ;</span><br><span class="line"></span><br><span class="line">number : INTEGR_CONST ;</span><br><span class="line"></span><br><span class="line">unaryOp : PLUS | MINUS | NOT ;</span><br><span class="line"></span><br><span class="line">funcRParams : param (COMMA param)* ;</span><br><span class="line"></span><br><span class="line">constExp : exp ;</span><br><span class="line"></span><br><span class="line">param: exp ;</span><br></pre></td></tr></table></figure><h2 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h2><p>例如：stmt：”if” expr “then” stmt “else” stmt ; 是一个二义性文法（if-else 的匹配问题）</p><p>可以通过改写来消除二义性（将 else 与最近的未匹配的 if 相匹配）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stmt : matched_stmt | open_stmt ;</span><br><span class="line">matched_stmt : &quot;if&quot; expr &quot;then&quot; matched_stmt &quot;else&quot; matched_stmt</span><br><span class="line">             | expr ;</span><br><span class="line">open_stmt : &quot;if&quot; expr &quot;then&quot; stmt</span><br><span class="line">  | &quot;if&quot; expr &quot;then&quot; matched_stmt &quot;else&quot; open_stmt ;</span><br></pre></td></tr></table></figure><p>例如：expr：expr “*” expr | expr “+” expr | DIGIT ; 是一个二义性文法（运算符的结合性和优先级）</p><p>常识告诉我们乘法的优先级比加法高，并且两者都是左结合的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 左递归文法 */</span><br><span class="line">expr : expr &quot;+&quot; term | term ;</span><br><span class="line">term : term &quot;*&quot; factor | factor ;</span><br><span class="line">factor : DIGIT ;</span><br></pre></td></tr></table></figure><p>ANTLR 可以通过算法直接处理二义性文法和具有左公因子的文法，无需人为改写（优先级高的写在前）</p><p>ANTLR 中二元运算符默认为左结合，一元运算符默认为右结合，对于右结合的二元运算符，使用关键字 assoc 加以限定，expr：&lt;assoc = right&gt; expr “^” expr</p><h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281037083.png" alt="image-20221228103735005" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281041154.png" alt="image-20221228104150107" style="zoom:50%;" /><p><strong>一些复杂的例子</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281115304.png" alt="image-20221228111512276" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281051824.png" alt="image-20221228105110789" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281052729.png" alt="image-20221228105232697" style="zoom:50%;" /><p><strong>上下文无关文法的表达能力强于正则表达式</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281053858.png" alt="image-20221228105339687" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281056905.png" alt="image-20221228105605841" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281058935.png" alt="image-20221228105824901" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281103647.png" alt="image-20221228110306581" style="zoom:50%;" /><p><strong>证明一个上下文无关文法没有二义性</strong></p><p>对于 A → X | Y | Z，要证明：</p><ul><li>L(X) ∩ L(Y) = Ø</li><li>L(Y) ∩ L(Z) = Ø</li><li>L(Z) ∩ L(X) = Ø</li></ul><p>其中，L(X) 表示 X 所定义的语言</p><p>故，更一般的，对于 A → X1 | X2 | X3 | … | Xn，需要证明，∀ i, j ∈ [1, n] (i != j)，有 L(Xi) ∩ L(Xj) = Ø</p><h1 id="05-语法分析算法"><a href="#05-语法分析算法" class="headerlink" title="05 - 语法分析算法"></a>05 - 语法分析算法</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220094542795.webp" alt="image-20230220094542795" style="zoom:50%;" /><h2 id="LL-1-语法分析算法"><a href="#LL-1-语法分析算法" class="headerlink" title="LL(1) 语法分析算法"></a>LL(1) 语法分析算法</h2><p>自顶向下的，递归下降的，基于分析预测表的，适用于 LL(1) 文法的 LL(1) 语法分析器</p><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>LL(1) 从左往右读入词法单元（left-to-right），并且在推导的每一步，总是选择<strong>最左边的非终结符</strong>进行展开（left-most description）</p><h3 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220095224395.webp" alt="image-20230220095224395" style="zoom:50%;" /><h3 id="分析预测表"><a href="#分析预测表" class="headerlink" title="分析预测表"></a>分析预测表</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220100730617.webp" alt="image-20230220100730617" style="zoom:50%;" /><h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1) 文法"></a>LL(1) 文法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220100923810.webp" alt="image-20230220100923810" style="zoom:50%;" /><h3 id="实现样例"><a href="#实现样例" class="headerlink" title="实现样例"></a>实现样例</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220101059108.webp" alt="image-20230220101059108" style="zoom:50%;" /><h3 id="计算给定文法-G-的预测分析表"><a href="#计算给定文法-G-的预测分析表" class="headerlink" title="计算给定文法 G 的预测分析表"></a>计算给定文法 G 的预测分析表</h3><p><strong>First 集合</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220102228084.webp" alt="image-20230220102228084" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220102303259.webp" alt="image-20230220102303259" style="zoom:50%;" /><p><strong>Follow 集合</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220102435072.webp" alt="image-20230220102435072" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220102625682.webp" alt="image-20230220102625682" style="zoom:50%;" /><p><strong>计算 First 集合</strong></p><p>对于每个符号串 α 的产生式：α = X1 X2 X3 … Xm</p><ul><li>先计算每个 X 的 First(X) 集合</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220104053883.webp" alt="image-20230220104053883" style="zoom:50%;" /><ul><li>再计算每个符号串 α 的 First(α) 集合</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220104558617.webp" alt="image-20230220104558617" style="zoom:50%;" /><p><strong>计算 Follow 集合</strong></p><ul><li>为每个非终结符 X 计算 Follow(X) 集合</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220105107878.webp" alt="image-20230220105107878" style="zoom:50%;" /><p><strong>生成预测分析表</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220105629679.webp" alt="image-20230220105629679" style="zoom:50%;" /><h3 id="非递归的预测分析算法"><a href="#非递归的预测分析算法" class="headerlink" title="非递归的预测分析算法"></a>非递归的预测分析算法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220110342405.webp" alt="image-20230220110342405" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220110424089.webp" alt="image-20230220110424089" style="zoom:50%;" /><h3 id="改造非-LL-1-文法"><a href="#改造非-LL-1-文法" class="headerlink" title="改造非 LL(1) 文法"></a>改造非 LL(1) 文法</h3><ul><li>消除左递归（使用右递归）</li><li>提取左公因子</li></ul><h2 id="Adaptive-LL-语法分析算法（AllStar-算法）"><a href="#Adaptive-LL-语法分析算法（AllStar-算法）" class="headerlink" title="Adaptive LL(*) 语法分析算法（AllStar 算法）"></a>Adaptive LL(*) 语法分析算法（AllStar 算法）</h2><p>关于 ANTLR v4：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220111538654.webp" alt="image-20230220111538654" style="zoom:50%;" /><h3 id="处理左递归-优先级"><a href="#处理左递归-优先级" class="headerlink" title="处理左递归+优先级"></a>处理左递归+优先级</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220121644591.webp" alt="image-20230220121644591" style="zoom:50%;" /><p><strong>优先级上升算法</strong></p><p>变为非左递归，然后用迭代的方式进行处理</p><p>展开递归表达式时，需要一个优先级参数</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220121957805.webp" alt="image-20230220121957805" style="zoom:50%;" /><p>更多例子：</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220122923959.webp" alt="image-20230220122923959" style="zoom:50%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220123004166.webp" alt="image-20230220123004166" style="zoom:50%;" /></center><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220123158588.webp" alt="image-20230220123158588" style="zoom:50%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220122854917.webp" alt="image-20230220122854917" style="zoom:50%;" /></center><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220131823952.webp" alt="image-20230220131823952" style="zoom:50%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220131926622.webp" alt="image-20230220131926622" style="zoom:50%;" /></center><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220132352223.webp" alt="image-20230220132352223" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220132407304.webp" alt="image-20230220132407304" style="zoom:50%;" /><h3 id="进行错误报告与恢复"><a href="#进行错误报告与恢复" class="headerlink" title="进行错误报告与恢复"></a>进行错误报告与恢复</h3><p>恐慌/应急模式（Panic Mode）：假装成功，调整状态，继续进行</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220132724391.webp" alt="image-20230220132724391" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220132926556.webp" alt="image-20230220132926556" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220133643768.webp" alt="image-20230220133643768" style="zoom:50%;" /><h3 id="AllStar-算法"><a href="#AllStar-算法" class="headerlink" title="AllStar 算法"></a>AllStar 算法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220133946836.webp" alt="image-20230220133946836" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220134014892.webp" alt="image-20230220134014892" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220134205766.webp" alt="image-20230220134205766" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220134749427.webp" alt="image-20230220134749427" style="zoom:50%;" /><h1 id="06-符号表"><a href="#06-符号表" class="headerlink" title="06 - 符号表"></a>06 - 符号表</h1><p>每个符号表代表了一个作用域，不同的作用域需要通过树结构来维护：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140121490.webp" alt="image-20230220140121490" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140342843.webp" alt="image-20230220140342843" style="zoom:50%;" /><p>每个作用域需要提供的接口：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140512430.webp" alt="image-20230220140512430" style="zoom:50%;" /><p><strong>符号表相关的类层次结构设计</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140908716.webp" alt="image-20230220140908716" style="zoom:50%;" /><h1 id="07-语义分析"><a href="#07-语义分析" class="headerlink" title="07 - 语义分析"></a>07 - 语义分析</h1><h2 id="类型系统与类型检查"><a href="#类型系统与类型检查" class="headerlink" title="类型系统与类型检查"></a>类型系统与类型检查</h2><ul><li><p>类型检查</p></li><li><p>类型转换</p></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220144425670.webp" alt="image-20230220144425670" style="zoom:50%;" /><ul><li>类型综合</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220144547713.webp" alt="image-20230220144547713" style="zoom:50%;" /><ul><li>类型推导</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220144638313.webp" alt="image-20230220144638313" style="zoom:50%;" /><p><strong>生成数组类型的类型表达式</strong></p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220153819939.webp" alt="image-20230220153819939" style="zoom:50%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220153754567.webp" alt="image-20230220153754567" style="zoom:50%;" /></center><h2 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h2><p>属性文法：为上下文无关文法赋予语义</p><p><strong>关键问题：如何基于上下文无关文法做上下文相关分析？</strong>（语法分析树上的有序信息流动，DFS 遍历）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220161257010.webp" alt="image-20230220161257010" style="zoom:50%;" /><p>在 ANTLR v4 中，使用参数的形式来表示继承属性，使用返回值来表示综合属性</p><p>（代码演示部分略）</p><h3 id="语法制导定义"><a href="#语法制导定义" class="headerlink" title="语法制导定义"></a>语法制导定义</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220192334350.webp" alt="image-20230220192334350" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220192552257.webp" alt="image-20230220192552257" style="zoom:50%;" /><h4 id="S-属性定义"><a href="#S-属性定义" class="headerlink" title="S 属性定义"></a>S 属性定义</h4><p><strong>综合属性</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220192854928.webp" alt="image-20230220192854928" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220192953775.webp" alt="image-20230220192953775" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220193042113.webp" alt="image-20230220193042113" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220193122241.webp" alt="image-20230220193122241" style="zoom:50%;" /><h4 id="L-属性定义"><a href="#L-属性定义" class="headerlink" title="L 属性定义"></a>L 属性定义</h4><p><strong>继承属性</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220193309453.webp" alt="image-20230220193309453" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220193659176.webp" alt="image-20230220193659176" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220200519082.webp" alt="image-20230220200519082" style="zoom:50%;" /><ul><li><strong>例子：属性文法计算后缀表达式</strong></li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201141864.webp" alt="image-20230220201141864" style="zoom:40%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201312671.webp" alt="image-20230220201312671" style="zoom:40%;" /></center><ul><li><strong>例子：属性文法计算有符号二进制数</strong></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201545335.webp" alt="image-20230220201545335" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201740985.webp" alt="image-20230220201740985" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201849477.webp" alt="image-20230220201849477" style="zoom:50%;" /><h3 id="语法制导的翻译方案"><a href="#语法制导的翻译方案" class="headerlink" title="语法制导的翻译方案"></a>语法制导的翻译方案</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220202655013.webp" alt="image-20230220202655013" style="zoom:50%;" /><p>将带有<strong>语义规则</strong>的 SDD 转换为带有<strong>语义动作</strong>的 SDT：</p><ul><li>S 属性的翻译方案</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220202928233.webp" alt="image-20230220202928233" style="zoom:50%;" /><ul><li>L 属性定义与 LL 语法分析</li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220203423540.webp" alt="image-20230220203423540" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220203525251.webp" alt="image-20230220203525251" style="zoom:50%;" /></center><ul><li>比较：在左递归与右递归上的属性定义</li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220210233365.webp" alt="image-20230220210233365" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220210256289.webp" alt="image-20230220210256289" style="zoom:45%;" /></center><ul><li>L 属性翻译方案</li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220210540575.webp" alt="image-20230220210540575" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220210633745.webp" alt="image-20230220210633745" style="zoom:45%;" /></center><ul><li>L 属性翻译方案样例</li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220211418305.webp" alt="image-20230220211418305" style="zoom:40%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220211445122.webp" alt="image-20230220211445122" style="zoom:40%;" /></center><h1 id="08-LLVM-IR"><a href="#08-LLVM-IR" class="headerlink" title="08 - LLVM IR"></a>08 - LLVM IR</h1><h2 id="LLVM（Low-Level-Virtual-Machine）"><a href="#LLVM（Low-Level-Virtual-Machine）" class="headerlink" title="LLVM（Low-Level Virtual Machine）"></a>LLVM（Low-Level Virtual Machine）</h2><p><strong>The LLVM Compiler Infrastructure</strong></p><blockquote><p>The LLVM Project is a collection of <strong>modular</strong> and <strong>reusable</strong> compiler and tool-chain technologies. Despite its name, LLVM has little to do with traditional <strong>virtual machines</strong>. The name “LLVM” itself is not an acronym; it is the full name of the project.</p></blockquote><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220212550131.webp" alt="image-20230220212550131" style="zoom:60%;" /><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220213427834.webp" alt="image-20230220213427834" style="zoom:50%;" /><h3 id="自动生成-LLVM-IR"><a href="#自动生成-LLVM-IR" class="headerlink" title="自动生成 LLVM IR"></a>自动生成 LLVM IR</h3><p>使用命令 <code>clang -S -emit-llvm xxx.c -o xxx.ll</code> 生成 LLVM IR code 样例：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220220126419.webp" alt="image-20230220220126419" style="zoom:60%;" /><p>演示代码 1：<a href="https://github.com/courses-at-nju-by-hfwei/compilers-antlr/tree/main/src/main/java/llvm/factorial">https://github.com/courses-at-nju-by-hfwei/compilers-antlr/tree/main/src/main/java/llvm/factorial</a> &amp;&amp; <a href="https://github.com/courses-at-nju-by-hfwei/learning-llvm/tree/main/10-llvm">https://github.com/courses-at-nju-by-hfwei/learning-llvm/tree/main/10-llvm</a></p><p>更多关于 LLVM 的使用：<a href="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/LLVM.pdf">https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/LLVM.pdf</a></p><p>使控制流满足 SSA：<strong>Φ 函数</strong>根据控制流决定选择 y1 还是 y2</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220221003332.webp" alt="image-20230220221003332" style="zoom:50%;" /><p><strong>不同优化等级下对控制流的实现方式</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220222526053.webp" alt="image-20230220222526053" style="zoom:70%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220222623949.webp" alt="image-20230220222623949" style="zoom:70%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220223642412.webp" alt="image-20230220223642412" style="zoom:70%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220224220970.webp" alt="image-20230220224220970" style="zoom:70%;" /><h3 id="编程方式生成-LLVM-IR"><a href="#编程方式生成-LLVM-IR" class="headerlink" title="编程方式生成 LLVM IR"></a>编程方式生成 LLVM IR</h3><blockquote><p>详见实验代码</p></blockquote><h1 id="09-中间代码生成"><a href="#09-中间代码生成" class="headerlink" title="09 - 中间代码生成"></a>09 - 中间代码生成</h1><h2 id="表达式翻译与控制流翻译"><a href="#表达式翻译与控制流翻译" class="headerlink" title="表达式翻译与控制流翻译"></a>表达式翻译与控制流翻译</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220235003531.webp" alt="image-20230220235003531" style="zoom:50%;" /><p>注意：下图中的文法对布尔表达式和非布尔表达式做出了区分</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221001735737.webp" alt="image-20230221001735737" style="zoom:90%; margin-bottom:40px" /><h3 id="非布尔表达式的中间代码翻译"><a href="#非布尔表达式的中间代码翻译" class="headerlink" title="非布尔表达式的中间代码翻译"></a>非布尔表达式的中间代码翻译</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221090506622.webp" alt="image-20230221090506622" style="zoom:50%;" /><h3 id="数组引用表达式的中间代码翻译"><a href="#数组引用表达式的中间代码翻译" class="headerlink" title="数组引用表达式的中间代码翻译"></a>数组引用表达式的中间代码翻译</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221081957482.webp" alt="image-20230221081957482" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221082244527.webp" alt="image-20230221082244527" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221082449049.webp" alt="image-20230221082449049" style="zoom:50%; margin-top:50px" /><p><strong>LLVM IR 的生成结果：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221083640233.webp" alt="image-20230221083640233" style="zoom:50%; margin-bottom:20px" /><h3 id="控制流语句与布尔表达式的中间代码翻译"><a href="#控制流语句与布尔表达式的中间代码翻译" class="headerlink" title="控制流语句与布尔表达式的中间代码翻译"></a>控制流语句与布尔表达式的中间代码翻译</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221084113845.webp" alt="image-20230221084113845" style="zoom:60%;" /><p><strong>if 条件语句：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221084512124.webp" alt="image-20230221084512124" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221084547737.webp" alt="image-20230221084547737" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221084615354.webp" alt="image-20230221084615354" style="zoom:60%;" /><p>最终生成的 IR code：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goto L1</span><br><span class="line">L1:</span><br><span class="line">goto L0</span><br><span class="line">L3:</span><br><span class="line">assign</span><br><span class="line">L0:</span><br></pre></td></tr></table></figure><p><strong>if else 条件语句：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221085547052.webp" alt="image-20230221085547052" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221085737101.webp" alt="image-20230221085737101" style="zoom:60%;" /><p>最终生成的 IR code：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">goto L1</span><br><span class="line">L1:</span><br><span class="line">goto L3</span><br><span class="line">L3:</span><br><span class="line">assign</span><br><span class="line">goto L0</span><br><span class="line">L4:</span><br><span class="line">assign</span><br><span class="line">goto L0</span><br><span class="line">L2:</span><br><span class="line">assign</span><br><span class="line">L0:</span><br></pre></td></tr></table></figure><p><strong>while 循环语句：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221092013672.webp" alt="image-20230221092013672" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221092534286.webp" alt="image-20230221092534286" style="zoom:60%;" /><p>最终生成的 IR code：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">begin:</span><br><span class="line">goto L1</span><br><span class="line">L1:</span><br><span class="line">goto L4</span><br><span class="line">L3:</span><br><span class="line">assign</span><br><span class="line">goto begin</span><br><span class="line">L4:</span><br><span class="line">assign</span><br><span class="line">goto begin</span><br><span class="line">L0:</span><br></pre></td></tr></table></figure><p><strong>并列顺序语句：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093336145.webp" alt="image-20230221093336145" style="zoom:50%;" /><p><strong>布尔表达式：</strong></p><ul><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093742808.webp" alt="image-20230221093742808" style="zoom:50%;" /></li><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093703309.webp" alt="image-20230221093703309" style="zoom:50%;" /></li><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093628479.webp" alt="image-20230221093628479" style="zoom:50%;" /></li><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093924755.webp" alt="image-20230221093924755" style="zoom:50%;" /></li><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221094042026.webp" alt="image-20230221094042026" style="zoom:50%;" /></li></ul><p>一个复杂的例子：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221094123089.webp" alt="image-20230221094123089" style="zoom:70%;" /><p>最终生成的 IR code：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if x &lt; 100 goto L2</span><br><span class="line">goto L3</span><br><span class="line">L3:</span><br><span class="line">if x &gt; 200 goto L4</span><br><span class="line">goto L1</span><br><span class="line">L4:</span><br><span class="line">if x != y goto L2</span><br><span class="line">goto L1</span><br><span class="line">L2:</span><br><span class="line">x = 0</span><br><span class="line">L1:</span><br></pre></td></tr></table></figure><p><strong>生成 LLVM IR code 并可视化展示控制流图</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221100702370.webp" alt="image-20230221100702370" style="zoom:50%;" /><p><strong>使用 ANTLR v4 生成控制流</strong></p><p>参考样例代码：</p><p><a href="https://github.com/courses-at-nju-by-hfwei/compilers-antlr/blob/main/src/main/antlr/codegen/Control.g4">https://github.com/courses-at-nju-by-hfwei/compilers-antlr/blob/main/src/main/antlr/codegen/Control.g4</a></p><p><a href="https://github.com/courses-at-nju-by-hfwei/compilers-antlr/blob/main/src/main/java/codegen/CodeGenListener.java">https://github.com/courses-at-nju-by-hfwei/compilers-antlr/blob/main/src/main/java/codegen/CodeGenListener.java</a></p><p><strong>关于布尔表达式的补充</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221101915982.webp" alt="image-20230221101915982" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221101938668.webp" alt="image-20230221101938668" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 编译原理 </tag>
            
            <tag> LLVM </tag>
            
            <tag> ANTLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《大数据分析》课程作业</title>
      <link href="/2022/09/22/Bigdata-Analysis-Homework/"/>
      <url>/2022/09/22/Bigdata-Analysis-Homework/</url>
      
        <content type="html"><![CDATA[<h4 id="Scala-安装（Windows）"><a href="#Scala-安装（Windows）" class="headerlink" title="Scala 安装（Windows）"></a>Scala 安装（Windows）</h4><p>需要已经安装有 Java 环境</p><p>安装包下载：<a href="https://www.scala-lang.org/download/%EF%BC%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8">https://www.scala-lang.org/download/（建议使用</a> .msi 方式安装）</p><p>配置环境变量：</p><ul><li>添加系统变量 <strong>SCALA_HOME = [scala安装路径]</strong></li><li>在系统变量 <strong>Path</strong> 下添加 <strong>%SCALA_HOME%\bin;</strong></li><li>在系统变量 <strong>Classpath</strong> 下添加 <strong>.;%SCALA_HOME%\bin;</strong></li></ul><h4 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h4><p>使用 Scala 语言的 RDD 相关操作(map、reduce 等)，编写代码实现对 test.txt 文件单词次数统计（单词不区分大小写）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="type">Source</span>.fromFile(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">          .getLines()</span><br><span class="line">          .reduce(_ + <span class="string">&quot; &quot;</span> + _)</span><br><span class="line">          .toLowerCase</span><br><span class="line">          .split(<span class="string">&quot;[^a-zA-Z0-9&#x27;]+&quot;</span>)</span><br><span class="line">          .map(word =&gt; (word, <span class="string">&quot;&quot;</span>))</span><br><span class="line">          .groupBy(_._1)</span><br><span class="line">          .map(&#123;<span class="keyword">case</span> (k, v) =&gt; (k, v.length)&#125;)</span><br><span class="line">          .toList</span><br><span class="line">          .sortBy(_._1)</span><br><span class="line">        println(result.mkString(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 大数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>商业模式新生代阅读笔记</title>
      <link href="/2022/09/11/Business-Model/"/>
      <url>/2022/09/11/Business-Model/</url>
      
        <content type="html"><![CDATA[<blockquote><p>商业模式：一个商业模式描述的是一个组织创造、传递以及获得价值的基本原理</p></blockquote><h1 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h1><h2 id="九大模块"><a href="#九大模块" class="headerlink" title="九大模块"></a>九大模块</h2><p><strong>客户细分</strong></p><p>一家企业想要获得的和期望服务的不同的目标人群和机构</p><p>细分客户群体的条件：</p><ul><li>需求催生新供给</li><li>需要建立新的分销渠道</li><li>需要建立新的客户关系类型</li><li>产生的利润率不同</li><li>愿意为某方面特殊改进而买单</li></ul><p>客户群体划分方式：</p><ul><li>大众市场（常见于消费电子产业、大型零售商等）</li><li>小众市场（常见于供应商—采购商）</li><li>求同存异的客户群体（各类产品线）</li><li>多元化的客户群体</li><li>多边平台/多边市场</li></ul><p><strong>价值主张</strong></p><p>为某一客户群体提供能为其创造价值的产品和服务（一家公司为客户提供的利益集合）</p><p>有益于价值创造的因素（更简单，更“复杂”，更透明）：</p><ul><li>创新（客户未曾察觉的全新需求，之前没有类似产品）</li><li>性能</li><li>定制（大规模定制，用户参与创造）</li><li>保姆式服务（外包）</li><li>设计（时尚，电子产品）</li><li>品牌/低位（奢侈品，潮牌，游戏等级）</li><li>价格（以更低的价格提供类似的产品：廉价航空，小米，免费经济）</li><li>缩减成本（服务外包：编程，房产销售）</li><li>风险控制（保险，额外保障服务）</li><li>可获得性（分享经济，共同基金）</li><li>便利性/实用性（云计算服务）</li></ul><p>一个产品的价值主张通常是相互重叠且交错的（价值网络）</p><p><strong>渠道通路</strong></p><p>企业如何同其客户群体沟通并建立联系，以向对方传达自身的价值主张</p><p>企业与客户的交互体系：交流、分销、销售渠道、售后，是用户的交互触点</p><p>作用：了解产品和服务，评估价值主张；购买产品与服务，传递价值主张；提供售后支持</p><p>渠道的五个阶段与运营方式：</p><ul><li>知名度—评价—购买—传递—售后</li><li>将价值主张推向市场，与客户建立联系：自有渠道，合作方渠道，混合渠道</li></ul><p>渠道通路的重要性：</p><ul><li>对同类产品竞争起核心作用，但过度重视容易引起反噬（品质与信任失配）</li><li>承载价值主张和客户细分的组合关系，用不断推出的新产品进行营销，强化/更新价值主张，加强/拓展客户细分对系列产品服务的认知</li></ul><p><strong>客户关系</strong></p><p>企业针对某一客户群体所建立的客户关系的类型</p><p>驱动力：开发新客户；留住原客户；增加销售量或单价</p><p>客户关系类型：</p><ul><li>私人服务：发生在购买的现场（价值导向）</li><li>专属私人服务：需要长时间积累，如私人银行服务等（价值导向）</li><li>自助服务：企业向客户提供渠道（成本导向）</li><li>自动化服务：根据客户资料定制服务，如商品推荐等（成本导向）</li><li>社区：使用用户社区融入客户，有利于企业预判未来市场发展，促进社区中成员间联系（兼顾）</li><li>与用户协作，共同创造：与客户合作共同创造价值，如亚马逊邀请客户撰写书评（价值导向）</li></ul><p><strong>收入来源</strong></p><p>企业从每个客户群体中获得的现金收益</p><p>收入来源的方式：</p><ul><li>资产销售：出售实物产品所有权</li><li>使用费：提供某种具体服务，使用越多支付越多</li><li>会员费：销售某项服务的持续使用权限</li><li>租赁：将特定资产某一时期专门供给某人使用</li><li>许可使用费：授予某种受保护知识产权的使用权，并收取使用费</li><li>经纪人佣金：提供中介服务（手续费）</li><li>广告费：为某种产品、服务或品牌做广告</li></ul><p><strong>核心资源</strong></p><p>保证一个商业模式顺利运行所需的最重要资产</p><p>作用：创造并提供价值主张，获得市场，保持与某个客户群体的客户关系并获得收益</p><p>“核心”意味着稀缺/不可替代，需要花费巨大成本来维系</p><ul><li>自主拥有：额外的管理和折旧风险，效率高降低成本</li><li>寻求合作：让出利润空间，颠覆式生存危机</li></ul><p>核心资源类型：</p><ul><li><p>实物资源：一切实物资产，如生产设备、房屋、车辆、机器、管理系统、分销渠道等（资本密集型）</p></li><li><p>知识性资源：如品牌、专营权、专利权、版权、合作关系、客户数据库等，不宜获得但价值巨大</p></li><li><p>人力资源：普遍需要，在知识密集型产业和创新产业尤为关键，如制药公司等</p><ul><li>高价劳动力的来源：对个人创造力的依赖/赛道的稳定程度</li></ul></li><li><p>金融资源：现金、信用额度、用于吸引关键雇员的股票期权池</p></li></ul><p><strong>关键业务</strong></p><p>保障商业模式正常运行所需要做的最重要的事情（运用核心资源，价值主张的落地）</p><p>关键业务是企业创造并提供价值主张，获得市场，维系客户关系并获得收益所必须的</p><p>构建护城河：商业模式创新 – 构建不可替代的关键业务 – 支撑服务升级 – 基础设施投资 –底层技术突破 – 拥有/强化核心资源</p><p>关键业务的分类：</p><ul><li>生产：涉及较大数量或上乘质量，设计、制造以及分销产品，如制造类企业</li><li>解决方案：涉及为个体客户的问题提供解决方案，如咨询公司、医院等</li><li>平台/网络：涉及平台管理、新服务启动、平台升级，如 Visa 公司搭建的信用卡交易平台</li></ul><p><strong>重要合作</strong></p><p>一个商业模式顺利运行所需的供应商和合作伙伴网络</p><p>合作类型：</p><ul><li>非竞争者之间的商业联盟（微信生态 vs. 苹果生态）</li><li>竞争者之间的战略合作（微信支付和支付宝，可口可乐和百事可乐）</li><li>新业务的合资公司</li><li>稳定供应关系的供应商和采购商（产业园，闭环的互联网影视平台）</li></ul><p>合作动机：</p><ul><li>优化及规模效应：优化资源及活动配置，降低成本，如外包、基础设施共享等</li><li>降低风险和不确定性：互为竞争对手的企业在某一领域建立战略联盟而在其他领域保持竞争关系</li><li>特殊资源及活动的获得：企业通过依赖其他占有某项资源或专注于某项活动的公司来实现能力的拓展</li></ul><p><strong>成本结构</strong></p><p>运营一个商业模式所发生的全部成本</p><p>导向：</p><ul><li><p>成本导向：创造并维持精简的成本结构，如低价的价值主张、自动化生产最大化、广泛的业务外包</p></li><li><p>价值导向：更少地关注成本，更多地关注价值创造，以更高端的价值主张、高度的个性化服务为特点</p></li></ul><p>特点：</p><ul><li>固定成本</li><li>可变成本</li><li>规模经济（大宗采购、大规模生产摊薄固定成本）</li><li>范围经济（渠道的复用，摊薄部分可变成本）</li></ul><h2 id="商业模式画布"><a href="#商业模式画布" class="headerlink" title="商业模式画布"></a>商业模式画布</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072007214.png" alt="image-20220907200701090" style="zoom:50%;" /><p><strong>模块之间的联系</strong></p><p>纵向联系：</p><ul><li>客户关系-&gt;渠道通路-&gt;收入来源</li><li>关键业务-&gt;关键资源-&gt;成本支出</li></ul><p>跨越的联系：</p><ul><li>客户关系选择与成本支出导向（定制化、个人化 – 价值导向 VS 自动化、大众化 – 成本导向）</li><li>除了价值主张与关键业务，关注建设渠道通路所需的核心资源与重要合作</li><li>细分的客户群体是否认同上游的重要合作方与引入的外部关键资源</li></ul><p>联系的联系</p><ul><li>平台：多个“价值主张-客户细分”对的组合才能构成完整的收入来源<ul><li>吸引用户的主张与用户愿意付费的主张</li><li>促进多种不同用户群体的交易：补贴谁？收费谁？</li><li>如何运维平台并促进不同用户群体加入</li></ul></li></ul><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="分拆商业模式"><a href="#分拆商业模式" class="headerlink" title="分拆商业模式"></a>分拆商业模式</h2><p>一般来说，只有大型的成熟的公司，进入稳定的运营状态之后，才会使用分拆的商业模式</p><p>企业内部三类规则：经济、竞争、文化</p><ul><li>将企业从事的活动分为：客户关系管理、新产品开发、基础设施管理</li><li>活动对应三种价值信条：亲近客户、产品领先、运营卓越</li></ul><p>理想情况下，它们存在于相互独立的实体中以避免冲突或不必要的消长</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072256345.png" alt="image-20220907225625044" style="zoom:40%;" /><p><strong>私人银行产业</strong>集合了上述三种商业活动：<strong>财富管理</strong>，<strong>经纪服务</strong>，<strong>金融产品设计</strong></p><p>三种不同类型基础业务之间的消长：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072310035.png" alt="image-20220907231007672" style="zoom:50%;" /><p><strong>移动通信行业</strong>的拆分：</p><ul><li><p>基础设施管理交由设备生产商，它们可以同时为多个运营商提供服务，做到更低的运营成本</p></li><li><p>新产品开发交由多个内容提供商（更小的创新型企业），发挥小而有活力的组织的优势</p></li><li><p>品牌和客户关系作为新的核心资产，由减负后的运营商专心聚焦</p></li></ul><h2 id="长尾商业模式"><a href="#长尾商业模式" class="headerlink" title="长尾商业模式"></a>长尾商业模式</h2><p>受到生产工具、销售渠道的普及以及连接供需双方搜寻成本的降低的促进</p><p>少量、多种，即致力于提供多种小众产品（专注于多种类产品销售）</p><p>需要满足：低库存成本、强大的平台、及时售出</p><p><strong>图书出版行业</strong>的转型：</p><p>以“畅销书为中心”转变为“为任何有需要的人出版”</p><p>吸引大量作家，使得作品的失败对出版商而言接近零成本</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209101052230.png" alt="image-20220910105254140" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209101053454.png" alt="image-20220910105332377" style="zoom:45%;" /></center>**乐高**的新长尾模式：<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102301261.png" alt="image-20220910230107977" style="zoom:50%;" /><p><strong>长尾模式总结</strong>：</p><ul><li>小众产品提供者是<strong>重要伙伴</strong></li><li>以提供宽范围的非热销品与热销品共存为<strong>价值主张</strong></li><li>聚焦于小众<strong>客户</strong></li><li>以<strong>平台</strong>为核心资源</li><li>以平台开发维护、小众产品的获得与生产等为<strong>关键业务</strong></li><li><strong>成本</strong>主要发生于平台开发和维护</li><li>依赖互联网来维护<strong>客户关系</strong>或作为<strong>交易渠道</strong></li><li><strong>收入来源</strong>广泛，可能包括广告、产品销售、订阅费等</li><li>对专业和业余产品提供者都适用，创造了一个同时服务于用户和生产者的<strong>多边平台</strong></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102309693.png" alt="image-20220910230923520" style="zoom:50%;" /><ul><li>长尾的发展趋势：坚持 – 转化：长尾部分扁平化；形成若干“小众中心”，并分别向“大众中心”转化</li></ul><h2 id="多边平台商业模式"><a href="#多边平台商业模式" class="headerlink" title="多边平台商业模式"></a>多边平台商业模式</h2><ul><li><p>将两个或更多独立但相互依存的客户群体连接在一起</p></li><li><p>平台对于平台中某一群体的价值在于平台中其他客户群体的存在</p></li><li><p>平台通过促进不同群体间的互动而创造价值（充当媒介）</p></li><li><p>平台的价值提升在于其所吸引的用户数量的增加（网络效应）</p></li></ul><p><strong>谷歌</strong>的商业模式：</p><p>向三个相互依存的客户群体提出三个不同的价值主张：</p><ul><li>针对搜索内容靶向投放广告（广告商）</li><li>免费的强大的搜索引擎服务，多种在线工具服务（上网浏览者）</li><li>呈现谷歌广告商的广告，利用自己的网站内容获利（第三方内容创造者）</li></ul><p>从广告商群体中赚钱，对上网浏览着和内容提供者给予补贴</p><p><strong>电子游戏机产业</strong>：Wii <em>vs.</em> PSP/Xbox</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102343513.png" alt="image-20220910234316443" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102342897.png" alt="image-20220910234251855" style="zoom:45%;" /></center><p><strong>苹果公司</strong>的平台发展：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102341296.png" alt="image-20220910234129230" style="zoom:50%;" /><p><strong>多边平台商业模式总结</strong>：</p><ul><li><strong>核心资源</strong>是平台，关键活动是平台管理、服务实现以及平台升级</li><li><strong>价值主张</strong>主要体现在吸引客户群体，将客户群体进行配对，通过平台提供的交易渠道降低交易成本</li><li>有两个或更多的相互依赖的<strong>客户细分</strong>，每个都有各自的价值主张和收益流</li><li>每个客户群体产生一个<strong>收益流</strong>，一个或多个群体享受免费服务或来自另一客户群体收益流的补贴</li><li>选择对的客户群体作为补贴对象是关键，决定了该模式是否成功</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102352220.png" alt="image-20220910235239062" style="zoom:50%;" /><h2 id="免费的商业模式"><a href="#免费的商业模式" class="headerlink" title="免费的商业模式"></a>免费的商业模式</h2><ul><li><p>至少有一个关键客户群体可以持续免费地享受服务</p></li><li><p>不付费的客户所得到的财务支持来自商业模式中另一个客户群体</p></li></ul><p>三种使得免费可行的方式：</p><ul><li><p>基于多边平台的免费商品（广告模式）</p><ul><li>好的产品和服务以及高流量会吸引广告商，进而补贴产品和服务</li><li>成本：平台的开发和维护，以及可能的获客与维系成本</li></ul></li><li><p>免费的基本服务，可选的增值服务（免费增值模式）</p><ul><li>收入形式：大量用户从免费服务获益，少量用户为增值服务付费</li><li>两个关键指标：关注免费用户服务成本（低边界成本）与增值用户转化率</li><li>平台发展新趋势：需要高水平、差异化的产品与服务（为免费增值提供空间）</li></ul></li><li><p>以免费吸引客户，引诱其进入重复购买状态（钓鱼模式）</p><ul><li>产品与后续产品之间要有紧密连接，为后续高收益产品或服务的重复购买创造可能</li><li>关注后续产品交付，需要强大品牌支撑</li><li>重要成本结构：初始产品补贴与后续产品的成本</li><li>慢慢融入平台与免费增值</li></ul></li></ul><p><strong>基于广告的</strong>：<em>Metro</em> 公司免费报纸</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112225265.png" alt="image-20220911222512167" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112226573.png" alt="image-20220911222635481" style="zoom:50%;" /><p><strong>免费增值模式</strong>：图片分享网站 <em>Flicker</em> &amp; <em>Redhat</em> 开放源码</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112233796.png" alt="image-20220911223302666" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112234465.png" alt="image-20220911223453366" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112238197.png" alt="image-20220911223813106" style="zoom:50%;" /><p><strong>钓鱼模式</strong>：免费移动电话</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112241625.png" alt="image-20220911224158562" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112240562.png" alt="image-20220911224022382" style="zoom:50%;" /><h2 id="开放式的商业模式"><a href="#开放式的商业模式" class="headerlink" title="开放式的商业模式"></a>开放式的商业模式</h2><p>系统性与外部伙伴合作</p><p>企业的研发流程对外敞开</p><ul><li>“由外到内”：将外部的理念、技术或知识产权引入内部</li><li>“由内到外”：将内部的知识产权或技术，特别是闲置资产向外出售</li></ul><p>开放的商业模式的优势：</p><ul><li>适用于拥有强势品牌、强大分销渠道与良好客户关系的大公司</li><li>进一步挖掘客户关系的价值</li><li>外部组织能提供有价值的见解、知识、专利、甚至现成的产品</li><li>要能有效获取外部特定资源，要有对外协作的专门业务</li><li>外来意味着成本，但可以缩短上市时间，提升内部开发效率</li><li>帮助企业实现跨越式发展（中国高铁）</li><li>以研发为核心的组织往往产生许多内部无法实用化的知识、技术、和智力资产</li><li>将闲置资产变现，增加收入</li><li>因战略或运营原因对内无价值的研发成果可能对其它行业意义重大</li><li>帮助企业聚焦核心战略，鼓励内部创新</li></ul><h2 id="后发软件产品的机会"><a href="#后发软件产品的机会" class="headerlink" title="后发软件产品的机会"></a>后发软件产品的机会</h2><ul><li>更加细分、贴合的用户体验 – 形成独特的亚文化、亚群体</li><li>结合核心资源、关键业务的深入打造（重资产、“持有型投资”） - 不可替代性强的日常生活服务</li><li>向新技术、新领域、新应用的创新尝试（“新”是指与典型互联网企业、行业相比，往往是有利可图的“老”行业） - 工业/产业互联网</li></ul><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="客户洞察"><a href="#客户洞察" class="headerlink" title="客户洞察"></a>客户洞察</h2><p>根据客户洞察打造商业模式</p><p>成功的创新需要深入理解客户的环境、日常工作、担忧和渴望</p><p>辅助工具：移情图</p><ul><li>看：描述该客户在她所处的环境中所看到的东西</li><li>听：描述环境如何影响到这个客户</li><li>想&amp;感受：尝试勾勒你的客户思维的过程</li><li>说&amp;做：想象客户可能的言辞，或公共场合的行为</li><li>痛点：已遭受的挫折、正遇到的阻碍、怕承担的风险</li><li>收益：预期成就、成功衡量标准、实现目标所采用的策略</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230210144340911.webp" alt="image-20230210144340911" style="zoom:45%;" /><p>客户洞察补充：变需要为需求（人为核心）</p><p>客户洞察的核心：换位思考（帮助人们发掘未能意识到的潜在需求）</p><h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><p>一个能够产生大量商业模式创意，并成功识别出其中最佳创意的流程被称作构思</p><p>构思的两个步骤：生成大量创意-&gt;对创意进行整合并挑选</p><p>商业模式创新的焦点：</p><ul><li>资源驱动：创新来源于组织现有的基础设施或合作伙伴资源</li><li>供给驱动：创造全新的价值主张，并影响到其它模块</li><li>客户驱动：基于客户需求、可获得性或便利性的提升，并影响其他模块</li><li>财务驱动：由新收益来源、定价机制或者被缩减的成本驱动的创新</li><li>多点驱动：多焦点驱动的创新，并对其它模块产生深远影响</li></ul><h2 id="视觉化思考"><a href="#视觉化思考" class="headerlink" title="视觉化思考"></a>视觉化思考</h2><p>抽象的东西具体化、复杂的概念简单化</p><p>视觉化的作用：理解商业模式的本质，提升对话效率，探索创意，提升沟通</p><h2 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h2><p>与视觉化思考一样，模型构建可以使抽象的概念具体化，帮助探索新的创意</p><p>模型构建有助于实际商业模式的探索</p><h2 id="讲故事"><a href="#讲故事" class="headerlink" title="讲故事"></a>讲故事</h2><p>故事是一个理想的热身工具，为深度讨论商业模式与其内在逻辑做好准备</p><p>将故事与画布结合，利用叙事性克服听众对不熟悉模式的抵触，放下对陌生事物的怀疑</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>将模型构建中明确的方向具体化，从而给出有见地的设计</p><p>两种场景：</p><ul><li>不同的客户结构：结合客户洞察描绘出独特、具体的图景<ul><li>由场景决定选择哪款产品而放弃其它产品（价值主张的排他性）</li></ul></li><li>未来可能的竞争环境：想象未来可能的具体细节，品味特定条件下商业模式如何演进</li></ul><h1 id="战略"><a href="#战略" class="headerlink" title="战略"></a>战略</h1><h2 id="商业模式环境评估"><a href="#商业模式环境评估" class="headerlink" title="商业模式环境评估"></a>商业模式环境评估</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230208141317874.webp" alt="image-20230208141317874" style="zoom:50%;" /><ul><li>市场影响力<ul><li>市场问题 – 从客户和供给的角度识别出驱动和改变你的市场的关键问题</li><li>市场分类 – 识别主要的市场群体，描述他们的兴趣点，尝试发现新的群体</li><li>需求和诉求 – 列举市场需求并分析这些需求被满足的程度</li><li>切换成本 – 客户转投竞争对手，需要改变哪些方面</li><li>收入影响力 – 识别与收入吸引力和定价能力相关的因素</li></ul></li><li>关键趋势<ul><li>技术趋势 – 威胁和推动发展当前商业模式的技术趋势</li><li>行业管理趋势 – 影响（你的）商业模式的管理规定和管理趋势</li><li>社会和文化趋势 – 可能影响（你的）商业模式的社会趋势</li><li>社会经济趋势 – 总结和你的商业模式有关的主要社会经济趋势</li></ul></li><li>行业影响力<ul><li>主流竞争对手 – 识别它们以及它们的相对优势</li><li>挑战者 - 新出现的玩家以及它们商业模式的不同</li><li>替代产品和服务 - （包括其它市场和行业在内的）替代产品与服务</li><li>供应商与价值链上的其他厂商 – 当前价值链上的关键玩家与新兴玩家</li><li>利益相关者 – 哪些人会影响你的组织和商业模式</li></ul></li><li>宏观经济影响<ul><li>全球市场情况 – 从宏观经济角度总结当前整体情况</li><li>资本市场 – 与你的资本需求相关的当前资本市场情况</li><li>大宗商品和其他资源 – 关注你的商业模式所需的资源价格与趋势</li><li>经济基础设施 – 你的业务市场的经济基础设施</li></ul></li></ul><h2 id="评估商业模式"><a href="#评估商业模式" class="headerlink" title="评估商业模式"></a>评估商业模式</h2><p>商业模式环境-由外到内的影响，评估商业模式-由内到外的分析</p><h3 id="SWOT评估"><a href="#SWOT评估" class="headerlink" title="SWOT评估"></a>SWOT评估</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230208142342478.webp" alt="image-20230208142342478" style="zoom:50%;" /><p>传统SWOT分析与商业模式画布结合：按照价值主张、成本/收入、基础设施（KR+KA+KP）、客户界面（CS+CH+CR）四类展开评估</p><p><strong>评估优势与劣势</strong></p><ul><li>价值主张：<ul><li>匹配用户需求，形成网络效应（相互关联促进），产品与服务强耦合，用户满意</li></ul></li><li>成本/收入：<ul><li>利润高，收入可预期、可持续、多样化，支出前有进账，定价机制抓住客户购买意愿</li><li>成本可预测，成本结构合理（与商业模式相匹配），运营的成本效率高，获益于规模经济</li></ul></li><li>基础设施：<ul><li>核心资源难以被复制、资源需求可预测、合适时间部署合适资源</li><li>有效执行关键业务、关键业务难以被复制、执行质量高、业务活动内外平衡</li><li>必要合作伙伴、合作关系融洽</li></ul></li><li>客户界面：<ul><li>客户流失率、客户分类、新客户获取</li><li>渠道有效率、有效果、连接客户能力、客户可以轻易接触、被高度整合、产生规模经济、匹配客户群体</li><li>客户关系强、切换成本高绑定关系、品牌强</li></ul></li></ul><p><strong>评估威胁</strong></p><ul><li>对价值主张的威胁（可替代性）</li><li>对成本/收入的威胁（利润的威胁、是否单一、缩水、无法预测、无法支撑）</li><li>对基础设施的威胁（供应不足、干扰、合作关系波动）</li><li>客户界面上的威胁（市场竞争、渠道威胁、客户关系恶化）</li></ul><p><strong>评估机会</strong></p><ul><li>价值主张中的机会（整合、服务化与拓展）</li><li>成本/收入中的机会（可重复、交叉销售、开源节流）</li><li>基础设施中的机会（强化核心、减轻负担、转让闲置）</li><li>客户界面的机会（增长的市场、客户细分、渠道优化与去中间商，客户关系加强与取舍）</li></ul><h2 id="蓝海战略"><a href="#蓝海战略" class="headerlink" title="蓝海战略"></a>蓝海战略</h2><p>蓝海战略：通过根本性的差异化来创造全新的行业，而不是模仿现有商业模式在当前行业中竞争</p><p>蓝海战略的“四项行动架构”（增加价值，减少成本）</p><ul><li>行业中哪些理所当然的要素应被删除（删除）</li><li>哪些要素应被大幅消减至行业标准以下（削减）</li><li>哪些要素应该被大幅调整到行业标准之上（提升）</li><li>哪些行业中从未提供的要素是应该被创造出来的（创造）</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230208181916463.webp" alt="image-20230208181916463" style="zoom:50%;" /><p>蓝海战略强调在增加价值的同时减少成本，通过删除和消减低价值产品或服务来降低成本，通过提升和创造对成本影响弱的高价值功能或服务来实现</p><p>蓝海战略的风险：空心化、外部潮流与形势变更</p><h2 id="多种商业模式管理"><a href="#多种商业模式管理" class="headerlink" title="多种商业模式管理"></a>多种商业模式管理</h2><p>组织的艰巨任务：如何在实施和管理新商业模式的同时维持现有的商业模式</p><ul><li>将新商业模式剥离成一个独立的实体，或者成立独立的业务单元，或维持现状</li><li>拆分商业模式：基础服务、客户关系、新业务</li></ul><p>衡量是否拆分的双变量</p><ul><li>两种模式冲突的严重程度</li><li>战略上的相似性</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h2><p><strong>需求获取</strong></p><ul><li>目标分析（目标模型）<ul><li>确定一个或多个总的目标</li><li>将目标不断细化（目标精化）<ul><li>AND 精化</li><li>OR 精化</li></ul></li><li>标明矛盾冲突（目标阻碍）</li><li>目标的基本模式<ul><li>实现（achieve）</li><li>终止（cease）</li><li>保持（maintain）</li><li>避免（avoid）</li><li>优化（max / min）</li></ul></li></ul></li><li>涉众分析<ul><li>主体依赖模型（ADM 模型）：在涉众识别中分析关键涉众<ul><li>目标依赖</li><li>软目标依赖</li><li>任务依赖</li><li>资源依赖</li></ul></li><li>Power-Interest 模型，Power-Attitude 模型：涉众风险评估<ul><li>参与者，环境设定者，被影响者，观众</li><li>强反对者，强支持着，弱反对者，弱支持者</li></ul></li><li>Stakeholder-Issue 模型：涉众共赢分析<ul><li>列出所有涉众类别（stakeholder）</li><li>将不同涉众的兴趣和期望总结归纳为共同的问题（issue）</li><li>标明涉众对对应问题的期望和态度</li><li>冲突的部分进行折中调整、权衡协商</li></ul></li></ul></li><li>需求获取方法<ul><li>面谈<ul><li>查阅背景资料</li><li>确定主题与目标</li><li>联系被会见者</li><li>确定问题类型及具体问题（先开放后封闭，避免诱导性和双筒式的问题）</li><li>主持面谈</li><li>处理面谈结果</li></ul></li><li>原型</li><li>观察</li></ul></li></ul><p><strong>需求分析</strong></p><ul><li>概念类图（领域模型）</li><li>系统顺序图</li><li>系统状态图</li></ul><p><strong>需求验证</strong></p><ul><li>评审</li><li>原型与模拟</li><li>开发测试用例</li><li>用户手册编制</li><li>利用跟踪关系</li><li>自动化分析</li></ul><p><strong>需求管理</strong></p><ul><li><p>维护需求基线</p><ul><li>配置管理</li><li>状态维护</li></ul></li><li><p>实现需求跟踪</p><ul><li>避免在开发过程或者演化过程中与需求基线不一致或者偏离的风险</li><li>前向跟踪：被定义到软件需求规格说明文档之前的需求演化过程</li><li>后向跟踪：被定义到软件需求规格说明文档之后的需求演化过程</li></ul></li><li><p>控制需求变更</p><ul><li>对变化的评估</li><li>协调</li><li>批准或拒绝</li><li>实现</li><li>验证</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 商业模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《云计算》课程笔记</title>
      <link href="/2022/09/07/NJU-Cloud-Computing/"/>
      <url>/2022/09/07/NJU-Cloud-Computing/</url>
      
        <content type="html"><![CDATA[<h3 id="云计算的概念"><a href="#云计算的概念" class="headerlink" title="云计算的概念"></a>云计算的概念</h3><h4 id="云计算的定义"><a href="#云计算的定义" class="headerlink" title="云计算的定义"></a>云计算的定义</h4><p>关键字：数据存储和网络计算服务，按需交付，分布式，商业计算模型，计算服务交付与底层技术分离</p><h4 id="云计算的参与者"><a href="#云计算的参与者" class="headerlink" title="云计算的参与者"></a>云计算的参与者</h4><ul><li>有基础设施，有意向提供服务或出租</li><li>需要增加基础设施，但不知道需要多长时间</li><li>需要增加基础设施，但资金投入能力有限</li><li>想要专心于设计和开发，不想操心维护和扩展</li><li>想要在任何地方都能访问个人的资源（e.g. 编辑个人文档）</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071511203.png" alt="image-20220907151132110" style="zoom:50%;" /><p>（如上图，上层为云栈，下层为云体）</p><h4 id="计算模式的演进"><a href="#计算模式的演进" class="headerlink" title="计算模式的演进"></a>计算模式的演进</h4><p>主机系统与集中计算 → 效用计算 → 客户机/服务器模式 → 集群计算 → 服务计算 → 个人计 算机与桌面计算 → 分布式计算 → 网格计算 → 软件即服务 → 云计算 </p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071530707.png" alt="image-20220907153039668" style="zoom:50%;" /><p>人类对计算的追求：自动化、高性能、易使用</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071535832.png" alt="image-20220907153511752" style="zoom:50%;" /><p><strong>传统分布式系统</strong></p><p>计算机集群：将多个可信、静态的独立节点连接起来协作完成计算（计算抽象）</p><p>P2P网络：每个节点既是客户端也是服务器，提供部分系统资源（存储抽象）</p><p>计算网格：将多个<strong>异构</strong>计算机动态、紧耦合地整合在一起完成计算任务（接近“云”）</p><p><strong>云计算的基本想法</strong></p><p>对网格的优化（分布式计算的解决方案）：</p><ul><li>大量计算节点，同构可控</li><li>专用内部网络</li><li>通过互联网对外服务（公有云）</li><li>全面虚拟化：计算、存储、网络、桌面</li><li>集中管理：安全、高效</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071736462.png" alt="image-20220907173616370" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071737319.png" alt="image-20220907173711248" style="zoom:50%;" /><p>云计算持续优化的动力：节能降耗、降低维护成本、提升资产安全、提升信息系统的容灾备份能力</p><h4 id="云计算的特征与分类"><a href="#云计算的特征与分类" class="headerlink" title="云计算的特征与分类"></a>云计算的特征与分类</h4><h5 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209151529008.png" alt="image-20220915152859786" style="zoom:33%;" /><h5 id="云计算的特点"><a href="#云计算的特点" class="headerlink" title="云计算的特点"></a>云计算的特点</h5><ul><li>超大规模——需求</li><li>虚拟化——技术</li><li>按需服务——商业模式</li><li>通用；高可伸缩；极其廉价——得益于技术和模式</li><li>高可靠——要求</li></ul><h5 id="云部署模型"><a href="#云部署模型" class="headerlink" title="云部署模型"></a>云部署模型</h5><p>公有云；社区云；私有云；混合云</p><h5 id="云服务模型"><a href="#云服务模型" class="headerlink" title="云服务模型"></a>云服务模型</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209151532919.png" alt="image-20220915153256807" style="zoom:50%;" /><p><strong>IaaS：</strong></p><p>通过虚拟机方式对外提供计算和存储能力</p><p>机器享有公网IP，多个虚拟机之间通过网络进行通信（也会有内部子网）</p><p>类似租用独立的计算机</p><p>用户自行解决多台机器之间的协同问题</p><p>优势：</p><ul><li>允许动态申请和释放资源</li><li>按使用量计费</li><li>更高的资源使用效率</li></ul><p><strong>PaaS：</strong></p><p>提供用户应用程序的开发和运行环境，包括应用编程接口和运行平台等，支持应用从创建到运行整个生命周期需要的各种软硬件资源和工具：</p><ul><li>经过封装的IT能力或逻辑资源：数据库、文件系统和应用运行环境</li><li>主要面向软件开发者（包括应用服务上）</li></ul><p>PaaS自身负责资源的动态扩展和容错管理</p><p>用户无需考虑节点间的配合问题</p><p>用户自主权降低，需按照给定的编程环境和编程模型构建应用</p><p>类似MPI（Message Passing Interface）编程（只适用于解决模型特定的计算问题）</p><p><strong>SaaS：</strong></p><p>通过标准的Web浏览器获软件客户端访问云上的应用</p><p><strong>IaaS <em>vs.</em> PaaS <em>vs.</em> SaaS：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209152214305.png" alt="image-20220915221420238" style="zoom:50%;" /><h4 id="云计算的三元认知论"><a href="#云计算的三元认知论" class="headerlink" title="云计算的三元认知论"></a>云计算的三元认知论</h4><p><strong>一种商业模式</strong></p><p>从提供的服务类型来看是一种全新的商业模式（没有包含新技术）</p><p>区别于传统的“互联网服务”模式：在软件服务基础上提供平台和基础设施服务</p><p>以云平台体现具体实现机制，包括计算范式和实现方式</p><p><strong>一种计算范式</strong></p><ul><li><p>理论层面的实现方式，偏向针对商业模式的体系结构设计</p></li><li><p>云体逻辑结构：具体落地的云平台逻辑结构——物理结构就是云数据中心</p><ul><li>计算 + 存储 + 通信</li></ul></li><li><p>云栈逻辑结构：面向服务的云平台逻辑结构——物理结构就是管理系统的结构</p><ul><li>基础设施即服务，平台即服务，软件即服务</li></ul></li></ul><p><strong>一种实现方式</strong></p><ul><li>数据中心 + 云平台管理系统</li><li>软件定义数据中心：软件定义计算，软件定义存储，软件定义网络，软件定义安全</li></ul><h3 id="云计算架构"><a href="#云计算架构" class="headerlink" title="云计算架构"></a>云计算架构</h3><h4 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h4><p>云体</p><ul><li>云计算的物质基础，云计算使用的资源集合，构成云计算的软硬件环境，如网络、服务器、存储器、交换机等，广义的云体包括数据中心机器辅助设施如电力、空调、机架、冷却等系统。</li></ul><p>云栈</p><ul><li>又称云平台，在云上建造的运行环境，能够支持应用程序的发布、运行、监控、调度、伸缩，并为应用程序提供辅助服务机制，如访问控制、权限管理等。</li></ul><p>云计算</p><ul><li>利用云体和云平台所进行的计算或处理——云计算可以在云体上直接进行，也可以在云平台上进行。无论在哪个层面开展，只要符合“按量计费、资源可伸缩”就是云计算。</li><li>云存储、云服务、在云上运行自己的软件或算法，都是云计算。</li><li>云计算是人们利用云体和云平台所从事的活动。</li></ul><h5 id="逻辑云栈"><a href="#逻辑云栈" class="headerlink" title="逻辑云栈"></a>逻辑云栈</h5><p>云栈——提供的服务种类多，规模大，需要层次架构以便于管理（从纵向的方式来构建云计算的整体架构）</p><p>云栈的三层模式：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210252326017.png" alt="image-20221025232658834" style="zoom:50%;" /><h5 id="技术体系结构"><a href="#技术体系结构" class="headerlink" title="技术体系结构"></a>技术体系结构</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210042009691.png" alt="image-20221004200936543" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210042010200.png" alt="image-20221004201019106" style="zoom:50%;" /><h5 id="IaaS-实现方式"><a href="#IaaS-实现方式" class="headerlink" title="IaaS 实现方式"></a>IaaS 实现方式</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210252328183.png" alt="image-20221025232822038" style="zoom:50%;" /><h5 id="物理云栈-OpenStack"><a href="#物理云栈-OpenStack" class="headerlink" title="物理云栈 OpenStack"></a>物理云栈 OpenStack</h5><p>OpenStack 是一个管理云计算中计算、存储和网络，甚至是应用的通用平台，其提供 Web界面、命令行工具和应用程序接口（API）等使用接口</p><p>本质上OpenStack通过抽象和一个通用的API接口控制不同厂商提供的硬件和软件资源， 是对计算系统的更高层次的抽象</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210252331164.png" alt="image-20221025233127087" style="zoom:50%;" /><h5 id="逻辑云体"><a href="#逻辑云体" class="headerlink" title="逻辑云体"></a>逻辑云体</h5><p> 云栈是从纵向角度看云计算的整体架构；云体是从横向角度看其架构模式</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210252336306.png" alt="image-20221025233642224" style="zoom:50%;" /><h5 id="物理云体云数据中心"><a href="#物理云体云数据中心" class="headerlink" title="物理云体云数据中心"></a>物理云体云数据中心</h5><p>传统数据中心暴露的问题：</p><ul><li>过多的机器</li><li>机器利用率过低</li><li>应用迁移太困难</li><li>存储需求增长太快</li></ul><p>软件定义的数据中心，重新重视虚拟化，以提高资源利用率：</p><ul><li>不仅应用到计算节点</li><li>复制到存储、网络、安全等方方面面</li><li>软件定义计算：计算节点的虚拟化：虚拟机成为计算调度和管理的单位，不中断服务的前提下动态迁移。</li><li>软件定义存储：分离管理接口与数据读写；统一的管理接口与上层管理软件交互；数据读写可以兼容各种不同的链接方式。</li><li>软件定义网络：数据平面（数据转发）和控制平面（转发表的设置等）分离；集中控制，分布式转发。</li></ul><h3 id="云数据中心"><a href="#云数据中心" class="headerlink" title="云数据中心"></a>云数据中心</h3><h4 id="云数据中心的特征"><a href="#云数据中心的特征" class="headerlink" title="云数据中心的特征"></a>云数据中心的特征</h4><p>绿色节能；高可用性；自动化管理</p><h4 id="云数据中心网络部署"><a href="#云数据中心网络部署" class="headerlink" title="云数据中心网络部署"></a>云数据中心网络部署</h4><p>传统树结构：建造方便简单，但不利于拓展升级，不够健壮</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131933371.png" alt="image-20221013193357250" style="zoom:50%;" /><p>云数据中心需要：低成本、高可扩展性、低配置开销、健壮性、节能</p><h5 id="改进树结构——FatTree"><a href="#改进树结构——FatTree" class="headerlink" title="改进树结构——FatTree"></a>改进树结构——FatTree</h5><ul><li><p>K叉树，K个Pod(集装器)，每个Pod有K个交换机，其中K/2个接入交换机，K/2个汇聚交换机</p></li><li><p>Pod中每个交换机有K个接口，K/2个接主机，K/2个接汇聚；K/2个接接入，K/2个接核心</p></li><li><p>有(K/2)^2个核心交换机，每个交换机K个端口接K个汇聚交换机</p></li><li><p>一个Pod内的所有交换机相互连接：完全二分图</p></li><li><p>一个Pod内的每个汇聚交换机与一部分核心交换机连接，但是一个Pod和每一个核心交换机都有连接</p></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131937108.png" alt="image-20221013193704955" style="zoom:50%;" /><p>两级路由表，使Pod间的流量均匀分布于核心交换机</p><p>任意两个不同Pod主机间存在K条路径</p><p>与传统层次结构相比，FatTree有如下特点：</p><ul><li>消除了树形结构上层链路对吞吐量的限制</li><li>为内部节点间通信提供多条并行链路</li><li>与现有数据中心网络使用的以太网结构和IP配置的服务器兼容</li><li>布线复杂；扩展时需要重构；受到端口数限制</li></ul><p>FatTree的扩展性受限于核心交换机的端口数量</p><h5 id="改进树结构——VL2"><a href="#改进树结构——VL2" class="headerlink" title="改进树结构——VL2"></a>改进树结构——VL2</h5><p>VL2特点：</p><ul><li>扁平寻址，允许服务实例被放置到网络覆盖的任何地方</li><li>负载均衡将流量统一分配到网络路径</li><li>终端系统的地址解析拓展到巨大的服务器池</li></ul><p>核心思想：</p><ul><li>使用FatTree同样的拓扑结构建立扁平的第二层网络</li></ul><p>具体机制</p><ul><li>IP地址仅仅作为名字使用，没有拓扑含义；将服务器的名字与其位置分开</li><li>使用可扩展、可靠的目录系统来维持名字和位置间的映射</li><li>当服务器发送分组时，服务器上的VL2代理开启目录系统以得到实际的目的位置，然后将分组发送到目的地</li></ul><h5 id="递归层次"><a href="#递归层次" class="headerlink" title="递归层次"></a>递归层次</h5><ul><li>DCell</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131949173.png" alt="image-20221013194957026" style="zoom:50%;" /><ul><li>FiConn</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131953140.png" alt="image-20221013195352016" style="zoom:50%;" /><ul><li>BCube</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131956063.png" alt="image-20221013195601954" style="zoom:50%;" /><h5 id="光交换网络"><a href="#光交换网络" class="headerlink" title="光交换网络"></a>光交换网络</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132000709.png" alt="image-20221013200045561" style="zoom:50%;" /><h5 id="无线数据中心网络"><a href="#无线数据中心网络" class="headerlink" title="无线数据中心网络"></a>无线数据中心网络</h5><p>静态链路和有线接口在大量高突发流量和高负载服务器情况下降低数据中心网络性能，无线网络的广播机制能够克服这个问题</p><p>无需重新布线即可灵活调整拓扑结构，但提供足够带宽的前提下传输距离有限</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132002114.png" alt="image-20221013200249990" style="zoom:50%;" /><h5 id="软件定义网络"><a href="#软件定义网络" class="headerlink" title="软件定义网络"></a>软件定义网络</h5><p>OpenFlow</p><h4 id="绿色节能技术"><a href="#绿色节能技术" class="headerlink" title="绿色节能技术"></a>绿色节能技术</h4><p>配电系统节能技术；空调系统节能技术；集装箱数据中心节能技术；节能策略和算法研究；新能源应用</p><h4 id="自动化管理"><a href="#自动化管理" class="headerlink" title="自动化管理"></a>自动化管理</h4><h4 id="容灾备份"><a href="#容灾备份" class="headerlink" title="容灾备份"></a>容灾备份</h4><h5 id="标准等级"><a href="#标准等级" class="headerlink" title="标准等级"></a>标准等级</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132008261.png" alt="image-20221013200842102" style="zoom:50%;" /><h5 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132009878.png" alt="image-20221013200929790" style="zoom:50%;" /><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>虚拟化技术是云计算的核心技术</p><p>虚拟化技术的本质：添加虚拟化层将物理设备逻辑化，实现软硬件解耦</p><p>虚拟化技术核心思想：利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源，在虚拟资源上可安装部署多个虚拟机，实现多用户共享物理资源</p><h4 id="服务器虚拟化层级"><a href="#服务器虚拟化层级" class="headerlink" title="服务器虚拟化层级"></a>服务器虚拟化层级</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301646751.png" alt="image-20220930164619323" style="zoom:35%;" /><h5 id="硬件级虚拟化"><a href="#硬件级虚拟化" class="headerlink" title="硬件级虚拟化"></a>硬件级虚拟化</h5><p>添加一个称为虚拟化层的软件，管理客户操作系统，使其能够独立于主机操作系统同时运行在同一硬件上</p><ul><li><p>三个要求：</p><ul><li><p>同质：提供与原始硬件机器基本一致的环境</p></li><li><p>高效：运行在虚拟硬件环境中的程序性能损失较低</p></li><li><p>资源受控：系统资源处于 VMM (<em>Virtual Machine Monitor</em>) 的完全控制之中</p></li></ul></li><li><p>优势：</p><ul><li>封装性：以虚拟机为粒度，运行环境的保存和部署方便</li><li>多实例：提高计算机性能利用率，降低资源消耗</li><li>隔离：虚拟机中的应用程序可以在自己的操作系统中独立运行（安全性、测试场景）</li><li>硬件无关：无缝跨硬件迁移（云计算环境中虚拟机迁移很重要）</li><li>特权功能：在虚拟化层添加特权功能，不能被客户机绕过 ；事件记录和回放</li></ul></li></ul><p>客户机操作系统的敏感指令都是特权指令才能够实现高效的虚拟化——陷入VMM</p><ul><li><p><strong>CPU 虚拟化</strong></p><p>  任意时刻一个物理 CPU 只能运行一个虚拟 CPU</p><p>  每个客户操作系统可以使用一个或多个虚拟 CPU</p><p>  各个操作系统之间虚拟 CPU 运行相互隔离，互不影响</p><p>  解释执行：来自操作系统的指令由 VMM 解释成执行函数到硬件上执行（模拟执行，Java 虚拟机同样）</p><p>  扫描与修补：部分指令（敏感指令）模拟执行，部分指令（非敏感指令）监控执行</p><ul><li><p>基于软件的完全虚拟化（由 VMM 全权掌控，速度慢）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302139221.png" alt="image-20220930213941167" style="zoom:50%;" /></li><li><p>基于硬件的辅助虚拟化（对硬件的操作权限进行划分：根模式→VMM，非根模式→客户机，即硬件能意识到虚拟环境的存在）</p>  <center>      <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302148784.png" alt="image-20220930214829754" style="zoom:40%;" />      <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302149053.png" alt="image-20220930214859997" style="zoom:40%;" />  </center></li><li><p>改操作系统的类虚拟化（修改暴露给虚拟机的硬件抽象和上层操作系统，客户机操作系统和 VMM 配合实现虚拟化，即修改后的操作系统能意识到虚拟环境的存在）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302157414.png" alt="image-20220930215713319" style="zoom:50%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302157645.png" alt="image-20220930215748568" style="zoom:50%;" /></li></ul></li><li><p><strong>内存虚拟化</strong></p><p>  虚拟地址 GVA → 客户机物理地址 GPA → 宿主机物理地址 HPA</p><p>  VMM 需要维护客户机物理地址和宿主机器的机器地址之间的映射；截获虚拟机对客户机物理地址的访问，并根据所记录的映射关系，转换成机器地址</p><ul><li><p>基于软件的完全虚拟化</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301712764.png" alt="image-20220930171243657" style="zoom:50%;" /></li><li><p>基于硬件的辅助虚拟化（通过扩展页表，在硬件上支持 GVA-GPA-HPA 的两次地址转换）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301714151.png" alt="image-20220930171445041" style="zoom:50%;" /></li><li><p>改操作系统的类虚拟化（客户机操作系统直接使用 VMM 的机器地址到物理地址的翻译表更新页表映射）</p></li></ul></li><li><p><strong>I/O 虚拟化</strong></p><ul><li><p>基于软件的完全虚拟化</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301704623.png" alt="image-20220930170430482" style="zoom:50%;" /></li><li><p>基于硬件的辅助虚拟化（客户机直接访问I/O地址空间，设备直接访问客户机内存）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301707204.png" alt="image-20220930170742090" style="zoom:60%;" /></li><li><p>改操作系统的类虚拟化（修改客户操作系统，使其通过 VMM 提供的接口直接与物理设备交互）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301709917.png" alt="image-20220930170929793" style="zoom:60%;" /></li></ul></li></ul><h5 id="操作系统级虚拟化"><a href="#操作系统级虚拟化" class="headerlink" title="操作系统级虚拟化"></a>操作系统级虚拟化</h5><p>没有 Hypervisor / VMM，在主机操作系统中插入一个虚拟化层</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301731842.png" alt="image-20220930173153736" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301732013.png" alt="image-20220930173233909" style="zoom:45%;" /></center>#### 不同层级虚拟化技术对比<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210051520653.png" alt="image-20221005152014471" style="zoom:50%;" /><h4 id="云数据中心的虚拟化"><a href="#云数据中心的虚拟化" class="headerlink" title="云数据中心的虚拟化"></a>云数据中心的虚拟化</h4><h5 id="服务器虚拟化"><a href="#服务器虚拟化" class="headerlink" title="服务器虚拟化"></a>服务器虚拟化</h5><ul><li>虚拟机和容器共存，容器的地位不断提升，目前与虚拟机相当</li><li>高效率的unikernel技术<ul><li>unikernel是使用库操作系统（LibOS）构建的专用的、单一地址空间机器镜像</li><li>LibOS库操作系统：在应用程序层中实施访问控制和隔离，用户应用无需在用户模式和内核模式间切换，直接访问硬件；然而多 个应用程序同时运行时隔离性不好</li><li>可使用操作系统虚拟化（虚拟机监控器VMM）克服硬件资源隔离缺陷：LibOS通过VMM驱动物理硬件，像虚拟机一样运行</li></ul></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132013617.png" alt="image-20221013201349545" style="zoom:50%;" /><h5 id="存储虚拟化"><a href="#存储虚拟化" class="headerlink" title="存储虚拟化"></a>存储虚拟化</h5><p>存储虚拟化将系统中分散且异构的存储资源整合起来，形成一个统一的连续编址的逻辑存储空间</p><p>存储虚拟化能够：提高存储资源利用率，降低单位存储空间成本，降低存储管理的负担和复杂性</p><p>一般模型：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132027550.png" alt="image-20221013202725455" style="zoom:50%;" /><p>具体实现：</p><ul><li>基于主机的存储虚拟化</li><li>基于存储设备的存储虚拟化</li><li>基于网络的存储虚拟化</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132028821.png" alt="image-20221013202853677" style="zoom:50%;" /><h5 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h5><p>云数据中心的业务集中度、服务的客户数量远远超过传统数据中心，对网络的高带宽、低拥塞的要求更高</p><p>云数据中心对网络的需求：</p><ul><li>提高数据传输效率：应对数据同步、备份、虚拟机迁移等的大流量</li><li>提高管理效率：采用统一的交换网络减少布线、维护和扩容的成本</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132029018.png" alt="image-20221013202957800" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132030266.png" alt="image-20221013203024225" style="zoom:50%;" /><h4 id="云环境中的虚拟机迁移"><a href="#云环境中的虚拟机迁移" class="headerlink" title="云环境中的虚拟机迁移"></a>云环境中的虚拟机迁移</h4><h5 id="虚拟机迁移的需求"><a href="#虚拟机迁移的需求" class="headerlink" title="虚拟机迁移的需求"></a>虚拟机迁移的需求</h5><ul><li>云计算中心物理服务器负载处于动态变化中，当无法提供额外物理资源而为了负载平衡，可将占用热门物理资源的虚拟机迁移到其他物理服务器</li><li>物理服务器定期升级的需要，升级前将虚拟机迁移到其他物理服务器，等升级完成再迁移回来</li></ul><p>云计算中关注的重点：实时迁移</p><h5 id="虚拟机迁移的具体内容"><a href="#虚拟机迁移的具体内容" class="headerlink" title="虚拟机迁移的具体内容"></a>虚拟机迁移的具体内容</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132036696.png" alt="image-20221013203657514" style="zoom:50%;" /><p>均需要基于有效的虚拟化技术</p><h3 id="OpenStack-开源云计算平台"><a href="#OpenStack-开源云计算平台" class="headerlink" title="OpenStack 开源云计算平台"></a>OpenStack 开源云计算平台</h3><p>OpenStack 是开源云计算平台（云操作系统），可控制整个数据中心的大型计算，存储和网络资源池</p><p>管理员能够通过Web界面、命令行或 API 接口控制、配置资源；用户可以通过 Web 界面使用资源</p><p>OpenStack 的定位：云计算系统的控制面和执行面</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261032724.png" alt="image-20221026103206644" style="zoom:50%;" /><p>除了云操作系统OpenStack，构建云计算还需要很多其他东西：底层驱动 + 上层应用程序</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261033962.png" alt="image-20221026103314898" style="zoom:50%;" /><h5 id="云操作系统"><a href="#云操作系统" class="headerlink" title="云操作系统"></a>云操作系统</h5><p>构架于服务器、存储、网络等<strong>基础硬件资源</strong>和单机操作系统、中间件、数据库等<strong>基础软件</strong>之上，管理海量的基础硬件、软件资源的云平台<strong>综合管理系统</strong>：</p><ul><li>管理和驱动海量服务器、存储等基础硬件，将数据中心的硬件资源逻辑上整合成一台服务器</li><li>为云应用软件提供统一的、标准的接口</li><li>管理海量的计算任务以及资源调配和迁移</li></ul><p>特点：</p><ul><li>网络化：将用户计算需求作为任务通过网络发送给各个处于不同地理位置的服务器处理，通过网络返回结果 </li><li>安全：采用多种多样的安全保障措施保证数据安全。内存安全、数据传输安全（加密）、持久存储安全（冗 余、备份）</li><li>计算的可扩充性：动态申请网络硬件资源为用户服务——本地硬件资源无需扩展</li></ul><h4 id="OpenStack-简介"><a href="#OpenStack-简介" class="headerlink" title="OpenStack 简介"></a>OpenStack 简介</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul><li>既是一个开源软件，也是一个项目，还是一个社区，提供了一个部署云的操作平台或工具集。用 OpenStack 易于构建虚拟计算或存储服务的云，既可以为公有云、私有云，也可以为大云、小云提供可扩展、灵活的云计算</li><li>OpenStack 是一个管理<strong>计算、存储和网络资源</strong>的数据中心云计算开放平台，通过一个仪表板，为管理 员提供了所有的管理控制，同时通过 Web 界面为其用户提供资源</li><li>Rackspace 公司的 “云文件” 平台 Swift + 美国宇航局 NASA “星云” 平台 Nova</li></ul><h5 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h5><ul><li>开放：任何个人、企业、组织、政府机构，只要遵循相关开源协议，都可以使用、拿到源代码</li><li>灵活：带来可以定制的好处，每一个类型组建都有多个替代品，不会因为某一个组件的原因受到限制</li><li>可扩展：各个组件是相互独立的项目，各个组件可以从内部解决可扩展的问题，而不影响其他组件</li></ul><h5 id="参考架构"><a href="#参考架构" class="headerlink" title="参考架构"></a>参考架构</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261038593.png" alt="image-20221026103833509" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261039370.png" alt="image-20221026103920264" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261042381.png" alt="image-20221026104209256" style="zoom:50%;" /><h5 id="计算和存储、网络、镜像服务关系"><a href="#计算和存储、网络、镜像服务关系" class="headerlink" title="计算和存储、网络、镜像服务关系"></a>计算和存储、网络、镜像服务关系</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261043542.png" alt="image-20221026104343363" style="zoom:50%;" /><h5 id="虚拟机创建过程"><a href="#虚拟机创建过程" class="headerlink" title="虚拟机创建过程"></a>虚拟机创建过程</h5><ul><li><p>资源准备</p><ul><li><p>通过Keystone进行用户身份认证，通过认证后，用户即可与Openstack API节点通信，触发创建请求</p></li><li><p>通过调度器获得启动虚拟机的最佳位置：通过工作守护进程获得物理节点上的资源状态；Nova-scheduler</p></li></ul></li><li><p>创建流程</p><ul><li><p>调用身份认证进行身份验证</p></li><li><p>生成用于后续调用的令牌</p></li><li><p>访问镜像服务以获取镜像列表，并获取目标基础镜像</p></li><li><p>处理计算服务 API 请求</p></li><li><p>处理计算服务对安全组和密钥调用的请求</p></li><li><p>调用网络服务 API 确定可用网络</p></li><li><p>通过计算节点调度程序选择 Hypervisor 节点</p></li><li><p>调用块存储服务 API 为实例分配卷</p></li><li><p>通过计算服务API调用在 Hypervisor 节点启动实例</p></li><li><p>调用网络服务API为实例分配网络资源</p></li></ul></li></ul><h5 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h5><h5 id="物理部署示例"><a href="#物理部署示例" class="headerlink" title="物理部署示例"></a>物理部署示例</h5><h5 id="四种节点"><a href="#四种节点" class="headerlink" title="四种节点"></a>四种节点</h5><h5 id="物理部署模型-估算"><a href="#物理部署模型-估算" class="headerlink" title="物理部署模型-估算"></a>物理部署模型-估算</h5><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><h5 id="DevOps-和-Openstack"><a href="#DevOps-和-Openstack" class="headerlink" title="DevOps 和 Openstack"></a>DevOps 和 Openstack</h5><h5 id="OpenStack-Ansible"><a href="#OpenStack-Ansible" class="headerlink" title="OpenStack Ansible"></a>OpenStack Ansible</h5><h4 id="云控制器"><a href="#云控制器" class="headerlink" title="云控制器"></a>云控制器</h4><h4 id="计算节点"><a href="#计算节点" class="headerlink" title="计算节点"></a>计算节点</h4><h5 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h5><h5 id="Magnum"><a href="#Magnum" class="headerlink" title="Magnum"></a>Magnum</h5><h4 id="存储节点"><a href="#存储节点" class="headerlink" title="存储节点"></a>存储节点</h4><h5 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h5><h5 id="Cinder"><a href="#Cinder" class="headerlink" title="Cinder"></a>Cinder</h5><h4 id="网络节点"><a href="#网络节点" class="headerlink" title="网络节点"></a>网络节点</h4><h5 id="Neutron"><a href="#Neutron" class="headerlink" title="Neutron"></a>Neutron</h5><h5 id="虚拟网络-VLAN-实现"><a href="#虚拟网络-VLAN-实现" class="headerlink" title="虚拟网络 VLAN 实现"></a>虚拟网络 VLAN 实现</h5><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><h4 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h4><h5 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h5><p>集中式计算：完全依赖一台大型的中心计算机的处理能力，即主机</p><p>分布式计算：多个通过网络互联的计算机都具有一定的计算能力，他们相互之间传递数据，实现信息共享，协作共同完成一个处理任务</p><p>分布式系统：将海量计算能力才能处理的问题拆分成许多小块，将小块分配给同一套系统中不同的计算机节点处理，最后将分开计算的结果合并得到最终结果的系统</p><p>分布式计算的一般步骤：</p><ul><li>设计分布式计算模型；分布式任务分配；编写并执行分布式程序【难点：计算任务划分 + 多节点通信】</li></ul><h5 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h5><p>ACID原则：数据库事务正常执行的四个原则：原子性(Atomicity)，一致性(Consistency)，独立性(Isolation)，持久性(Durability)</p><p>CAP理论：一个分布式系统最多能够同时满足一致性(consistency)、可用性(Availability)、分区容错性(Partition tolerance)中的两项</p><p>对于大多数大型互联网服务而言，节点故障、网络故障是常态，均采取保证AP的策略，对于一致性退而求其次，只保证最终一致性</p><p>BASE理论——追求最终一致性</p><ul><li>Basically Available-基本可用：系统出现故障时，允许损失部分可用性，保证核心可用</li><li>Soft State-软状态：允许系统存在中间状态，但中间状态不会影响系统的整体可用性</li><li>Eventual Consistency-最终一致性：所有数据副本经过一定时间后，能最终达到一致的状态</li></ul><p>一致性算法：在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致</p><ul><li>基于消息传递的一致性算法Paxos：<a href="https://www.cnblogs.com/linbingdong/p/6253479.html">https://www.cnblogs.com/linbingdong/p/6253479.html</a> </li><li>基于消息传递的一致性算法Raft： <a href="https://raft.github.io/">https://raft.github.io/</a> </li></ul><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>容错性：能在某些节点发生故障的情况下，利用容错机制避免整套系统服务都不可用</li><li>高可扩展性：能在运行过程中自由地对系统内部节点或现有功能进行扩充，而不影响现有服务的运行</li><li>开放性：决定了一个系统是否具备自我扩展和与其他系统集成的能力；开放的接口+接口遵循协议=更好</li><li>并发处理能力：系统必须保证对象的操作在并发环境中能够安全使用，保证数据一致性和系统高可用性</li><li>透明性：无需让用户知晓系统的内部细节，暴露给用户访问资源和服务的方式，将系统看作是一个整体</li></ul><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>分布式存储系统</p><ul><li>结构化存储：事务处理系统或关系型数据库，数据划分为表、字段和表关系，如分布式MySQL</li><li>非结构化存储：强调很高的可扩展性，存储数据非常自由，代表是分布式文件系统，如HDFS，GFS等</li><li>半结构化存储：解决非结构化数据随机访问性能差的问题，如NoSQL，Key-Value Store，对象存储</li><li>In-memory存储：基于内存的存储系统，利用内存实现极高读写性能，例如Memcached和Redis</li><li>NewSQL：既具备结构化存储的ACID事务支持，又拥有NoSQL半结构化存储的强大可扩展能力</li></ul><p>分布式计算系统</p><ul><li>传统基于消息的系统：MPI（Message Passing Interface）</li><li>Dataflow系统：将计算抽象为高层算子，算子组合为有向无环图，由后端调度引擎并行化调度执行<ul><li>Hadoop：MapReduce；Spark：更多类型的算子</li></ul></li><li>流式计算、图计算、分布式机器学习——Spark都实现了这些类型的分布式计算</li></ul><p>分布式资源管理系统：支持多种计算框架、高可扩展、高容错、高资源利用率、细粒度资源分配</p><ul><li>Yarn：Hadoop 2.0版本，解决了原来Hadoop扩展性较差的问题，可以在框架下自定义算子</li><li>Apache Mesos：加州大学伯克利分校的一个研究项目，现在属于Apache基金会的一个项目</li><li>Spark Standalone：Spark自带的简单的资源管理系统，负责跟踪集群状态并调度计算任务</li><li>Kubernets：谷歌开发的一个强大的容器编排框架，用户通过Kubernets管理容器，不需要和底层交互</li></ul><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>网格系统：</p><ul><li>一种能够整合的合作使用的由多家组织拥有和管理的高端计算机、网络、数据库、实验设备等基础设施</li><li>网格是一类并行、分布式系统，能够在运行时动态分享、选择、聚合地理散布得自治资源，依据它们的可用性、能力、性能、代价以及用户对服务质量的需求，构建满足用户需求的设备组合</li><li>网格技术解决的主要问题是合作研究中的社会问题，包括：<ul><li>改善分布式管理，同时保持对本地资源的全面控制</li><li>改善数据可用性，识别问题和数据访问模式的解决方案</li><li>为学者提供友好的环境，能够访问更大范围的地理上分布的设备，提高产率</li></ul></li></ul><p>P2P系统：</p><ul><li>是一种在对等者之间分配任务和工作负载的分布式应用架构的系统</li><li>所有参与者角色相同，都对外共享它们拥有的一部分硬件资源，这些资源可以被系统内其他参与者访问</li><li>性质：高度分散化；自组织性；多管理域</li><li>特点（优点）：部署门槛低；增长速度快；容错性高；资源的丰富性和多样性高</li><li>应用：共享及分发文件；流媒体；网络电话；志愿计算等</li></ul><p>区块链：</p><ul><li><p>一种去中心化、不可篡改、可追溯、多方共同维护的分布式数据库系统</p></li><li><p>集成了P2P协议、非对称加密技术、共识机制、块链结构等多种技术，解决数据的可信问题</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132248086.png" alt="image-20221013224834015" style="zoom:50%;" /></li></ul><h5 id="分布式计算、存储和资源管理系统—Hadoop-2-0"><a href="#分布式计算、存储和资源管理系统—Hadoop-2-0" class="headerlink" title="分布式计算、存储和资源管理系统—Hadoop 2.0"></a>分布式计算、存储和资源管理系统—Hadoop 2.0</h5><ul><li>Yarn做分布式资源管理</li><li>HDFS做分布式存储</li><li>MapReduce做分布式计算</li></ul><p>分布式存储：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251649215.png" alt="image-20221025164945152" style="zoom:50%;" /><p>分布式计算：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251651507.png" alt="image-20221025165158421" style="zoom:50%;" /><p>分布式计算——Hadoop MapReduce 框架：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251653531.png" alt="image-20221025165321351" style="zoom:50%;" /><p>资源管理——Yarn：管理计算机资源、提供用户和程序访问系统资源的API</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251654123.png" alt="image-20221025165433968" style="zoom:50%;" /><p>资源管理——Yarn是可编程的，不仅仅支持自带的MapReduce，还可以自定义算子</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251655762.png" alt="image-20221025165556672" style="zoom:50%;" /><h5 id="分布式计算和资源管理系统—Spark"><a href="#分布式计算和资源管理系统—Spark" class="headerlink" title="分布式计算和资源管理系统—Spark"></a>分布式计算和资源管理系统—Spark</h5><p>没有类似 HDFS 的分布式文件（存储）系统，但是有一套分布式内存管理系统（核心）</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251641105.png" alt="image-20221025164127997" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251642695.png" alt="image-20221025164200617" style="zoom:45%;" /></center><p>Spark 是建立在弹性分布式数据集（RDD）之上的</p><p>RDD 使得 Spark 可以用一致的方式处理大数据的不同应用场景</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251646318.png" alt="image-20221025164642100" style="zoom:50%;" /><h4 id="分布式存储系统"><a href="#分布式存储系统" class="headerlink" title="分布式存储系统"></a>分布式存储系统</h4><h5 id="数据和系统类型"><a href="#数据和系统类型" class="headerlink" title="数据和系统类型"></a>数据和系统类型</h5><ul><li><p>分布式文件系统——泛指以分布式的方式存储文件的系统，文件可以多种形式存在</p><ul><li>三种数据类型：二进制大对象(Blob)，定长块，大文件</li><li>提供不同类型的存储服务：对象存储、文件存储、块存储</li><li>可以作为分布式健值存储、分布式表、分布式数据的底层存储（GFS，弹性块存储EBS，Ceph）</li></ul></li><li><p>分布式健值系统</p><ul><li>用来存储关系简单的半结构化数据，提供基于主键的 CRUD 功能</li><li>可以看作是对分布式表的简化，一般用来作缓存，例如 Memcached</li><li>常用技术是一致性 Hash</li></ul></li><li><p>分布式表</p><ul><li>用于存储半结构化数据；以表格为单位组织数据，一个表格有多行，通过主键标识一行</li><li>不仅仅支持简单的CRUD，还支持扫描某个主键的范围和范围查找功能（Google Bigtable）</li></ul></li><li><p>分布式数据库</p><ul><li>基于传统关系型数据库发展而来，例如分布式 MySQL</li></ul></li></ul><h5 id="文件系统的发展"><a href="#文件系统的发展" class="headerlink" title="文件系统的发展"></a>文件系统的发展</h5><ul><li>单机文件系统：使用树型数据结构组织文件、目录以及访问控制；三类数据模型：文件、关系、健值，对应文件系统、数据库、健值存储</li><li>网络文件系统：让用户能够以访问本地文件系统的方式访问远程机器上的文件，提供跨平台的文件共享系统</li><li>并行文件系统：用在大规模并行处理体系结构中，保证一个业务的多个并行任务可以同时对同一个文件的不同位置并行处理</li><li>分布式文件系统：采用集中式管理、分布式存储的架构，将文件实际存储在多个不同的节点上，且每一个部分都有多个副本</li><li>高通量文件系统：专指为大型数据中心设计的分布式文件系统，将数据中心所有的低成本存储资源有效地组织起来服务于上层多种应用的数据存储需求和数据访问需求</li></ul><p>分布式存储系统面临的重要问题：</p><ul><li>如何将数据均匀的分布到多个存储节点</li><li>如何保证提供高可用性的数据多副本始终保持一致</li><li>如何检测节点故障并高效应对</li></ul><p>分布式存储系统的评价指标：</p><ul><li>性能：<ul><li>吞吐率-在某一段时间可以处理的请求总数</li><li>系统响应时间-从某个请求发出到收到结果的时间</li></ul></li><li>可用性：<ul><li>指在系统面对各种异常时可以提供的正常服务能力</li><li>用停止服务的时间和正常时间比重</li></ul></li><li>度量一致性：<ul><li>越强的一致性模型用户使用起来越简单——可能牺牲可用性或分区容错性</li></ul></li><li>可扩展性：<ul><li>能否通过增加服务器数量提高系统能力或者增加服务器的难度</li><li>理想的“线性可扩展”</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 每日一题（摆了）</title>
      <link href="/2022/09/05/Leetcode/"/>
      <url>/2022/09/05/Leetcode/</url>
      
        <content type="html"><![CDATA[<h3 id="2022-09"><a href="#2022-09" class="headerlink" title="2022.09"></a>2022.09</h3><h4 id="9-5"><a href="#9-5" class="headerlink" title="9.5"></a>9.5</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209060904247.png" alt="image-20220906090456163" style="zoom:50%;" /><p>标签：二叉树序列化，哈希表，DFS</p><p>思路：用序列化的方式表示子树，通过字符串比较来判断子树是否重复</p><p>具体操作：通过 dfs 将二叉树序列化成 “root(左子树)(右子树)” 的形式，中间过程包含了所有子树的序列化结果，通过哈希表来保存重复的子树的根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 建立起序列化结果到子树的映射</span></span><br><span class="line">    Map&lt;String, TreeNode&gt; serialToTree = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;TreeNode&gt; repeated = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(repeated);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serial</span> <span class="operator">=</span> </span><br><span class="line">            node.val + <span class="string">&quot;(&quot;</span> + dfs(node.left) + <span class="string">&quot;)(&quot;</span> + dfs(node.right) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (serialToTree.containsKey(serial)) &#123; </span><br><span class="line">            repeated.add(serialToTree.get(serial));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; serialToTree.put(serial, node); &#125;</span><br><span class="line">        <span class="keyword">return</span> serial;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-6"><a href="#9-6" class="headerlink" title="9.6"></a>9.6</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209060920686.png" alt="image-20220906092058579" style="zoom:50%;" /><p>（暴力求解会超时）</p><p>标签：动态规划，哈希表</p><p>思路：分别计算每个字符的贡献，对于下标为 <em>i</em> 的字符，其在字符串中上一次出现在下标 <em>j</em> 处，下一次出现在下标 <em>k</em> 处，那么其贡献的个数为 <strong>(i-j) * (k-i)</strong></p><p>具体操作：先扫描一遍字符串，把每个出现的字符及其对应的位置（下标）通过 list 保存下来并维护一个映射关系（为了计算方便需要，每个 list 开头为 -1，结尾为 s.length()），然后遍历扫描结果按照思路中的计算方法进行计算并累加求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniqueLetterString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(ch)) &#123;</span><br><span class="line">            map.put(ch, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            map.get(ch).add(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(ch).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : map.keySet()) &#123;</span><br><span class="line">        List&lt;Integer&gt; tmp = map.get(ch);</span><br><span class="line">        tmp.add(s.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; tmp.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            res += (tmp.get(i) - tmp.get(i-<span class="number">1</span>)) * (tmp.get(i+<span class="number">1</span>) - tmp.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209070905821.png" alt="image-20220907090554737" style="zoom:50%;" /><p>思路：通过 <em>split(“\s+”)</em> 方法获取所有的单词（注意去掉前置和后置的空格，否则得到的单词中有空串）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reorderSpaces</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> text.length();</span><br><span class="line">    String[] words = text.trim().split(<span class="string">&quot;\s+&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numOfSpace</span> <span class="operator">=</span> len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; ++i) &#123;</span><br><span class="line">        numOfSpace -= words[i].length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">intervalSpaceCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        intervalSpaceCnt = numOfSpace / (list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSpaceCnt</span> <span class="operator">=</span> numOfSpace - intervalSpaceCnt * (list.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(list.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; intervalSpaceCnt; ++j) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; leftSpaceCnt; ++j) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-8"><a href="#9-8" class="headerlink" title="9.8"></a>9.8</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209081036138.png" alt="image-20220908103617060" style="zoom:50%;" /><p>先考虑特殊情况，当 k = n-1 时，通过大小交替的排序方式可以满足题目要求，即 [1,n,2,n-1,3,n-2,4, …]</p><p>故想到，可以将 1~n-k 先按顺序排列，剩 k 个数大小交替排列，即 [1, 2, …, n-k, n, n-k+1, n-1, n-k+2,…]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] constructArray(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n - k; ++i) &#123;</span><br><span class="line">        ans[i-<span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">even</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ans[n - k + j] = n - odd;</span><br><span class="line">            ++odd;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[n - k + j] = n - even;</span><br><span class="line">            --even;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-9"><a href="#9-9" class="headerlink" title="9.9"></a>9.9</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209090949235.png" alt="image-20220909094926123" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(String[] logs)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; logs.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logs[i].equals(<span class="string">&quot;./&quot;</span>)) &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logs[i].equals(<span class="string">&quot;../&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (steps &gt; <span class="number">0</span>) --steps;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ++steps;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-10"><a href="#9-10" class="headerlink" title="9.10"></a>9.10</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209101151018.png" alt="image-20220910115125927" style="zoom:50%;" /><p>标签：深度搜索，二叉搜索树</p><p>思路：根据二叉搜索树的性质，有以下情况</p><ul><li>若某一节点的<strong>左</strong>子节点<strong>不在</strong>边界范围内，则该节点的<strong>左子树</strong>都<strong>不在</strong>边界范围内</li><li>若某一节点的<strong>右</strong>子节点<strong>不在</strong>边界范围内，则该节点的<strong>右子树</strong>都<strong>不在</strong>边界范围内</li><li>若某一节点的<strong>左</strong>子节点<strong>在</strong>边界范围内，则该节点的<strong>右子树</strong>都<strong>在</strong>边界范围内</li><li>若某一节点的<strong>右</strong>子节点<strong>在</strong>边界范围内，则该节点的<strong>左子树</strong>都<strong>在</strong>边界范围内</li></ul><p>故可以迭代地将不满足条件的节点从二叉搜索树中剔除</p><p>注意：迭代之前需要用类似的方法找到一个满足条件的新的根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">null</span> &amp;&amp; (root.val &lt; low || root.val &gt; high)) &#123;</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; low) &#123; root = root.right; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; root = root.left; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.left.val &lt; low) &#123; node.left = node.left.right; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; node = node.left; &#125;</span><br><span class="line">&#125;</span><br><span class="line">node = root;</span><br><span class="line"><span class="keyword">while</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.right.val &gt; high) &#123; node.right = node.right.left; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; node = node.right; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另附上递归（深度搜索）的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; high) &#123; <span class="keyword">return</span> trimBST(root.left, low, high); &#125;</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; low) &#123; <span class="keyword">return</span> trimBST(root.right, low, high); &#125;</span><br><span class="line">root.left = trimBST(root.left, low, high);</span><br><span class="line">root.right = <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-11"><a href="#9-11" class="headerlink" title="9.11"></a>9.11</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209110953590.png" alt="image-20190911095307193" style="zoom:50%;" /><p>标签：贪心，优先队列</p><p>思路：每个人应得的报酬根据其工作质量的比例从总报酬中分配，并需要满足不低于最低期望，如①式</p><p>记一个工人的最低期望工资与对应工作质量之比为ε，经推导，要使总报酬最低，需要总工作质量相同的情况下使得最大的ε值最小，也即，选定了最大ε值的工人之后，其余工人工作质量之和尽量小<br>$$<br>Pay_{i}=\Sigma Pay_{i}×\frac{Quality_{i}}{\Sigma Quality_{i}}≥Wage_{i};①\<br>\Sigma Pay_{i}≥\Sigma Quality_{i}×\frac{Wage_{i}}{Quality_{i}};②\<br>\Sigma Pay_{i}≥\Sigma Quality_{i}×\epsilon_{max};③\<br>$$<br>具体操作：将工人按照ε值从小到大的排序，并逐个添加到一个以工作质量为比较标准的最大堆中，保证先入堆的工人ε值较小。从第k个工人入堆开始需要计算当前k个人产生的总成本，与已有结果比较取更小者。下一个工人入堆之前，需要将已有的k个工人中工作质量最优的人剔除（最大ε值增加而总工作质量尽量地减小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">mincostToHireWorkers</span><span class="params">(<span class="type">int</span>[] quality, <span class="type">int</span>[] wage, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wage.length;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; worker = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        worker.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;quality[i], wage[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    worker.sort((a, b) -&gt; &#123; <span class="keyword">return</span> a[<span class="number">1</span>] * b[<span class="number">0</span>] - a[<span class="number">0</span>] * b[<span class="number">1</span>]; &#125;);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">    <span class="type">double</span> <span class="variable">minCost</span> <span class="operator">=</span> Double.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalQuality</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k-<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> worker.get(i)[<span class="number">0</span>];</span><br><span class="line">        totalQuality += q;</span><br><span class="line">        pq.offer(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k-<span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> worker.get(i)[<span class="number">0</span>];</span><br><span class="line">        totalQuality += q;</span><br><span class="line">        pq.offer(q);</span><br><span class="line">        <span class="type">double</span> <span class="variable">ratio</span> <span class="operator">=</span> worker.get(i)[<span class="number">1</span>] / (<span class="type">double</span>) q;</span><br><span class="line">        minCost = Math.min(minCost, totalQuality * ratio);</span><br><span class="line">        totalQuality -= pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-12"><a href="#9-12" class="headerlink" title="9.12"></a>9.12</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209122134037.png" alt="image-20220912213454957" style="zoom:50%;" /><p>思路：排序后遍历比较</p><p>具体操作：将数组降序排列，一次遍历，同时满足 <strong>①第k个数大于等于k</strong> 且 <strong>② 第k+1个数小于k</strong> 则返回k，若不满足条件①则不存在特征值，若不满足条件②则继续遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">specialArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Integer[] a = Arrays.stream(nums).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">    Arrays.sort(a, Collections.reverseOrder());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= a.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i-<span class="number">1</span>] &gt;= i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == a.length || a[i] &lt; i) &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-13"><a href="#9-13" class="headerlink" title="9.13"></a>9.13</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209131100155.png" alt="image-20220913110028095" style="zoom:50%;" /><p>思路：要使交换后一个 n 位数尽量大，应当在前 k 位已经最大的情况下，将第 k+1 位与第 k+2 到第 n 位中最大且最靠近个位的位进行交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSwap</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; intBits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; intBitsInOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">intBit</span> <span class="operator">=</span> temp % <span class="number">10</span>;</span><br><span class="line">        intBits.add(intBit);</span><br><span class="line">        intBitsInOrder.add(intBit);</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    intBitsInOrder.sort(Comparator.naturalOrder());</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intBits.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">indexToChange</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intBits.get(i) == intBitsInOrder.get(i)) <span class="keyword">continue</span>;</span><br><span class="line">        indexToChange = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (indexToChange == -<span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; indexToChange; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intBits.get(i) == intBitsInOrder.get(indexToChange)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxSwap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n-<span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j;</span><br><span class="line">                <span class="keyword">if</span> (index == indexToChange) index = i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (index == i) index = indexToChange;</span><br><span class="line">                maxSwap = maxSwap * <span class="number">10</span> + intBits.get(index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxSwap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// unreachable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-14"><a href="#9-14" class="headerlink" title="9.14"></a>9.14</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209140035840.png" alt="image-20220914003555785" style="zoom:50%;" /><p>傻子题不想动脑子了…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">trimMean</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> len * <span class="number">5</span> / <span class="number">100</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; len-n; ++i) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / (len - <span class="number">2</span>*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-15"><a href="#9-15" class="headerlink" title="9.15"></a>9.15</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209152105646.png" alt="image-20220915210536590" style="zoom:50%;" /><p>思路：过滤+排序，可以使用 Java8 中的 <em>Stream</em> 类型来清晰地处理</p><p>具体实现：<em>filter</em> 过滤流中的元素；<em>sorted</em> 对流中的元素排序；<em>map</em> 对流中的元素进行映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">filterRestaurants</span><span class="params">(<span class="type">int</span>[][] restaurants, <span class="type">int</span> veganFriendly, <span class="type">int</span> maxPrice, <span class="type">int</span> maxDistance)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Arrays.stream(restaurants)</span><br><span class="line">.filter(e -&gt; veganFriendly == <span class="number">0</span> || veganFriendly == <span class="number">1</span> &amp;&amp; e[<span class="number">2</span>] == <span class="number">1</span>)</span><br><span class="line">.filter(e -&gt; e[<span class="number">3</span>] &lt;= maxPrice)</span><br><span class="line">.filter(e -&gt; e[<span class="number">4</span>] &lt;= maxDistance)</span><br><span class="line">.sorted((a, b) -&gt; a[<span class="number">1</span>] != b[<span class="number">1</span>] ? b[<span class="number">1</span>] - a[<span class="number">1</span>] : b[<span class="number">0</span>] - a[<span class="number">0</span>])</span><br><span class="line">.map(e -&gt; e[<span class="number">0</span>])</span><br><span class="line">.toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-16"><a href="#9-16" class="headerlink" title="9.16"></a>9.16</h4><p>太难了做不出来，答案也看不懂，咕咕咕~</p><h4 id="9-17"><a href="#9-17" class="headerlink" title="9.17"></a>9.17</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209171006533.png" alt="image-20220917100645450" style="zoom:50%;" /><p>简单题美滋滋~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLengthBetweenEqualCharacters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">Set&lt;Character&gt; letters = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">letters.add(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : letters) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.indexOf(ch);</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.lastIndexOf(ch);</span><br><span class="line">maxLen = Math.max(j-i-<span class="number">1</span>, maxLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-18"><a href="#9-18" class="headerlink" title="9.18"></a>9.18</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209181754074.png" alt="image-20220918175455009" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-19"><a href="#9-19" class="headerlink" title="9.19"></a>9.19</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209191026089.png" alt="image-20220919102640021" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] frequencySort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (freqMap.containsKey(nums[i])) &#123;</span><br><span class="line">freqMap.replace(nums[i], freqMap.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">freqMap.put(nums[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Integer[] temp = Arrays.stream(nums).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">Arrays.sort(temp, (x,y) -&gt;</span><br><span class="line">freqMap.get(x) == freqMap.get(y) ? y-x : freqMap.get(x)-freqMap.get(y));</span><br><span class="line"><span class="keyword">return</span> Arrays.stream(temp).mapToInt(Integer::valueOf).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-20"><a href="#9-20" class="headerlink" title="9.20"></a>9.20</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209201951230.png" alt="image-20220920195130145" style="zoom:50%;" /><blockquote><p>不会做… 抄的网上的答案…</p></blockquote><p>思路：递归地按照从大到小的顺序把数组中的数放入k个槽位中，使得每个槽位中数的和小于等于目标和</p><p>剪枝策略：<strong>若 <code>cur[j]</code> 与 <code>cur[j-1]</code> 相等，意味着在 <code>cur[j-1]</code> 时已经完成了搜索，可跳过当前的搜索</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line"><span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">subSum</span> <span class="operator">=</span> sum / k;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="type">int</span>[] curSum = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line"><span class="keyword">return</span> dfs(nums, curSum, subSum, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] curSum, <span class="type">int</span> subSum, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; curSum.length; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; curSum[j] == curSum[j-<span class="number">1</span>]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">curSum[j] += nums[i];</span><br><span class="line"><span class="keyword">if</span> (curSum[j] &lt;= subSum &amp;&amp; dfs(nums, curSum, subSum, i-<span class="number">1</span>)) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">curSum[j] -= nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-21"><a href="#9-21" class="headerlink" title="9.21"></a>9.21</h4><p>咕咕咕~</p><h4 id="9-22"><a href="#9-22" class="headerlink" title="9.22"></a>9.22</h4><p>？？？</p><h4 id="9-23"><a href="#9-23" class="headerlink" title="9.23"></a>9.23</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231258100.png" alt="image-20220923125807981" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.head.prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.head.next = <span class="built_in">this</span>.tail;</span><br><span class="line">        <span class="built_in">this</span>.tail.prev = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="built_in">this</span>.tail.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; ++i) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        node.next = <span class="built_in">this</span>.head.next;</span><br><span class="line">        <span class="built_in">this</span>.head.next.prev = node;</span><br><span class="line">        node.prev = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="built_in">this</span>.head.next = node;</span><br><span class="line">        ++<span class="built_in">this</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        node.prev = <span class="built_in">this</span>.tail.prev;</span><br><span class="line">        <span class="built_in">this</span>.tail.prev.next = node;</span><br><span class="line">        node.next = <span class="built_in">this</span>.tail;</span><br><span class="line">        <span class="built_in">this</span>.tail.prev = node;</span><br><span class="line">        ++<span class="built_in">this</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="built_in">this</span>.length) &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.length) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; ++i) &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> curr.prev;</span><br><span class="line">            prev.next = node;</span><br><span class="line">            node.prev = prev;</span><br><span class="line">            node.next = curr;</span><br><span class="line">            curr.prev = node;</span><br><span class="line">            ++<span class="built_in">this</span>.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.length) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; ++i) &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> curr.prev;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            --<span class="built_in">this</span>.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《自动化测试》课程笔记</title>
      <link href="/2022/08/10/NJU-Software-Testing/"/>
      <url>/2022/08/10/NJU-Software-Testing/</url>
      
        <content type="html"><![CDATA[<p>课程预习资料来源：<a href="https://www.icourse163.org/learn/NJU-1001773008?tid=1450627499#/">https://www.icourse163.org/learn/NJU-1001773008?tid=1450627499#/</a></p><h2 id="预习"><a href="#预习" class="headerlink" title="预习"></a>预习</h2><h3 id="软件测试基础"><a href="#软件测试基础" class="headerlink" title="软件测试基础"></a>软件测试基础</h3><h4 id="PIE-模型"><a href="#PIE-模型" class="headerlink" title="PIE 模型"></a><em>PIE</em> 模型</h4><p>概念辨析：</p><ul><li><em>Fault</em>：程序中存在的静态错误（编程过程中产生）</li><li><em>Error</em>：程序因运行到其中的 <em>Fault(s)</em> 而进入的错误的中间状态（程序运行时产生）</li><li><em>Failure</em>：<em>Error(s)</em> 传播到程序外部，使得用户观测到与预期不符的错误行为（程序行为完成时产生）</li></ul><p><em>PIE</em> 模型：</p><ul><li>Execution/Reachability：程序中含有 <em>fault</em> 的地方必须被执行到</li><li>Infection：程序必须进入错误的中间状态（<em>error</em>）</li><li>Propagation：被感染的状态必须传播到程序外部，即导致程序错误的输出结果（产生 <em>failure</em>）</li></ul><p>针对 <em>PIE</em> 模型的分析：</p><ul><li>测试不一定能执行到带有 <em>fault</em> 的语句</li><li>测试执行到带有 <em>fault</em> 的语句，不一定会触发 <em>error</em></li><li>测试执行到带有 <em>fault</em> 的语句并触发 <em>error</em>，不一定会产生 <em>failure</em></li></ul><h4 id="软件测试术语"><a href="#软件测试术语" class="headerlink" title="软件测试术语"></a>软件测试术语</h4><p>测试用例（<em>test case</em>）：</p><ul><li>测试输入（<em>test input</em>）：<em>test data</em></li><li>测试预言（<em>test oracle</em>）：<em>expected output</em></li><li>其他（<em>others</em>）：<em>environment</em></li></ul><p>测试（<em>testing</em>）：执行测试并观测 <em>failure</em>（发现 <em>bug</em>）</p><p>调试（<em>debugging</em>）：定位、理解并改正 <em>fault</em>（修复 <em>bug</em>）</p><p>确认（<em>validation</em>）：确认规格文档是否与用户需求相符</p><p>确认（<em>verification</em>）：确认最终实现是否满足规格文档</p><p>静态测试（<em>static testing</em>）：不运行程序</p><p>动态测试（<em>dynamic testing</em>）：运行程序</p><p>黑盒测试（<em>black-box testing</em>）：不需要源代码</p><p>白盒测试（<em>white-box testing</em>）：需要源代码</p><p>灰盒测试（<em>gray-box testing</em>）：通过反编译等手段获得了部分结构信息</p><p>测试过程：<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102310315.png" alt="image-20220810231017192" style="zoom:50%;" /></p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><h4 id="测试中的图"><a href="#测试中的图" class="headerlink" title="测试中的图"></a>测试中的图</h4><p>测试路径：从初始节点到终结节点的一条路径（可以通过设定哑节点使初始节点和终结节点唯一）</p><p>测试路径代表了测试用例的执行情况（有些路径可以被多个测试用例执行到，有些路径不可被执行到）</p><p>path( <em>t</em> ) 表示测试 <em>t</em> 执行的测试路径；path( <em>T</em> ) 表示测试集合 <em>T</em> 执行的测试路径集合</p><p>本课程不考虑非确定性环境，即认为一个测试用例只能执行到一条测试路径</p><h4 id="图覆盖准则"><a href="#图覆盖准则" class="headerlink" title="图覆盖准则"></a>图覆盖准则</h4><p>语法可达（<em>Syntactic reach</em>）：通过语法构建的图中存在一条路径</p><p>语义可达（<em>Semantic reach</em>）：存在能够被执行到的测试路径</p><p>覆盖（<em>Cover</em>）：</p><ul><li>如果节点 <em>v</em> 在测试路径 <em>p</em> 中，则该测试路径 <em>p</em> 覆盖节点 <em>v</em></li><li>如果边 <em>e</em> 在测试路径 <em>p</em> 中，则该测试路径 <em>p</em> 覆盖边 <em>e</em></li><li>如果子路径 <em>p’</em> 在测试路径 <em>p</em> 中，则该测试路径 <em>p</em> 覆盖子路径 <em>p’</em></li></ul><p>测试需求（<em>Test Requirement</em>）：描述测试路径性质</p><p>测试准则（<em>Test Criterion</em>）：描述测试需求的规则</p><p>给定一个测试准则 <em>C</em>，派生出对应的测试需求集 <em>TR</em>，定义一个测试用例集 <em>T</em>  满足 <em>C</em>，当且仅当对于 <em>TR</em> 中的每个测试需求，集合 path( <em>T</em> ) 中都存在一条测试路径满足该测试需求</p><h4 id="结构化覆盖"><a href="#结构化覆盖" class="headerlink" title="结构化覆盖"></a>结构化覆盖</h4><p>顶点覆盖；边覆盖；边对覆盖（字面意思）</p><p>n-路径覆盖：为了定义的完整性，要求长度覆盖小于等于 n 的所有路径</p><p>蕴含（<em>Subsume</em>）：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151107010.png" alt="image-20220815110709940" style="zoom: 40%;" /><p>结构化覆盖的例子：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151109982.png" alt="image-20220815110904886" style="zoom:50%;" /><h4 id="控制流测试"><a href="#控制流测试" class="headerlink" title="控制流测试"></a>控制流测试</h4><p>将程序按照一定的粒度（语句、语句块、函数、模块）转换为控制流图</p><p>使用 <em>Soot</em> 为 <em>Java</em> 程序自动生成控制流图</p><h4 id="数据流测试"><a href="#数据流测试" class="headerlink" title="数据流测试"></a>数据流测试</h4><p>关于数据流的几个定义：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151113624.png" alt="image-20220815111350511" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151114319.png" alt="image-20220815111440247" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151115743.png" alt="image-20220815111513638" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151116857.png" alt="image-20220815111601773" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151117998.png" alt="image-20220815111711863" style="zoom:40%;" /><p>数据流覆盖准则：</p><p>定义覆盖；引用覆盖；定义引用路径覆盖</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151118980.png" alt="image-20220815111825820" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151119254.png" alt="image-20220815111953197" style="zoom:40%;" /><h4 id="JUNIT-使用示例"><a href="#JUNIT-使用示例" class="headerlink" title="JUNIT 使用示例"></a>JUNIT 使用示例</h4><p>Maven 中的配置信息：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151121881.png" alt="image-20220815112155844" style="zoom:50%;" /><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><h4 id="随机测试"><a href="#随机测试" class="headerlink" title="随机测试"></a>随机测试</h4><p>随机测试（模糊测试）</p><p>自适应随机测试</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151127955.png" alt="image-20220815112710890" style="zoom:40%;" /><p>反随机测试（应对离散的输入域）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151129731.png" alt="image-20220815112944651" style="zoom:40%;" /><h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><p>将输入域划分为一系列子集（等价类），在每个子集中选取有代表性的测试用例进行测试</p><p>划分准则：不同类型数据的处理；不同的数据流或控制流；合法或非法输入</p><p>等价类划分需要满足完备性和无冗余性</p><h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><p>（字面意思）</p><h4 id="组合测试"><a href="#组合测试" class="headerlink" title="组合测试"></a>组合测试</h4><p>完全组合测试：组合数等于各输入等价类个数的乘积，测试代价高</p><p>两两组合测试：覆盖任意两个测试变量之间所有的取值组合（可以推广到 <em>T-wise combinatorial test</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151148998.png" alt="image-20220815114858813" style="zoom:40%;" /><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><h4 id="功能测试简介"><a href="#功能测试简介" class="headerlink" title="功能测试简介"></a>功能测试简介</h4><p>功能测试常用步骤：</p><ul><li>根据需求细分功能点</li><li>根据功能点派生测试需求</li><li>根据测试需求设计功能测试用例</li><li>逐项执行功能测试用例验证产品</li></ul><h4 id="探索式测试"><a href="#探索式测试" class="headerlink" title="探索式测试"></a>探索式测试</h4><p>探索式测试是一种软件测试风格</p><p>强调独立测试人员的个人职责和自由</p><p>将测试学习、设计、执行、结果分析作为相互支持的活动</p><p>在整个项目中并行地执行</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208161241281.png" alt="image-20220816124129162" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208161242881.png" alt="image-20220816124227760" style="zoom:40%;" /><p>强调：关注价值、风险驱动</p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>度量方法：</p><ul><li>服务端性能采用 CPU、内存等使用率来度量</li><li>客户端性能通常根据系统处理特定用户请求的响应时间来度量</li></ul><p>响应时间 = 服务端响应时间 + 客户端响应时间</p><p>并发用户数（取决于测试对象的目标业务场景）</p><p>吞吐量：单位时间内处理的用户请求数量</p><p>负载测试：验证系统在正常的负载条件下的行为</p><p>压力测试：评估系统处于或超过预期负载时的行为</p><h3 id="移动应用测试"><a href="#移动应用测试" class="headerlink" title="移动应用测试"></a>移动应用测试</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Android 测试工具：</p><ul><li><em>Monkey</em></li><li><em>Android Instrumentation</em></li><li><em>Android BDD-Calabash</em></li></ul><p>众包测试：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208161249785.png" alt="image-20220816124907539" style="zoom:40%;" /><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h3 id="一些测试思想："><a href="#一些测试思想：" class="headerlink" title="一些测试思想："></a>一些测试思想：</h3><p><strong>模糊测试</strong>：通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072113715.png" alt="image-20220907211354434" style="zoom: 50%;" /><p><strong>变异测试</strong>：在细节方面改进程序源代码的软件测试方法。这些所谓的变异，是基于良好定义的变异操作，这些操作或者是模拟典型应用错误（例如：使用错误的操作符或者变量名字），或者是强制产生有效地测试（例如使得每个表达式都等于0）。目的是帮助测试者发现有效地测试，或者定位测试数据的弱点，或者是在执行中很少（或从不）使用的代码的弱点。</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072115661.png" alt="image-20220907211512430" style="zoom: 50%;" /><p><strong>蜕变测试</strong>：用来缓解“测试准则问题”的软件测试技术。 测试准则是一种让测试人员判定程序是否能通过测试的机制。当测试人员对于所选择的测试用例难以确定预期的正确结果，或无法判定程序输出是否满足预期的结果时，便认为存在“测试准则问题”。</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072116482.png" alt="image-20220907211603369" style="zoom:50%;" /><p><strong>差分测试</strong>：通过将同一测试用例运行到一系列相似功能的应用中观察执行差异来检测 bug</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072116833.png" alt="image-20220907211634669" style="zoom:50%;" /><h3 id="一些已有的研究成果："><a href="#一些已有的研究成果：" class="headerlink" title="一些已有的研究成果："></a>一些已有的研究成果：</h3><ul><li>自动化测试脚本修复</li><li>测试用例推荐</li><li>基于互联网群体 智能的软件测试</li><li>智能软件测试</li><li>众包协作：一棵Bug报告树的生长</li><li>面向群体智能的测试报告自动化分析</li><li>面向群体智能的Bug截屏文本自动生成</li><li>基于截图理解的测试回放技术</li><li>基于深度图像理 解的报告排序</li><li>基于多源信息语义关联的众测报告半监督聚类</li><li>基于强化学习和图像理解的跨平台测试技术</li><li>面向群体智能的测试自动回放</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209092049620.png" alt="image-20220909204917288" style="zoom:50%;" /><h3 id="变异测试"><a href="#变异测试" class="headerlink" title="变异测试"></a>变异测试</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>变异测试的产生：</p><ul><li><p><strong>模拟</strong>缺陷，<strong>量化</strong>缺陷检测能力，指示测试有效性</p><ul><li><p>模拟：变异产生错误版本，模拟探测 bug 的过程</p></li><li><p>量化：变异得分（变异杀死率）</p></li></ul></li></ul><p>变异体：基于语法变换规则，通过对源程序进行程序变换得到的一系列变体（假设源程序不包含缺陷；假设变异体表达了某种缺陷）</p><p>变异得分：变异测试对测试套件检错能力的量化（变异体杀死率）</p><p>变异体的分类：有效；夭折（编译不通过）；冗余（等价、重复、蕴含）</p><p>变异算子：</p><ul><li><p>一系列语法变换规则</p></li><li><p>变异的依据，反应了测试人员关注的缺陷种类</p></li><li><p>基本形式</p><ul><li>对程序源码进行变换</li><li>对程序编译结果（中间表示）进行变换</li><li>元变异</li></ul></li></ul><p>基础假设：</p><ul><li>缺陷是简单的、可模拟的</li><li>缺陷是可叠加的</li><li>缺陷检测是有效的</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231453551.png" alt="image-20220923145344456" style="zoom:50%;" /><p>变异体筛选：对变异体进行筛选；对变异算子进行筛选（研究方向：变异算子的定义与约减策略）</p><p>变异体生成：将选中的变异算子实例化（研究方向：元变异，基于字节码操作，热替换）</p><p>变异体优化：</p><ul><li>识别等价变异体：代码优化 / 数据流分析</li><li>识别冗余变异体：操作符角度 / 缺陷层级角度 / 程序分析角度</li></ul><p>变异体执行：变异测试过程中最昂贵的阶段</p><ul><li><p>研究内容：针对<strong>计算变异得分</strong>（场景A）/ <strong>计算变异矩阵</strong>（场景B）优化执行过程</p></li><li><p>优化策略</p><ul><li>改变测试用例顺序（A）</li><li>匹配测试用例与变异体（A）</li><li>避免执行必定存活的变异体（A, B）</li><li>限定变异体的执行时间（A, B）</li></ul></li></ul><p>变异得分计算：（研究内容：变异杀死的条件，测试预言的生成）</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>评估作用：变异得分评估测试充分性</p><p>引导作用：利用变异测试 / 分析结果引导测试过程</p><p>传统应用：应用于确定性系统</p><ul><li>测试生成</li><li>语言生成</li><li>测试优化</li><li>debug 引导</li></ul><p>变异 &amp; AI：应用于非确定性系统</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231455917.png" alt="image-20220923145535799" style="zoom:50%;" /><h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><h4 id="起源与发展"><a href="#起源与发展" class="headerlink" title="起源与发展"></a>起源与发展</h4><p>模糊测试的诞生：</p><p>由字符乱码能够导致程序崩溃的现象启发，为提高 UINX 系统的可靠性，以随机字符串作为输入，运行操作系统组件，观察是否发生崩溃</p><p>近期发展：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231502603.png" alt="image-20220923150234520" style="zoom:50%;" /><h4 id="概念与架构"><a href="#概念与架构" class="headerlink" title="概念与架构"></a>概念与架构</h4><p>初始构想：工具（模糊器 Fuzzer） + 目标（待测程序 PUT） + 循环（执行程序 ⇆ 崩溃分派）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231508681.png" alt="image-20220923150810475" style="zoom:40%;" /><p>相关术语：</p><ul><li>模糊：从模糊输入空间得到输入来执行 DUT 的过程</li><li>模糊测试：应用模糊过程来验证 DUT 是否违反正确性策略的测试技术</li><li>模糊器：用于实现模糊测试的程序（核心，需要完成输入生成、测试执行和输出分析）</li><li>模糊运动：Fuzzer 按照特定的 Correctness Policy 在给定 DUT 上的一次具体的执行</li><li>缺陷预言：用于确定一次给定执行是否违反具体 Correctness Policy 的程序</li><li>模糊配置：控制和描述模糊（测试）算法的数据和约束</li><li>种子输入：在模糊测试过程中为输入生成提供基准的测试输入</li></ul><p>模糊测试框架：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231520555.png" alt="image-20220923152000213" style="zoom:40%;" /><h4 id="家族与分类"><a href="#家族与分类" class="headerlink" title="家族与分类"></a>家族与分类</h4><p>模糊测试家族：</p><ul><li>AFL家族（C/C++）：AFL、AFLFast、AFLSmart、AFLNet、 AFLGo、AFLIoT、FairFuzz、Mopt.、Neuzz</li><li>LibFuzzer家族（C/C++）：LibFuzzer、Entropic</li><li>JQF家族（Java）：JQF、BeDivFuzz、CONFETTI</li><li>其他（Rust、Python等）：Angora、DeepXplore</li></ul><p>模糊测试分类：</p><ul><li><p>按照采用的运行时信息：</p><ul><li>黑盒：仅从输入输出着手优化，利用输入格式或输出状态引导测试，效率高但有效性欠缺</li><li>白盒：使用混合分析、污点分析等昂贵白盒分析技术进行优化，利用详细程序分析结果引导测试，有效行高但效率低适配性差</li><li>灰盒：使用轻量级插桩监控程序，执行时收集各类信息并以此引导测试，黑盒白盒 trade-off</li></ul></li><li><p>按照输入生成的策略：</p><ul><li>基于变异：本质上是将种子输入转换为比特串进行变换，易于泛化但容易破环输入结构</li><li>基于生成：本质上是利用给定/挖掘/学习得到的文法规则来构建结构化输入，适用于对输入结构性要求较高的场景，但需要人工赋予一定的领域知识</li></ul></li><li><p>按照引导过程：</p><ul><li>Search-based：将测试转化为搜索问题，以代码覆盖率作为指示器、以启发式算法为核心，将测试导向更高覆盖的方向</li><li>Gradient-based：将测试转化为优化问题，以最大化缺陷发掘输入为目标构建目标函数，梯度下降算法迭代求最优解（若缺陷离散且无法预知，则将目标退阶为代码覆盖）</li></ul></li><li><p>按照测试的目的：</p><ul><li>定向：针对程序中的某个目标位置进行快而有效的测试</li><li>非定向：验证程序的正确性，检测程序中潜在的缺陷</li></ul></li><li><p>按照应用领域：网络协议、Compiler、DNN、IoT、内核</p></li><li><p>按照优化角度：种子调度、变异策略、能量调度、过程建模</p></li></ul><h4 id="iSE模糊测试"><a href="#iSE模糊测试" class="headerlink" title="iSE模糊测试"></a>iSE模糊测试</h4><h3 id="移动应用测试-1"><a href="#移动应用测试-1" class="headerlink" title="移动应用测试"></a>移动应用测试</h3><h4 id="众包测试"><a href="#众包测试" class="headerlink" title="众包测试"></a>众包测试</h4><h4 id="自动化测试-1"><a href="#自动化测试-1" class="headerlink" title="自动化测试"></a>自动化测试</h4><p>人为驱动的测试行为转化为机器执行</p><p>提升效率、降低成本、快速回归测试、保证测试一致性</p><p>开发时间周期长、对测试人员要求高、脚本维护开销大</p><p>adb 捕获移动应用内部状态</p><p>Appium</p><h3 id="代码摘要"><a href="#代码摘要" class="headerlink" title="代码摘要"></a>代码摘要</h3><p>代码摘要：翻译任务；特殊的文本摘要</p><p>研究目的：为缺少注释的旧代码补上注释；为新代码自动化生成注释</p><p>潜在应用场景：代码理解；代码审核；代码定位</p><p>早期工作：本文检索，从代码中提取关键词进行组合</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210141029336.png" alt="image-20221014102949158" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210141032878.png" alt="image-20221014103234674" style="zoom:50%;" /><p>中期工作：分析已有工作的有效性（提取的关键词和程序员实际认为的关键词是否相符等问题）并提出优化方案</p><p>近期工作：数据驱动，深度学习模型</p><p>测试：</p><ul><li>黑盒，白盒，灰盒</li><li>单元，集成，系统</li><li>功能，性能，安全，</li></ul><ul><li>正向：等价类划分（组合，正交实验设计）</li><li>负向：故障假设（边界值，…）</li></ul><p>Bug：</p><ul><li>显性</li><li>隐性</li></ul><p>智能系统</p><p>图</p><p>软件分析 -&gt; 代码的图结构</p><p>随机：自适应随机</p><ul><li>AI for SE</li><li>SE for AI</li></ul>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 UniRLTest</title>
      <link href="/2022/08/03/About-UniRLTest/"/>
      <url>/2022/08/03/About-UniRLTest/</url>
      
        <content type="html"><![CDATA[<p>有幸能参与到实验室学长的一个项目当中，简单记录一下整个项目和一些收获</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><em>UniRLTest</em> 即 <em>Universal Reinforcement Learning Test</em>，是基于图像识别、深度强化学习等实现的跨平台软件测试工具</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端部分主要负责与后端和设备进行通讯，接收后端传来的操作指令并在设备上执行，获取设备上应用的屏幕截图并传给后端进行分析</p><p>文件大致结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">../urt/urt-frontend</span><br><span class="line">│  client.py</span><br><span class="line">│  launcher.py</span><br><span class="line">│  logger.py</span><br><span class="line">│  plt.py</span><br><span class="line">│  urt_android.py</span><br><span class="line">│          </span><br><span class="line">├─android</span><br><span class="line">│  │  action_executor.py</span><br><span class="line">│  │  plt_android.py</span><br><span class="line">│  │  screen_capture.py</span><br><span class="line">│  │  tool_base.py</span><br><span class="line">│  │  utils.py</span><br><span class="line">│      </span><br><span class="line">├─pc</span><br><span class="line">│  │  action_executor.py</span><br><span class="line">│  │  plt_pc.py</span><br><span class="line">│  │  screen_capture.py</span><br><span class="line">│  │  tool_base.py</span><br><span class="line">│          </span><br><span class="line">├─web</span><br><span class="line">│  │  action_executor.py</span><br><span class="line">│  │  plt_web.py</span><br><span class="line">│  │  screen_capture.py</span><br><span class="line">│  │  tool_base.py</span><br><span class="line">│</span><br><span class="line">├─configs</span><br><span class="line">│  │  configure.py</span><br><span class="line">│  │  ssh_config.json</span><br><span class="line">│  │</span><br><span class="line">│  ├─android    </span><br><span class="line">│  │</span><br><span class="line">│  ├─web</span><br><span class="line">│          </span><br><span class="line">├─coverages</span><br><span class="line">│              </span><br><span class="line">├─logs   </span><br></pre></td></tr></table></figure><p>前端的运行需要一个配置文件作为额外参数（e.g. configs/android/anymemo.json），配置文件结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// e.g.&quot;android&quot;/&quot;web&quot;/&quot;pc&quot;</span></span><br><span class="line"><span class="attr">&quot;serial_no&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 测试使用的设备</span></span><br><span class="line"><span class="attr">&quot;screen_size&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">// 设备的屏幕尺寸（屏幕截图的分辨率）</span></span><br><span class="line"><span class="attr">&quot;server_proj_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 服务器上部署的后端项目的路径，e.g.&quot;/root/urt&quot;</span></span><br><span class="line"><span class="attr">&quot;server_screenshot_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 后端保存屏幕截图的文件夹路径，e.g.&quot;screenshots&quot;</span></span><br><span class="line"><span class="attr">&quot;local_screenshot_path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 本地保存屏幕截图的文件路径，e.g.&quot;anymemo.png&quot;</span></span><br><span class="line"><span class="attr">&quot;window_keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;total_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 测试的总时长，单位为秒</span></span><br><span class="line"><span class="attr">&quot;banner_height&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remote_port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 在服务器上使用的端口号，e.g.&quot;5000&quot;</span></span><br><span class="line"><span class="attr">&quot;app&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="comment">// 被测试应用的基本信息</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">//e.g.&quot;budgetwatch&quot;</span></span><br><span class="line"><span class="attr">&quot;pkg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">//e.g.&quot;protect.budgetwatch&quot;</span></span><br><span class="line"><span class="attr">&quot;main_activity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="comment">//e.g.&quot;protect.budgetwatch.test.InstrumentedActivity&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>此部分内容根据论文初稿整理</p></blockquote><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208051749222.png" alt="image-20220805174903049" style="zoom:50%;" /><h4 id="后端的功能主要分为两大模块："><a href="#后端的功能主要分为两大模块：" class="headerlink" title="后端的功能主要分为两大模块："></a>后端的功能主要分为两大模块：</h4><h5 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h5><ul><li><p>提取组件和页面布局特征</p><ul><li>使用 <em>Canny Edge Detection</em> 技术从屏幕截图中提取组件</li><li>根据提取到的组件构建一棵组件树来表示页面布局特征</li></ul></li><li><p>组件 Embedding</p><ul><li>组件图像经过卷积神经网络处理得到一个 4096 维向量，表示组件的图像信息</li><li>将屏幕截图的组件位置变为全白而其余地方变为全黑而得到的图片，经过卷积神经网络处理得到一个 4096 维向量，表示组件的位置信息（不使用坐标是为了相对图像信息有足够的权重）</li><li>组件图像经过卷积神经网络处理得到一个 14 维独热向量，表示组件的类型</li><li>将上述结果拼接而成一个 8206 维的向量，即为 embedding 的结果</li><li>以上所说的卷积神经网络，是一个预训练好的用于判断组件类型的 VGG-16 模型，4096 维的向量是其倒数第二层的输出，14 维的向量是其最后一层的输出</li></ul></li><li><p>页面布局 Embedding</p><ul><li>将树状结构的页面布局转化为字符串</li><li>将该字符串使用预训练好的 LSTM 模型处理，输出 512 维的向量，即为 embedding 的结果</li></ul></li><li><p>页面（app 状态）表示</p><ul><li>计算所有组件的 embedding 向量的平均值，即用一个 8206 维的向量表示所有组件</li><li>将组件和页面布局的 embedding 结果连接成 8718 维的向量，表示整个页面（app 状态）</li></ul></li></ul><h5 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h5><blockquote><p>这部分在此没有详细展开说明</p></blockquote><ul><li>动作生成<ul><li>用 17 维的独热向量表示动作类型</li><li>用 8026 维的向量表示实施动作的组件（没有则做 zero-padding）</li><li>用一维向量表示 window size 参数（没有则做 zero-padding）</li><li>表示一个动作的向量由上述向量连接而成</li></ul></li><li><em>Q-Network</em> 模型训练<ul><li>Q-Network 使用含有四个隐藏层的全连接神经网络</li><li>replay-memory 中保存了每次状态转换以及其对应的奖励值，也是训练模型的数据来源</li><li>随着测试的进行，模型需要被不断训练和更新</li></ul></li><li>动作决定<ul><li>通过 <em>Q-Network</em> 的输出可以得到当前页面下，所有可能动作被执行的优先级</li><li>使用 Boltzmann Strategy 决定下一个被执行的动作（避免被困在局部最优解）</li></ul></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p>Web 应用的测试和 PC 端应用的测试本人没有参与，所以以下内容只涉及安卓应用测试</p></blockquote><h4 id="安卓应用插桩测试方法"><a href="#安卓应用插桩测试方法" class="headerlink" title="安卓应用插桩测试方法"></a>安卓应用插桩测试方法</h4><h5 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h5><ul><li>Java：jdk8（较老的 gradle 无法用 jdk11 运行）和 jdk11（较新的 gradle 需要至少 jdk11 运行）</li><li>Gradle：不用额外安装，项目中自带的 gradlew 脚本能在当前自动安装对应版本的 gradle</li><li>Android SDK：使用 Android Studio 统一管理，环境变量中正确设置ANDROID_HOME的值</li></ul><h5 id="构建原项目："><a href="#构建原项目：" class="headerlink" title="构建原项目："></a>构建原项目：</h5><ul><li><p>在项目目录下执行如下命令进行构建：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --no-daemon --stacktrace assembleDebug</span><br></pre></td></tr></table></figure></li><li><p><em>–no-daemon</em> 表示 Gradle 守护进程会在命令执行完成后自动退出，不会常驻后台（因为不同应用依赖不同版本的gradle，守护进程没法很好的被复用，无需常驻后台）</p></li><li><p><em>–stacktrace</em> 表示若报错会打印堆栈信息</p></li><li><p><em>assembleDebug</em> 表示构建 debug 包</p></li><li><p>这一步的目的是保证应用本身可正常构建（其构建产物不会被后续使用）</p></li></ul><h5 id="添加插桩代码："><a href="#添加插桩代码：" class="headerlink" title="添加插桩代码："></a>添加插桩代码：</h5><ul><li><h6 id="使用-python-脚本一键插桩："><a href="#使用-python-脚本一键插桩：" class="headerlink" title="使用 python 脚本一键插桩："></a>使用 python 脚本一键插桩：</h6>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python instrument.py &#123;x&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：脚本完成了如下操作</p></li></ul><ol><li><p>备份 <em>app</em> 目录下的 <em>build.gradle</em>，并添加一个 <em>apply</em> 语句以应用 <em>jacoco</em> 插件</p></li><li><p>在 <em>app</em> 目录下添加 <em>jacoco-multi.gradle</em> 或 <em>jacoco-multi-kt.gradle</em>，包含了 <em>jacoco</em> 配置，其中后者是应对 <em>kotlin</em> 项目的配置（该配置文件是一个骨架，后面需要进行修改）</p></li><li><p>备份并修改 <em>AndroidManifest.xml</em> 配置文件，注册 <em>InstrumentedActiviy</em> 和 <em>JacocoInstrumentation</em> </p></li><li><p>向源码中加入三个文件：<em>FinishListener</em>、<em>InstrumentedActiviy</em> 和J <em>acocoInstrumentation</em></p></li></ol><p>（上述 <em>app</em> 目录为源码所在目录，一般为 <em>app</em>，也有可能为其它名称，该脚本若未检测到 <em>app</em> 目录，则会提示输入该目录的名称，需要用户自行判别目录并输入，有时源码所在目录就是项目目录，则输入一个点<code>.</code>表示项目目录即可；<em>AndroidManifest.xml</em> 文件默认路径为 <em>app/src/main</em> 下，若检测不到，会要求用户输入其完整路径；源码 <em>java</em> 目录默认为 <em>app/src/main/java</em>，若检测不到，会要求用户输入其完整路径）</p><ul><li><h6 id="修改-build-和-jacoco-配置："><a href="#修改-build-和-jacoco-配置：" class="headerlink" title="修改 build 和 jacoco 配置："></a>修改 build 和 jacoco 配置：</h6></li></ul><ol><li>检查源码语言是纯 <em>java</em> 还是使用了 <em>kotlin</em>，若使用了 <em>kotlin</em>，检查是否在 <em>app/build.gradle</em> 中 <em>apply</em> 了带 <em>“-kt”</em> 的 <em>jacoco</em> 配置，若没有，则需进行替换</li><li>查看 <em>build/intermediates</em> 下的 <em>javac</em> 或 <em>classes</em> 目录，若没有 <em>javac</em> 目录而有 <em>classes</em> 目录，则将 <em>jacoco</em>配置中的 <em>javac</em> 全部替换成 <em>classes</em></li><li>（假定上一步是 <em>javac</em> 目录）在 <em>javac</em> 目录下查看 <em>app</em> 构建类型，一般是 <em>xxxDebug</em>，选一个作为测试类型，以后只用该类型的 <em>apk</em>（在 <em>build/outputs/apk</em> 目录下有对应的 <em>apk</em> 文件），修改 <em>jacoco</em> 配置中的 <em>variantName</em> 变量为测试类型的名称</li></ol><h5 id="构建插桩后的应用："><a href="#构建插桩后的应用：" class="headerlink" title="构建插桩后的应用："></a>构建插桩后的应用：</h5><ul><li><p>使用相同的命令构建：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --no-daemon --stacktrace assembleDebug</span><br></pre></td></tr></table></figure></li></ul><p>这一步若出现报错，可能有以下几种情况：</p><ul><li><p><em>java</em> 版本不对（仔细查看报错信息，调整 <em>jdk</em> 版本）</p></li><li><p><em>jacoco</em> 配置出错，无法设置 <em>outputLocation</em> 属性。这种情况是由于 <em>gradle</em> 版本较低导致的，将<em>jacoco</em> 配置中的 <em>outputLocation</em> 全部替换成 <em>destination</em>，然后将以下三行改掉：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// classDirectories.from = files(...)</span></span><br><span class="line"><span class="comment">// sourceDirectories.from = files(...)</span></span><br><span class="line"><span class="comment">// executionData.from = ecFile</span></span><br><span class="line">classDirectories = files(...)</span><br><span class="line">sourceDirectories = files(...)</span><br><span class="line">executionData = files(ecFile)  <span class="comment">// 注意这里要套一个files</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="安装并运行插桩后的应用："><a href="#安装并运行插桩后的应用：" class="headerlink" title="安装并运行插桩后的应用："></a>安装并运行插桩后的应用：</h5><ul><li><p>检查本机是否已经连上用于测试的安卓设备（真机或虚拟机）：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure></li><li><p>项目目录下，在用于测试的设备上安装插桩后的应用：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb [-s &#123;设备名称&#125;] install ./app/build/outputs/xxxDebug.apk</span><br></pre></td></tr></table></figure></li><li><p>通过源码查看应用的{包名}，并在测试设备上运行安装的应用：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb [-s &#123;设备名称&#125;] shell am instrument &#123;包名&#125;/.test.JacocoInstrumentation</span><br></pre></td></tr></table></figure></li></ul><p>此时手机会打开插桩后的应用，随便交互几步后，关闭该应用并在后台进程中<strong>杀死</strong>该应用（若不杀死则会不断生成新的覆盖率数据）</p><ul><li>若插桩后的应用存在打开时闪退的问题，可能是由应用的主题导致的：<ul><li>尝试修改 <em>app/src/main/AndroidManifest.xml</em> 中 <em>application</em> 的 <em>android:theme</em> 属性，将原来的例如 <em>AnyMemo.Theme.Dark</em> 修改为 <em>AnyMemo.Theme.Dark</em><em>.NoActionBar</em>**，再重新构建和安装</li><li>插桩后出现闪退问题的一般定位方法如下：<ol><li>打开一个命令行，使用<code>adb logcat *:D</code>命令跟踪日志</li><li>到另一个命令行中启动 <em>instrumentation</em></li><li>切换到第一步的命令行，<em>ctrl+c</em> 停止打印，自底向上查找相关的报错信息</li></ol></li></ul></li></ul><h5 id="导出覆盖率数据并生成报告："><a href="#导出覆盖率数据并生成报告：" class="headerlink" title="导出覆盖率数据并生成报告："></a>导出覆盖率数据并生成报告：</h5><ul><li><p>覆盖率数据文件被保存在 <em>/data/data/&lt;包名&gt;/files</em> 目录下，通过如下命令导出这些文件：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次导出需要创建中间目录</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">mkdir</span> /sdcard/coverage</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面run-as后为应用包名</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">run-as org.liberty.android.fantastischmemo</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">mv</span> files/*.ec /sdcard/coverage</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目标路径为空则默认为当前目录</span></span><br><span class="line">adb pull /sdcard/coverage [目标路径]</span><br></pre></td></tr></table></figure></li><li><p>下面将 <em>coverage</em> 目录下所有 <em>.ec</em> 文件移动到该应用的项目目录下的 <em>app/build/jacoco</em> 目录下（没有则创建），在项目目录下使用如下命令生成报告（报告生成在 <em>app/build/reports</em> 目录下）：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --no-daemon --stacktrace multiJacocoTestReport</span><br></pre></td></tr></table></figure></li></ul><h4 id="安卓测试实验流程"><a href="#安卓测试实验流程" class="headerlink" title="安卓测试实验流程"></a>安卓测试实验流程</h4><ul><li>在安卓设备上安装插桩后的应用</li><li>在前端项目目录下的 <em>configs/android</em>/ 目录下添加被测应用对应的配置信息（xxx.json）</li><li>在服务器上启动后端（执行命令：<em>sh run.sh</em>）</li><li>在本地启动前端（执行命令：<em>python urt_android xxx.json</em>）</li><li>测试设备开始运行被测应用，<em>UniRLTest</em> 测试进行中 …</li><li>测试结束，覆盖率数据生成在前端项目目录下的 <em>coverages</em>/xxx/ 目录下</li><li>手动生成测试报告（具体步骤已在安卓应用插桩测试中讲过）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> NJU-iSE </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《软件分析》课程笔记</title>
      <link href="/2022/07/14/NJU-Static-Analysis/"/>
      <url>/2022/07/14/NJU-Static-Analysis/</url>
      
        <content type="html"><![CDATA[<p>课程内容来源：<a href="https://tai-e.pascal-lab.net/">https://tai-e.pascal-lab.net/</a></p><p>实验作业的实现：<a href="https://github.com/Ling-Yuchen/Tai-e-assignments/">https://github.com/Ling-Yuchen/Tai-e-assignments/</a></p><p>部分实验作业思路参考：<a href="https://vgalaxy.gitee.io/2022/05/05/static-analysis/">https://vgalaxy.gitee.io/2022/05/05/static-analysis/</a></p><h2 id="01-Introduction"><a href="#01-Introduction" class="headerlink" title="01 - Introduction"></a>01 - Introduction</h2><h3 id="1-静态分析：运行前对程序进行分析"><a href="#1-静态分析：运行前对程序进行分析" class="headerlink" title="1. 静态分析：运行前对程序进行分析"></a>1. 静态分析：运行前对程序进行分析</h3><p>​        是否存在私有信息泄露？</p><p>​        是否存在空指针异常？</p><p>​        是否存在强制类型转换异常？</p><p>​        是否允许存在指向同一内存块的指针？</p><p>​        是否存在 fail 的 <em>assert</em> 语句？</p><p>​        是否存在可以删除的死代码？</p><p>​        ……</p><h3 id="2-莱斯定理（Rice’s-Theorem）"><a href="#2-莱斯定理（Rice’s-Theorem）" class="headerlink" title="2. 莱斯定理（Rice’s Theorem）"></a>2. 莱斯定理（<em>Rice’s Theorem</em>）</h3><p><em>Any non-trivial property of the behavior of programs in a r.e. language is undecidable.</em></p><p>通俗来讲就是，以平时常用的编程语言写的程序，对于其有用的动态运行时性质，无法做出准确判断</p><p>——不存在完美的（<em>sound &amp; complete</em>）静态分析</p><p>对 soundness 妥协：产生漏报（<em>false negatives</em>）（可以接受）</p><p>对 completeness 妥协：产生误报（<em>false positive</em>s）（不希望发生）</p><p>静态分析：在确保 <em>soundness</em> 的前提下，在分析的准确度和速度之间做出有效的平衡</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207132057151.png" alt="img" style="zoom:50%;" /><h3 id="3-静态分析技术：抽象-近似"><a href="#3-静态分析技术：抽象-近似" class="headerlink" title="3. 静态分析技术：抽象+近似"></a>3. 静态分析技术：抽象+近似</h3><p>抽象（<em>abstraction</em>）：把具体域的值映射到抽象域的值</p><p>近似（Over-approximation）：在抽象层面定义转移函数；由于无法枚举所有路径，所以使用  <em>flow merging</em> 处理  <em>control flow</em></p><h3 id="本节重点"><a href="#本节重点" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>静态分析与（动态）测试的区别？</li><li>理解 soundness, completeness, false negatives 和 false positives 的概念</li><li>为什么静态分析需要保证 soundness？</li><li>怎样理解 abstraction 和 over-approximation？</li></ul><h2 id="02-Intermediate-Representation"><a href="#02-Intermediate-Representation" class="headerlink" title="02 - Intermediate Representation"></a>02 - Intermediate Representation</h2><h3 id="1-编译器（Compiler）与静态分析（Static-Analysis）"><a href="#1-编译器（Compiler）与静态分析（Static-Analysis）" class="headerlink" title="1. 编译器（Compiler）与静态分析（Static Analysis）"></a>1. 编译器（<em>Compiler</em>）与静态分析（<em>Static Analysis</em>）</h3><p>编译器：源码 =&gt;（词法分析器 Scanner）=&gt; Tokens =&gt;（语法分析器 Parser）=&gt; AST =&gt;（类型检查 Type Checker）=&gt; Decorated AST =&gt;（Translator）=&gt; IR =&gt;（Code Generator）=&gt; 机器码</p><p>静态分析需要在编译器前端生成的 IR 的基础上进行，e.g. 代码优化</p><h3 id="2-抽象语法树（AST）-vs-中间表示（IR）"><a href="#2-抽象语法树（AST）-vs-中间表示（IR）" class="headerlink" title="2. 抽象语法树（AST） vs. 中间表示（IR）"></a>2. 抽象语法树（<em>AST</em>） vs. 中间表示（<em>IR</em>）</h3><p>抽象语法树：贴近语法结构；依赖于不同语言；适合做快速的类型检查；缺少控制流信息</p><p>中间表示：贴近机器码；具有语言无关性；简洁而统一；包含控制流信息；通常作为静态分析的基础</p><h3 id="3-中间表示（三地址码）"><a href="#3-中间表示（三地址码）" class="headerlink" title="3. 中间表示（三地址码）"></a>3. 中间表示（三地址码）</h3><p>右侧最多只有一个操作符；每种指令都有对应的三地址码</p><ul><li>x = y <em>bop</em> z</li><li>x = <em>uop</em> y</li><li>x = y</li><li>goto L</li><li>if x goto L</li><li>if x <em>rop</em> y goto L</li></ul><h3 id="4-真实的静态分析器中的三地址码：Soot’s-IP"><a href="#4-真实的静态分析器中的三地址码：Soot’s-IP" class="headerlink" title="4. 真实的静态分析器中的三地址码：Soot’s IP"></a>4. 真实的静态分析器中的三地址码：Soot’s IP</h3><p>关于 JVM 的补充：</p><p>invoke-special:    call constructor，call superclass methods，call private methods</p><p>invoke-virtual:    call instance methods（virtual dispatch）</p><p>invoke-interface:    cannot optimize，checking interface implementation</p><p>invoke-static:    call static methods</p><p>method signature:    class name，return type，method name，parameter type</p><h3 id="5-控制流分析"><a href="#5-控制流分析" class="headerlink" title="5. 控制流分析"></a>5. 控制流分析</h3><p>输入三地址码，输出控制流图</p><p>Basic Block 定义：有且仅有一个入口和一个出口的指令块</p><p>确定 Basic Block 的算法：</p><ul><li>第一条指令是基本块的入口</li><li>所有跳转的目标指令是基本块的入口</li><li>所有跳转指令的下一条指令是基本块的入口</li><li>从一个入口指令到下一条入口指令的前一条指令构成一个基本块</li></ul><p>控制流图：</p><p>节点为基本块（<em>basic blocks</em>）</p><p>一条从基本块A到基本块B的边表示，存在从A尾部到B首部的有条件或无条件跳转，或者顺序上B紧跟着A且A的最后一条指令不是无条件跳转</p><p>加上 Entry 和 Exit 表示程序的入口和出口（类似哨兵节点）</p><h3 id="本节重点-1"><a href="#本节重点-1" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>编译器和静态分析器之间的关系？</li><li>理解三地址码及其通常的形式（in IR Jimple）</li><li>怎样在 IR 的基础上构建 basic blocks？</li><li>怎样在 basic blocks 的基础上构建控制流图？</li></ul><h2 id="03-Data-Flow-Analysis（Application）"><a href="#03-Data-Flow-Analysis（Application）" class="headerlink" title="03 - Data Flow Analysis（Application）"></a>03 - Data Flow Analysis（Application）</h2><h3 id="1-数据流分析概览"><a href="#1-数据流分析概览" class="headerlink" title="1. 数据流分析概览"></a>1. 数据流分析概览</h3><p>How <em>application-specific Data</em>（abstraction） <em>Flows</em>（safe-approximation） through the <em>Nodes</em> （Transfer function）and <em>Edges</em>（Control-flow handling） of CFG？</p><p>may analysis：输出信息可能是正确的（over-approximation）</p><p>must analysis：输出信息必须是正确的（under-approximation）</p><h3 id="2-数据流分析前驱知识"><a href="#2-数据流分析前驱知识" class="headerlink" title="2. 数据流分析前驱知识"></a>2. 数据流分析前驱知识</h3><p>Input and Output States</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141511690.png" alt="img" style="zoom:50%;" /><p>在数据流分析应用中，将每一个 <em>program point</em> 与一个 表示该点所有观测到的 <em>program states</em> 的集合的抽象的<em>数据流值（data-flow value）</em> 联系起来</p><p>数据流分析是对所有的语句，通过解析 safe-approximation 的约束规则，得到一个 solution（给每个 <em>program point</em> 一个 <em>data-flow value</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141528212.png" alt="img" style="zoom: 50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141533764.png" alt="img" style="zoom: 50%;" /><h3 id="3-定义可达性分析（Reaching-Definition-Analysis）"><a href="#3-定义可达性分析（Reaching-Definition-Analysis）" class="headerlink" title="3. 定义可达性分析（Reaching Definition Analysis）"></a>3. 定义可达性分析（<em>Reaching Definition Analysis</em>）</h3><p>定义可达性：A definition <em>d</em> at program point <em>p</em> reaches a point <em>q</em> if there is a path from <em>p</em> to <em>q</em> such that <em>d</em> is not killed along the path.</p><p>定义可达性可以用于 <em>侦测可能的未定义的变量</em></p><p><strong>理解定义可达性分析：</strong></p><p>用一个比特表示某个变量在某一点的定义可达性</p><p>用一个 n 维比特向量表示 n 个变量在某一点的定义可达性</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141559532.png" alt="1" style="zoom:50%;" /><p><strong>定义可达性分析算法：</strong></p><p>注意：</p><p>在算法模板中边界条件（OUT[entry]）单独初始化</p><p>对于 OUT[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141602719.png" alt="img" style="zoom:50%;" /><p>为什么该迭代算法最终会停下来？</p><p>对于 Transfer Function，OUT[S] 只受 IN[S] 的影响，当个更多的 facts 流入 IN[S] 时，要么被 kill 要么存活下来并永远被保留，故 OUT[S] 永远不会缩减（e.g. 0 =&gt; 1 或 1 =&gt; 1），又因为定义的变量数量是有限的，故该迭代一定会停下来（实际上到达了一个不动点）</p><h3 id="4-活跃变量分析（Live-Variable-Analysis）"><a href="#4-活跃变量分析（Live-Variable-Analysis）" class="headerlink" title="4. 活跃变量分析（Live Variable Analysis）"></a>4. 活跃变量分析（<em>Live Variable Analysis</em>）</h3><p>Live variable analysis tells whether the value of <em>variable v</em> at <em>program point p</em> could be used along some path in CFG starting at <em>p</em>（AND <em>v</em> should not be redefined before usage）. If so, <em>v</em> is live at <em>p</em>. Otherwise, <em>v</em> is dead at <em>p</em>.</p><p>活跃变量信息可用于寄存器分配（倾向于使用存有 dead value 的寄存器来存新数据）</p><p><strong>理解活跃变量分析：</strong></p><p>用一个比特表示某个变量在某一点是否活跃</p><p>用一个 n 维比特向量表示 n 个变量在某一点是否活跃</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141823269.png" alt="1" style="zoom:50%;" /><p>注意 use 的定义为：在重定义之前被使用</p><p><strong>活跃变量分析算法：</strong></p><p>注意：</p><p>在算法模板中边界条件（IN[entry]）单独初始化</p><p>对于 IN[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141826606.png" alt="img" style="zoom:50%;" /><h3 id="5-可用表达式分析（Available-Expressions-Analysis）"><a href="#5-可用表达式分析（Available-Expressions-Analysis）" class="headerlink" title="5. 可用表达式分析（Available Expressions Analysis）"></a>5. 可用表达式分析（<em>Available Expressions Analysis</em>）</h3><p>一个表达式，形如 <em>x op y</em>，在某个 <em>program point p</em> 是可用的，需要满足：</p><ul><li>从 <em>ENTRY</em> 到 <em>p</em> 的所有路径都必须计算过 <em>x op y</em> 的值</li><li>在这些路径各自最后一次计算该表达式的值之后没有修改过 <em>x</em> 或 <em>y</em> 的值</li></ul><p><strong>理解可用表达式分析：</strong></p><p>用一个比特表示某个表达式在某点是否可用</p><p>用一个 n 维比特向量表示 n 个表达式在某点是否可用</p><p>注意这是一个 must analysis</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171149946.png" alt="1" style="zoom:50%;" /><p><strong>可用表达式分析算法：</strong></p><p>注意在 must analysis 中的初始化方式</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171151583.png" alt="img" style="zoom:50%;" /><h3 id="6-不同数据流分析应用的对比"><a href="#6-不同数据流分析应用的对比" class="headerlink" title="6. 不同数据流分析应用的对比"></a>6. 不同数据流分析应用的对比</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171210734.png" alt="1" style="zoom:50%;" /><h3 id="本节重点-2"><a href="#本节重点-2" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>理解三种数据流分析</li><li>能说出三种数据流分析的相似与不同</li><li>理解迭代算法为什么最终能停下来</li></ul><h2 id="04-Data-Flow-Analysis（Foundations）"><a href="#04-Data-Flow-Analysis（Foundations）" class="headerlink" title="04 - Data Flow Analysis（Foundations）"></a>04 - Data Flow Analysis（Foundations）</h2><h3 id="1-从另一个角度来看迭代算法"><a href="#1-从另一个角度来看迭代算法" class="headerlink" title="1. 从另一个角度来看迭代算法"></a>1. 从另一个角度来看迭代算法</h3><p>假设给定的 CFG 有 <em>k</em> 个节点，迭代算法每次迭代更新每个节点的 OUT[n]</p><p>定义 <em>k-tuple</em> (OUT[n1], … , OUT[nk])，则该元组为集合 V^k 的一个元素（V 是数据流分析的值的域）</p><p>那么每次迭代可以视作作用了转移函数和流控制处理的一次映射，即：F:  V^k —&gt; V^k</p><p>整个算法就是在不断地输出这样的 <em>k-tuple</em> 直到出现连续两个相同的为止</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171602188.png" alt="img" style="zoom:50%;" /><p>迭代算法会在 X = F(X) 处停下来，即数学定义上的一个不动点（<em>fixed point</em>）</p><p>思考：</p><ul><li>算法能保证到达不动点吗？</li><li>如果能，那么只有一个不动点吗？若超过一个不动点，那么我们能到达最优解的不动点吗？</li><li>算法要多久才能到达不动点？（时间复杂度）</li></ul><h3 id="2-偏序"><a href="#2-偏序" class="headerlink" title="2. 偏序"></a>2. 偏序</h3><p>偏序关系（<em>Partial Order</em>）满足自反性、反对称性、传递性</p><p>一个偏序集（<em>poset</em>）中的任意两个元素之间不一定满足偏序关系</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171807638.png" alt="img" style="zoom:50%;" /><h3 id="3-上界和下界"><a href="#3-上界和下界" class="headerlink" title="3. 上界和下界"></a>3. 上界和下界</h3><p>上界（<em>upper bound</em>）和下界（<em>lower bound</em>）</p><p>最小上界（<em>least upper bound</em>）和最大下界（<em>greatest lower bound</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171809088.png" alt="img" style="zoom:50%;" /><p>最小上界（<em>least upper bound</em>）和最大下界（<em>greatest lower bound</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171809056.png" alt="img" style="zoom:50%;" /><p>不是每个偏序集都有最小上界（最大下界）；若偏序集存在最小上界（最大下界），则是唯一的</p><h3 id="4-格、半格、全格、格的积"><a href="#4-格、半格、全格、格的积" class="headerlink" title="4. 格、半格、全格、格的积"></a>4. 格、半格、全格、格的积</h3><p>格（<em>Lattice</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181246948.png" alt="img" style="zoom:50%;" /><p>半格（<em>Semilattice</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181251145.png" alt="1" style="zoom:50%;" /><p>全格（<em>Complete Lattice</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181253998.png" alt="img" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181257563.png" alt="1" style="zoom:50%;" /><p>有穷格一定是全格，全格不一定是有穷格</p><p>格的积（<em>Product Lattice</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181811085.png" alt="img" style="zoom:50%;" /><h3 id="5-通过格来表达数据流分析框架"><a href="#5-通过格来表达数据流分析框架" class="headerlink" title="5. 通过格来表达数据流分析框架"></a>5. 通过格来表达数据流分析框架</h3><p>数据流分析框架（D, L, F）：</p><ul><li>D：数据流的方向（<em>forward</em> 或 <em>backward</em>）</li><li>L：一个包含分析域（<em>domain</em>）以及 <em>join</em> 和 <em>meet</em> 操作的格</li><li>F：一组定义在在域（<em>domain</em>）上的转移函数（<em>transfer function</em>）</li></ul><p>数据流分析可以视作：对格的值迭代地作用转移函数（<em>transfer function</em>）和 <em>join</em> 或 <em>meet</em> 操作</p><h3 id="6-单调性与不动点定理"><a href="#6-单调性与不动点定理" class="headerlink" title="6. 单调性与不动点定理"></a>6. 单调性与不动点定理</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181843635.png" alt="img" style="zoom:50%;" /><p><strong>证明：不动点存在且是最小（大）的</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181851338.png" alt="img" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181855231.png" alt="img" style="zoom:50%;" /><h3 id="7-将迭代算法和不动点定理关联在一起"><a href="#7-将迭代算法和不动点定理关联在一起" class="headerlink" title="7. 将迭代算法和不动点定理关联在一起"></a>7. 将迭代算法和不动点定理关联在一起</h3><p>将迭代算法和不动点定理做出以下关联</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207182103098.png" alt="2" style="zoom:50%;" /><p>故只要证明 <em>function F</em> 是单调的</p><p>之前已经说明 <em>transfer function</em> 是单调的，故只要证明 <em>join/meet function</em> 是单调的</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207182111913.png" alt="img" style="zoom:50%;" /><p>到这里为止，我们可以用格的数学概念和不动点定理严格证明：</p><p>数据流分析的迭代算法一定能停下来（到达不动点），并且一定是最大（最小）不动点</p><h3 id="8-格的视角下的-May-Must-Analysis"><a href="#8-格的视角下的-May-Must-Analysis" class="headerlink" title="8. 格的视角下的 May / Must Analysis"></a>8. 格的视角下的 May / Must Analysis</h3><p>无论是 May Analysis 还是 Must Analysis，都是从 unsafe 的情况向 safe but useless 的情况迭代</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207182148271.png" alt="3" style="zoom:50%;" /><h3 id="9-MOP"><a href="#9-MOP" class="headerlink" title="9. MOP"></a>9. MOP</h3><p>Meet-Over-All-Paths Solution（MOP）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242025411.png" alt="img" style="zoom:50%;" /><p>迭代算法与 MOP 的比较：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242036375.png" alt="img" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242037852.png" alt="1" style="zoom:50%;" /><p>迭代算法得到的结果没有 MOP 准确，但当 <em>Transfer Function</em> 满足分配律的时候，迭代算法可以做到和 MOP 一样准确（可以用集合的交并进行操作的 <em>Transfer Function</em> 都是满足分配律的）</p><h3 id="10-常量传播分析（Constant-Propagation-Analysis）"><a href="#10-常量传播分析（Constant-Propagation-Analysis）" class="headerlink" title="10. 常量传播分析（Constant Propagation Analysis）"></a>10. 常量传播分析（<em>Constant Propagation Analysis</em>）</h3><p>常量传播（<em>Constant Propagation</em>）：对于给定的变量 <em>x</em>，在某一个 <em>program point p</em>，确定该变量是否确保持有一个常量值（<em>must analysis</em> ）</p><p>与之前的数据流分析不同，常量传播 CFG 中每个节点的 IN 和 OUT 都是键值对 <em>(x, v)</em> 的集合（<em>x</em> 表示变量名， <em>v</em> 表示变量持有的值）</p><p>根据数据流分析框架 (D, L, F) 来对常量传播分析进行定义：</p><ul><li>常量传播分析的数据流是正向的（<em>forward</em>）</li><li>常量传播分析的格模型</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242130437.png" alt="img" style="zoom: 50%;" /><ul><li>常量传播分析的转移函数</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242113532.png" alt="1" style="zoom:50%;" /><p>常量传播分析的 <em>Transfer Function</em> 不满足分配律</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242139017.png" alt="img" style="zoom:50%;" /><h3 id="11-工作列表算法"><a href="#11-工作列表算法" class="headerlink" title="11. 工作列表算法"></a>11. 工作列表算法</h3><p>工作列表算法（<em>Worklist Algorithm</em>）是迭代算法的一种优化，在实际场景中更常用</p><p>迭代算法的主体操作流程清晰直观但有很多冗余步骤，工作列表算法可以做到每次仅对有变化的部分施加转移函数</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242145947.png" alt="img" style="zoom:50%;" /><h3 id="本节重点-3"><a href="#本节重点-3" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>从函数的角度理解迭代算法</li><li>理解格的概念</li><li>理解不动点定理</li><li>用格来概括 <em>may/must analysis</em></li><li>理解 MOP 和迭代算法之间的联系</li><li>常量传播分析</li><li>工作列表算法</li></ul><h2 id="05-Interprocedural-Analysis"><a href="#05-Interprocedural-Analysis" class="headerlink" title="05 - Interprocedural Analysis"></a>05 - Interprocedural Analysis</h2><h3 id="1-为什么需要过程间分析"><a href="#1-为什么需要过程间分析" class="headerlink" title="1. 为什么需要过程间分析"></a>1. 为什么需要过程间分析</h3><p>仅对单个方法进行静态分析，若出现了对别的方法的调用，为了确保分析的正确性，只能认为该调用可以做任何事情，从而使得分析结果不够准确。例如，在常量传播分析中，分析 <em>x = fun()</em> 会认为 <em>x</em> 是 NAC，但方法 <em>fun()</em> 可能返回的是一个常数，即 <em>int fun() { return 0; }</em></p><h3 id="2-调用图的构造"><a href="#2-调用图的构造" class="headerlink" title="2. 调用图的构造"></a>2. 调用图的构造</h3><p>调用图：程序中调用关系的表示方式</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271046525.png" alt="1" style="zoom:50%;" /><p>调用图的应用：过程间分析的基础，程序的优化、理解、debug、测试 ……</p><p>OO 语言的调用图的构造（以 JAVA 为代表）：</p><ul><li>类层次分析（<em>CHA，Class Hierarchy Analysis</em>）：效率高</li><li>指针分析（<em>k-CFA，Pointer Analysis</em>）：精确度高</li></ul><p>JAVA 中的方法调用共有五种，其中 <em>invokedynamic</em> 在此不做考虑，由于 <em>Virtual Call</em> 的目标方法是运行时动态确定的（多态），故构造调用图的难点和关键在于如何处理 <em>Virtual Call</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271059481.png" alt="1" style="zoom:50%;" /><p><em>Virtual Call</em> 的方法分派依据 <em>receiver object</em> 的类型 <em>c</em> 和方法的签名 <em>m</em> （形如 *&lt;ClassType：ReturnType MehtodName（ParameterTypes）&gt;*），定义函数 <em>Dispatch(c, m)</em> 去模拟运行时方法分派，总的思路是优先在子类中匹配，匹配不到则递归地到父类中匹配</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271118454.png" alt="1" style="zoom:50%;" /><p><strong>类层次分析（<em>Class Hierarchy Analysis</em>）</strong></p><p>适用于 IDE 等场景，快速分析并对准确性没有较高的要求</p><p>定义函数 <em>Resolve(cs)</em> 解析方法调用的可能的目标方法，分别处理 <em>static call</em>，<em>special call</em> 和 <em>virtual call</em></p><p>注意 <em>special call</em> 中调用父类方法的时候需要递归寻找，为了形式统一使用用 <em>Dispatch</em> 函数</p><p>注意 <em>virtual call</em> 需要对对象的声明类型及其所有子类做 <em>Dispatch</em>（可能产生假的目标方法，不够准确）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271158826.png" alt="1" style="zoom:50%;" /><p>下面是 CHA 的一个例子，注意理解 <em>Resolve( b.foo() )</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271210904.png" alt="1" style="zoom:50%;" /><p>通过 CHA 来构造调用图：从入口方法（<em>main</em>）开始，对每一个可达的方法 <em>m</em> 中的每一个调用点 <em>cs</em>，解析目标方法（*Resolve(cs)*），重复该过程知道没有新的方法被发现。具体算法如下：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271234192.png" alt="img" style="zoom:50%;" /><h3 id="3-过程间控制流图"><a href="#3-过程间控制流图" class="headerlink" title="3. 过程间控制流图"></a>3. 过程间控制流图</h3><p>回顾：控制流图（<em>CFG</em>）可以表示一个独立的方法的结构</p><p>过程间控制流图（<em>ICFG，Interprocedural Control-Flow Graph</em>）可以表示整个程序的结构，包含程序中每个方法自己的控制流图以及两类额外的边：从调用点指向被调用方法的 <em>Call edges</em> 和从被调用方法的返回语句指向返回点（即调用点的下一条语句）的 <em>Return edges</em>，额外的边的信息从构造的调用图中可以获取。概述如下图：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271459841.png" alt="img" style="zoom:50%;" /><h3 id="4-过程间数据流分析"><a href="#4-过程间数据流分析" class="headerlink" title="4. 过程间数据流分析"></a>4. 过程间数据流分析</h3><p>基于 ICFG 进行程序分析，其 <em>Transfer Function</em> 不仅需要正常的 <em>Node Transfer</em> 还要处理 <em>Call Edge Transfer</em>（用于传参） 和 <em>Return Edge Transfer</em>（用于传递返回值）</p><p><strong>过程间常量传播分析（<em>Interprocedural Constant Propagation</em>）</strong></p><p>在 ICFG 中保留了调用点到返回点之间相连的边（<em>call-to-return edge</em>），能使得 ICFG 能够传递本地数据流（单个 CFG 内产生的数据流）</p><p>在本地方法的 CFG 中的 <em>Node Transfer</em> 需要把调用点的左值变量 <em>kill</em> 掉（<em>Return Edge Transfer</em> 会覆盖这些变量的值）</p><p>下面是一个详细示例：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271523413.png" alt="1" style="zoom:50%;" /><h3 id="本节重点-4"><a href="#本节重点-4" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>如何通过 CHA 构建调用图</li><li>过程间控制流图的概念</li><li>过程间数据流分析的概念</li><li>过程间常量传播分析</li></ul><h2 id="06-Pointer-Analysis"><a href="#06-Pointer-Analysis" class="headerlink" title="06 - Pointer Analysis"></a>06 - Pointer Analysis</h2><h3 id="1-为什么需要指针分析"><a href="#1-为什么需要指针分析" class="headerlink" title="1. 为什么需要指针分析"></a>1. 为什么需要指针分析</h3><p>基于指向关系进行分析，能有效避免 CHA 中出现 <em>fake target</em> 的问题</p><p>例如：针对语句 { A a = new A(); a.fun(); }，CHA 在解析 <em>a.fun()</em> 时会得到所有 A 类型及其子类的签名为 <em>fun()</em> 的方法，而使用指针分析则可以找到唯一的一个目标方法，提高分析的准确性</p><h3 id="2-指针分析的介绍"><a href="#2-指针分析的介绍" class="headerlink" title="2. 指针分析的介绍"></a>2. 指针分析的介绍</h3><p>指针分析是基础的静态分析，计算一个指针能够指向内存中的哪些地址</p><p>对于面向对象语言，以 JAVA 为例，指针分析计算一个指针（<em>variable or field</em>）能够指向哪些对象</p><p>指针分析可以看作一种 <em>may analysis</em>，计算结果是一个 <em>over-approximation</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281010951.png" alt="img" style="zoom:50%;" /><p>概念辨析：指针分析 vs. 别名分析</p><p>指针分析回答的问题：Which objects a pointer can point to ?</p><p>别名分析回答的问题：Can two pointers point to the same object ?</p><p>别名分析的结果可由指针分析的结果推到而来</p><h3 id="3-影响指针分析的关键要素"><a href="#3-影响指针分析的关键要素" class="headerlink" title="3. 影响指针分析的关键要素"></a>3. 影响指针分析的关键要素</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271601082.png" alt="img" style="zoom:50%;" /><p><strong>堆抽象（<em>Heap Abstraction</em>）</strong></p><p>为了保证静态分析能够终止，对堆内存进行建模，把 <em>动态分配的无限的具体对象</em>  构建成 <em>有限的抽象的对象</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271611034.png" alt="1" style="zoom:50%;" /><p>调用点抽象技术（<em>Allocation-Site Abstraction</em>）</p><p>将实例对象抽象成创建点，每个创建点建立一个抽象对象，用来表示该创建点分配的具体对象（在循环中的同一个创建点实际运行时会创建多个具体对象，但由于只有一个创建点只会创建一个抽象对象）</p><p><strong>上下文敏感（<em>Context Sensitivity</em>）</strong></p><p>上下文敏感的分析中，对同一个方法的不同调用进行区分，对每一个上下文都分析一次目标方法</p><p>上下文不敏感的分析中，对同一个方法的不同调用做数据流的合并处理，只分析一次，可能丢失精度</p><p><strong>流敏感（<em>Flow Sensitivity</em>）</strong></p><p>流敏感的分析是尊重语句的执行顺序的，程序中每个位置都维护了一个包含指向关系的 map</p><p>流不敏感的分析是忽视控制流的顺序的，整个程序只维护了一个包含指向关系的 map</p><p><strong>分析域（<em>Analysis Scope</em>）</strong></p><p>全程序分析：计算程序中所有指针的信息，服务所有可能的应用</p><p>需求驱动分析：只计算需要用到的指针的信息，服务特定的应用</p><h3 id="4-指针分析需要分析的语句"><a href="#4-指针分析需要分析的语句" class="headerlink" title="4. 指针分析需要分析的语句"></a>4. 指针分析需要分析的语句</h3><p>指针分析只关注 <em>Pointer-Affecting Statements</em></p><p>JAVA 中的指针：</p><ul><li>本地变量（<em>local variable</em>）<em>e.g.</em>  x</li><li>静态字段（<em>static field</em>）<em>e.g.</em>  C.f</li><li>实例字段（<em>instance field</em>）<em>e.g.</em>  x.f</li><li>数组元素（<em>array element</em>）<em>e.g.</em>  array[i]</li></ul><p>在数组元素的指针分析中，忽略数组下标，把整个数组视作一个单独的 <em>field</em></p><p>处理静态字段的方式与处理本地变量相似，处理数组元素的方式与处理实例字段相似</p><p>JAVA 中的 <em>pointer-affecting statements</em>：</p><ul><li>创建 New    <em>x = new T()</em></li><li>赋值 Assign    <em>x = y</em></li><li>存储 Store    <em>x.f = y</em></li><li>加载 Load    <em>y = x.f</em></li><li>调用 Call    <em>r = x.k(a, …)</em></li></ul><h3 id="本节重点-5"><a href="#本节重点-5" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>什么是指针分析</li><li>理解影响指针分析的关键要素</li><li>理解指针分析需要分析哪些内容</li></ul><h2 id="07-Pointer-Analysis（Foundations）"><a href="#07-Pointer-Analysis（Foundations）" class="headerlink" title="07 - Pointer Analysis（Foundations）"></a>07 - Pointer Analysis（Foundations）</h2><blockquote><p>本章节介绍使用调用点抽象技术、上下文不敏感、流不敏感的全程序指针分析</p></blockquote><h3 id="1-指针分析的规则"><a href="#1-指针分析的规则" class="headerlink" title="1. 指针分析的规则"></a>1. 指针分析的规则</h3><p>在 JAVA 的指针分析中，常用流不敏感的方式（效率高，精度损失可接受）</p><p>指针分析的域及其表示：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281054043.png" alt="img" style="zoom:50%;" /><p>不同语句的指针分析规则：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281059426.png" alt="1" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281109304.png" alt="img" style="zoom:50%;" /><h3 id="2-指针分析的实现"><a href="#2-指针分析的实现" class="headerlink" title="2. 指针分析的实现"></a>2. 指针分析的实现</h3><p>指针分析要在指针间传播指向信息，指针分析解决的是指针间的包含约束系统的问题</p><p>实现指针分析的关键在于：当指针集 <em>pt(x)</em> 改变时，要把更新的信息传播给其他与 <em>x</em> 相关的指针</p><p>实现方式：用图去连接相关联的指针，当指针集 <em>pt(x)</em> 改变时，把更新的信息传播给 <em>x</em> 的后继</p><p><strong>指针流图（<em>Pointer Flow Graph，PFG</em>）</strong></p><p>指针流图的节点为 <em>Pointer</em> = *V ∪ (O × F)*，可能是变量或抽象对象的字段</p><p>指针流图的边为 <em>Pointer × Pointer</em>，由 <em>x</em> 指向 <em>y</em> 的边表示 <em>x</em> 指向的对象有可能被 <em>y</em> 指向</p><p>指针流图的边由程序中的语句和处理指针分析的规则来确定：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061225160.png" alt="image-20220806122505050" style="zoom:50%;" /><p>通过指针流图，指针分析问题可以转化为在指针流图上求解传递闭包的问题</p><p>指针分析的复杂性在于构建指针流图和传播指向信息相互依赖（在指针分析的过程中，指针流图也在不断更新迭代，从而再次影响指针分析的过程）：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061238046.png" alt="image-20220806123814992" style="zoom:50%;" /><h3 id="3-指针分析的算法"><a href="#3-指针分析的算法" class="headerlink" title="3. 指针分析的算法"></a>3. 指针分析的算法</h3><p><strong>完整的算法过程：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061242284.png" alt="image-20220806124226182" style="zoom:50%;" /><p>关于算法中 <em>WL</em>，即 <em>Worklist</em> 的解释：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061248121.png" alt="image-20220806124824952" style="zoom:50%;" /><h3 id="4-带有方法调用的指针分析"><a href="#4-带有方法调用的指针分析" class="headerlink" title="4. 带有方法调用的指针分析"></a>4. 带有方法调用的指针分析</h3><p>过程间的指针分析需要构建调用图，使用 <em>CHA</em> 基于声明类型解析目标方法可能产生 <em>fake target</em>，在指针分析中，可以基于变量的指针集进行解析，得到更准确的调用图（<em>on-the fly call graph construnction</em>）</p><p><strong>方法调用的指针分析规则：</strong></p><p>一个方法调用要做的四件事：Dispatch；传 receiver object；传参数；传返回值</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061604497.png" alt="image-20220806160402337" style="zoom:50%;" /><p>思考：为什么不在 <em>PFG</em> 中添加由 <em>x</em> 到 <em>m_this</em> 的边？</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061653145.png" alt="image-20220806165315061" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061653241.png" alt="image-20220806165343145" style="zoom:50%;" /><p>过程间指针分析和调用图的构建相互依赖，同时进行</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061726888.png" alt="image-20220806172637806" style="zoom:50%;" /><p><strong>带有方法调用的指针分析的算法实现：</strong></p><p>（黄底内容为新增部分）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061729060.png" alt="image-20220806172859940" style="zoom:50%;" /><h3 id="本节重点-6"><a href="#本节重点-6" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>理解指针分析的规则</li><li>理解指针流图</li><li>理解指针分析的方法</li><li>理解指针分析处理方法调用的规则</li><li>理解过程间指针分析算法</li><li>理解即时调用图构建</li></ul><h2 id="08-Pointer-Analysis（Context-Sensitivity）"><a href="#08-Pointer-Analysis（Context-Sensitivity）" class="headerlink" title="08 - Pointer Analysis（Context Sensitivity）"></a>08 - Pointer Analysis（Context Sensitivity）</h2><blockquote><p>本章节介绍使用调用点抽象技术、上下文敏感、流不敏感的全程序指针分析</p></blockquote><h3 id="1-上下文敏感指针分析介绍"><a href="#1-上下文敏感指针分析介绍" class="headerlink" title="1. 上下文敏感指针分析介绍"></a>1. 上下文敏感指针分析介绍</h3><p><strong>为什么需要上下文敏感技术：</strong></p><p>在动态执行的时候，一个方法可能被调用多次，而不同调用的上下文不同（传参不同、返回点不同），故在上下文不敏感的指针分析中，不同调用上下文混合的数据流在程序中传播，产生假的数据流，影响程序分析的精度；引入上下文敏感技术，区分不同上下文之间的数据流，可以提升程序分析的精度</p><p><strong>上下文的表示方式：</strong></p><p>使用调用点来作为上下文：用一系列调用点来链式表示每个上下文（栈抽象）</p><p><strong>上下文敏感的实现：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081252673.png" alt="image-20220808125210400" style="zoom:50%;" /><p><strong>上下文敏感的堆抽象：</strong></p><p>在 <em>OO</em> 程序中，经常需要修改堆上对象，因此在实际情况中，上下文敏感技术需要应用于堆抽象</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081300289.png" alt="image-20220808130043102" style="zoom:50%;" /><p>为什么上下文敏感的堆抽象能够提升分析精度：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081302280.png" alt="image-20220808130257124" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081538904.png" alt="image-20220808153838733" style="zoom:50%;" /><h3 id="2-上下文敏感指针分析规则"><a href="#2-上下文敏感指针分析规则" class="headerlink" title="2. 上下文敏感指针分析规则"></a>2. 上下文敏感指针分析规则</h3><p><strong>上下文敏感指针分析的域及其表示：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081542619.png" alt="image-20220808154228430" style="zoom:50%;" /><p><strong>上下文敏感指针分析的规则：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081554195.png" alt="image-20220808155432112" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081609672.png" alt="image-20220808160955460" style="zoom:50%;" /><h3 id="3-上下文敏感指针分析算法"><a href="#3-上下文敏感指针分析算法" class="headerlink" title="3. 上下文敏感指针分析算法"></a>3. 上下文敏感指针分析算法</h3><p>基本思路和上下文不敏感的指针分析相似，即：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081847583.png" alt="image-20220808184754519" style="zoom:50%;" /><p>其中 <em>PFG with C.S.</em> 是一个有向图，定义如下：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081850174.png" alt="image-20220808185051069" style="zoom:50%;" /><p><em>PFG with C.S.</em> 边的建立：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081854521.png" alt="image-20220808185440449" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081856242.png" alt="image-20220808185605023" style="zoom:50%;" /><p>上下文敏感指针分析完整算法：</p><p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208082003685.png" alt="image-20220808200312549"></p><h3 id="4-上下文敏感技术的变种"><a href="#4-上下文敏感技术的变种" class="headerlink" title="4. 上下文敏感技术的变种"></a>4. 上下文敏感技术的变种</h3><blockquote><p>上下文敏感指针分析算法中 <em>Select</em> 方法的具体实现方式</p></blockquote><p><strong>调用点敏感（<em>Call-site Sensitivity</em>）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208082233180.png" alt="image-20220808223352053" style="zoom:50%;" /><p>为了避免产生过多的上下文，保证指针分析在合理的时间内完成，需要对调用链的长度进行限制（<em>e.g.</em> 递归调用能够产生很长的调用链），故引入 <em>k-Limiting Context Abstraction</em>，即选用最后的 <em>k</em> 个调用点作为上下文：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091134010.png" alt="image-20220809113401843" style="zoom:50%;" /><p><strong>调用对象敏感（<em>Object Sensitivity</em>）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091220974.png" alt="image-20220809122016842" style="zoom:50%;" /><p>在 <em>OO</em> 语言的实际应用中，调用对象敏感效果比调用点敏感速度更快、效果更好</p><p><strong>调用类型敏感（<em>Type Sensitivity</em>）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091409784.png" alt="image-20220809140913638" style="zoom:50%;" /><p>调用类型敏感是对调用对象敏感的一种粗粒度的抽象，获取了更快的分析速度，牺牲了精度</p><p><strong>三种上下文敏感技术变体的对比</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091415141.png" alt="image-20220809141528031" style="zoom:50%;" /><h3 id="本节重点-7"><a href="#本节重点-7" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>上下文敏感的概念</li><li>上下文敏感的堆抽象的概念</li><li>为什么上下文敏感和上下文敏感的堆抽象能够提升分析的精度</li><li>上下文敏感的指针分析的规则</li><li>上下文敏感指针分析的算法</li><li>常见的上下文敏感技术的变体</li><li>常见的上下文敏感技术的变体的不同与联系</li></ul><h2 id="09-Static-Analysis-For-Security"><a href="#09-Static-Analysis-For-Security" class="headerlink" title="09 - Static Analysis For Security"></a>09 - Static Analysis For Security</h2><h3 id="1-信息流安全"><a href="#1-信息流安全" class="headerlink" title="1. 信息流安全"></a>1. 信息流安全</h3><p>与访问控制不同，信息流表示一种端到端的数据流动</p><p>给程序中的变量赋予不同的密级（<em>Security Level</em>）以构建实现信息流安全的策略</p><p>密级可以用格（<em>Lattice</em>）进行建模，虽然二元密级（<em>Low &amp; High</em>）最为常见和常用，但是也可以存在复杂的密级结构：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101547940.png" alt="image-20220810154757779" style="zoom: 40%;" /><p>非干涉策略（<em>Noninterference Policy</em>）：不允许信息从高密级流向低密级</p><h3 id="2-保密性和完整性"><a href="#2-保密性和完整性" class="headerlink" title="2. 保密性和完整性"></a>2. 保密性和完整性</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101553122.png" alt="image-20220810155305010" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101557442.png" alt="image-20220810155701257" style="zoom:50%;" /><h3 id="3-显式流和隐藏信道"><a href="#3-显式流和隐藏信道" class="headerlink" title="3. 显式流和隐藏信道"></a>3. 显式流和隐藏信道</h3><p>显式流（<em>explicit flow</em>）：通过直接拷贝进行的信息流动</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101837830.png" alt="image-20220810183716782" style="zoom:50%;" /><p>隐式流（<em>implicit flow</em>）：控制流受到高密级信息的影响，如果产生的副作用能被观测到则会信息泄露</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101836377.png" alt="image-20220810183644320" style="zoom:50%;" /><p>隐藏信道（<em>hidden channel</em>）：不是用来传递信息流的内容将信息间接地传递出去，造成信息泄露</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102026254.png" alt="image-20220810202644130" style="zoom:50%;" /><p>就保密性而言，隐藏信道泄露的信息量有限，就完整性而言，隐藏信道不会造成什么危害，故应当优先处理显式流中的信息流安全问题</p><h3 id="4-污点分析"><a href="#4-污点分析" class="headerlink" title="4. 污点分析"></a>4. 污点分析</h3><p>污点分析（<em>Taint Analysis</em>）将程序中的数据分为两类：</p><ul><li><em>Data of interest</em>，将某些标签与其进行绑定，称之为污点数据（<em>tainted data</em>）</li><li><em>Other data</em>，称之为非污点数据（<em>untainted data</em>）</li></ul><p>污点数据的源头称为 <em>source</em>，实际情况中，污点数据通常来源于某些方法（<em>sources</em>）的返回值</p><p>污点分析追踪污点数据，观测其是否会流入某个特定的地方（<em>sink</em>） ，实际情况下通常是某些方法传参</p><p>污点分析的两种应用：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102046001.png" alt="image-20220810204620890" style="zoom:50%;" /><p>污点分析和指针分析本质上具有高度一致性，可以依据指针分析来做污点分析：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102050227.png" alt="image-20220810205031124" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102054790.png" alt="image-20220810205425522" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102058692.png" alt="image-20220810205817421" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102102679.png" alt="image-20220810210253547" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102100445.png" alt="image-20220810210049208" style="zoom:50%;" /><h3 id="本节重点-8"><a href="#本节重点-8" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>信息流安全的概念</li><li>保密性和完整性的概念</li><li>显式流和隐藏信道的概念</li><li>如何使用污点分析的检测有安全隐患的信息流</li></ul><h2 id="实验作业部分"><a href="#实验作业部分" class="headerlink" title="实验作业部分"></a>实验作业部分</h2><h3 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h3><ul><li>为 Java 实现一个活跃变量分析（Live Variable Analysis）</li><li>实现一个通用的迭代求解器（Iterative Solver），用于求解数据流分析问题，也就是本次作业中的活跃变量分析</li></ul><p><em>LiveVariableAnalysis</em> 类提供了一个活跃变量分析器，提供算法执行过程中所需要的接口（图中红色的方法标注），作为 <em>Solver</em> 类的一个私有变量</p><p><em>Solver</em> 类执行整个算法流程（大致分为初始化和循环体两个模块），分析结果以一个 <em>DataflowResult</em> 类的对象返回</p><p>注意 <em>LiveVariableAnalysis</em> 类只关注逻辑，IN, OUT, EXIT, ENTRY 等信息由 <em>DataflowResult</em> 类通过 <em>inFacts</em> 和 <em>outFacts</em> 两个 Map 管理</p><p>注意作业中为了简化实现难度没有使用 basic blocks，以单条语句为单位处理</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207151730781.png" alt="1" style="zoom: 40%;" /><h3 id="A2"><a href="#A2" class="headerlink" title="A2"></a>A2</h3><ul><li>为 Java 实现常量传播算法</li><li>实现一个通用的 worklist 求解器，并用它来解决一些数据流分析问题，例如本次的常量传播</li></ul><p>与 A1 的任务总体结构相同，理解常量传播和 worklist 的实现方式并读懂提供的框架源码即可</p><p>注意 newBoundryFact() 需要将方法的参数初始化为 NAC（参数不由方法本身决定，故必不是常量）</p><p>注意 transferNode() 的返回值为一个布尔类型，worklist 算法中不需要重复判断 OUT 是否被改变</p><p>注意 CPFact 类的设计，变量不在某个 CPFact 对象中视为 UNDEF</p><p>（有部分隐藏用例没有通过，大概猜测是在 evaluate() 方法中一些除了 Var, IntLiteral 和 BinaryExp 其他一些特殊类型的 expression 没有考虑的缘故，暂且搁置）</p><p>关于 debug：在 IntelliJ IDEA 中进行断点调试的时候，出现 ”<em>Skipped breakpoint at … because it happened inside debugger evaluation</em>“，打条件断点的地方被跳过，是由于测试时使用了多线程，将断点设置中 <em>Suspend</em> 选项的 <em>All</em> 改成 <em>Thread</em> 即可（如图所示）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207261829825.png" alt="1" style="zoom:50%;" /><h3 id="A3"><a href="#A3" class="headerlink" title="A3"></a>A3</h3><ul><li>为 Java 实现一个死代码（dead code）检测算法</li></ul><p>该死代码检测作业需要找出两种死代码：不可达代码和无用赋值</p><p>不可达代码又分为控制流不可达（e.g. Return 语句之后的代码）和分支不可达（e.g. 条件跳转处的条件为常量）</p><p>本次作业需要用到 A1 中实现的活跃变量分析（寻找无用赋值）和 A2 中实现的常量传播分析（寻找分支不可达的代码），并新补充实现 <em>DeadCodeDetection</em> 类中的 <em>analyse</em> 方法</p><p>在 <em>analyse</em> 方法中，已经构建了程序的控制流图、常量传播分析结果和活跃变量分析结果，需要以此为据找出可以被判定为死代码的语句，以一个集合的形式返回</p><p>一开始的思路是直接寻找死代码语句，但发现由于在数据流不向后继续传递，在确定一条语句为死代码后难以判断其后继语句是否为死代码，故转换思路，通过确定活代码来反推死代码，总体思路为从程序入口处开始，借助常量传播分析结果和活跃变量分析结果，在控制流图上遍历所有可能被执行的活代码并标记，没有被标记到的节点即为死代码</p><h3 id="A4"><a href="#A4" class="headerlink" title="A4"></a>A4</h3><ul><li>为 Java 实现一个类层次结构分析（Class Hierarchy Analysis，CHA）</li><li>实现过程间常量传播</li><li>实现过程间数据流传播的 worklist 求解器</li></ul><p>类层次结构分析部分需要实现 <em>buildCallGraph</em>、<em>resolve</em> 和 <em>dispatch</em> 三个方法，课件中已经给出了相应的算法流程，模拟实现即可</p><ul><li><em>callSite.getMethodRef().getDeclaringClass()</em> 获取调用点的对象的声明类型</li><li><em>callSite.getMethodRef().getSubsignature()</em> 获取调用点方法的子签名（一个方法的子签名只包含它的方法名和方法签名的描述符）</li><li>成员变量 <em>hierarchy</em> 中包含了所有类和接口的继承和实现关系</li></ul><p>过程间的常量传播需要考虑 <em>transferNode</em> 和 <em>transferEdge</em> 两种情况：</p><ul><li><em>transferNode</em> 分为 <em>transferCallNode</em> 和 <em>transfeNonCallNode</em>：由于调用由 <em>transferEdge</em> 处理，<em>transferCallNode</em> 只需要做恒等传播；而 <em>transfeNonCallNode</em> 与 A2 中的非过程间常量传播的 <em>transferNode</em> 相同</li><li><em>transferEdge</em> 分为 <em>transferCallToReturnEdge</em>、<em>transferCallEdge</em> 和 <em>transferReturnEdge</em>：<em>transferCallToReturnEdge</em> 需要将调用点的左值 kill 掉（如果存在的话）；<em>transferCallEdge</em> 需要完成参数的值的传递；<em>transferReturnEdge</em> 需要完成返回值向调用点左值的赋值（如果存在的话）</li></ul><p>（注意 <em>transferEdge</em> 的返回值是一个新的 <em>Fact</em>，不改变已有的 <em>Fact</em>）</p><p>e.g. 下图中蓝色虚线箭头为 <em>callEdge</em>，红色虚线箭头为 <em>returnEdge</em>，黑色虚线箭头为 <em>callToReturnEdge</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207292143391.png" alt="image-20220729214359229" style="zoom: 33%;" /><p>在实现 worklist 求解器时，注意与之前实现的不同之处有：</p><ul><li><p>初始化时，需要对所有的 <em>entry method</em> 的 <em>entry</em> 节点进行 <em>newBoundaryFact</em>（可使用 <em>icfg.entryMethods().toList()</em> 获取所有的 <em>entry method</em>）</p></li><li><p>执行算法流程时，每个节点的 <em>inFact</em> 不再是和所有前驱节点的 <em>outFact</em> 做 <em>meet</em> 操作获得，而是和所有汇入的边所带来的 <em>Fact</em> 做 <em>meet</em> 操作获得</p></li></ul><h3 id="A5"><a href="#A5" class="headerlink" title="A5"></a>A5</h3><ul><li>为 Java 实现非上下文敏感的指针分析</li><li>为指针分析实现一个调用图的实时构建算法</li></ul><p>作业文档足够详细，难度不大，按照算法流程实现即可，注意：</p><ol><li>每个方法可能有多个返回值，也有可能没有返回值</li><li>处理方法调用时需要的 dispatch 方法已经给出（*resolveCallee()*）可直接调用</li><li>新引入的静态字段、静态方法调用和数组在需要算法中进行处理的位置</li><li><em>var.getStoreFields()、var.getLoadArrays()、var.getInvokes()</em> 等接口可直接获取变量相关的语句</li><li><em>AddReachable</em> 方法使用了<a href="https://refactoringguru.cn/design-patterns/visitor">访问者设计模式 </a></li><li>提供的框架将算法中 Δ 的计算融入了 <em>propagate</em> 方法中</li></ol><p>参考算法流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Solve(m_entry):</span><br><span class="line">WL=[], PFG=&#123;&#125;, S=&#123;&#125;, RM=&#123;&#125;, CG=&#123;&#125;</span><br><span class="line">addReachable(m_entry)</span><br><span class="line">while WL is not empty do</span><br><span class="line">remove &lt;n, pts&gt; from WL</span><br><span class="line">Δ = pts - pt(n)</span><br><span class="line">Propagate(n, Δ)</span><br><span class="line">if n represents a variable x then</span><br><span class="line">foreach o ∈ Δ do</span><br><span class="line">foreach x.f = y ∈ S do</span><br><span class="line">AddEdge(y, o.f)</span><br><span class="line">foreach y = x.f ∈ S do</span><br><span class="line">AddEdge(o.f, y)</span><br><span class="line">foreach x[*] = y ∈ S do</span><br><span class="line">AddEdge(y, o[*])</span><br><span class="line">foreach y = x[*] ∈ S do</span><br><span class="line">AddEdge(o[*], y)</span><br><span class="line">ProcessCall(x, o)</span><br><span class="line"></span><br><span class="line">AddReachable(m):</span><br><span class="line">if m ∉ RM then</span><br><span class="line">add m to RM</span><br><span class="line">S ∪= S_m</span><br><span class="line">foreach i: x = new T() ∈ S_m do</span><br><span class="line">add &lt;x, &#123;o_i&#125;&gt; to WL</span><br><span class="line">foreach x = y ∈ S_m do</span><br><span class="line">AddEdge(y, x)</span><br><span class="line">foreach T.f = y ∈ S_m do</span><br><span class="line">AddEdge(y, T.f)</span><br><span class="line">foreach y = T.f ∈ S_m do</span><br><span class="line">AddEdge(T.f, y)</span><br><span class="line">foreach l: x = T.k(a1,...,an) ∈ S_m do</span><br><span class="line">f = Dispatch(_, k)</span><br><span class="line">if l → f ∉ CG then</span><br><span class="line">add l → f to CG</span><br><span class="line">AddReachable(f)</span><br><span class="line">foreach parameter p_i of f do</span><br><span class="line">AddEdge(a_i, p_i)</span><br><span class="line">AddEdge(f_ret, x)</span><br><span class="line"></span><br><span class="line">ProcessCall(x, o):</span><br><span class="line">foreach l: r = x.k(a1,...,an) ∈ S_m do</span><br><span class="line">m = Dispatch(o, k)</span><br><span class="line">add &lt;m_this, &#123;o&#125;&gt; to WL</span><br><span class="line">if l → m ∉ CG then</span><br><span class="line">add l → f to CG</span><br><span class="line">AddReachable(m)</span><br><span class="line">foreach parameter p_i of m do</span><br><span class="line">AddEdge(a_i, p_i)</span><br><span class="line">AddEdge(m_ret, r)</span><br><span class="line"></span><br><span class="line">AddEdge(s, t):</span><br><span class="line">if s → t ∉ PFG then</span><br><span class="line">add s → t to PFG</span><br><span class="line">if pt(s) is not empty then</span><br><span class="line">add &lt;t, pt(s)&gt; to WL</span><br><span class="line"></span><br><span class="line">Propagate(n, pts):</span><br><span class="line">if pts is not empty then</span><br><span class="line">pt(n) ∪= pts</span><br><span class="line">foreach n → s ∈ PFG do</span><br><span class="line">add &lt;s, pts&gt; to WL</span><br></pre></td></tr></table></figure><h3 id="A6"><a href="#A6" class="headerlink" title="A6"></a>A6</h3><ul><li>为 Java 实现一个上下文敏感的指针分析框架</li><li>作为指针分析的一部分，随着指针分析一起实现调用图（call graph）构建</li><li>实现几种常见的上下文敏感策略（context sensitivity variants）</li></ul><p>与 A5 相似，注意上下文的正确对应即可</p><h3 id="A7"><a href="#A7" class="headerlink" title="A7"></a>A7</h3><blockquote><p>开放性作业</p></blockquote><ul><li>为 Java 实现一个 alias-aware 的过程间常量传播分析</li></ul><p>在 A4 的基础上，利用 A6 中实现的指针分析的分析结果，得到更精确的过程间常量传播分析</p><p>A4 在 A3 的基础上，解决了把所有方法调用的返回值全部置为 <em>NAC</em> 的问题</p><p>A7 在 A4 的基础上，解决了把所有 <em>load</em> 语句（e.g. x = y.f）给变量的赋值全部置为 <em>NAC</em> 的问题</p><p>简言之就是，对于 <em>load</em> 语句 <em>x = y.f</em>，找出所有形如 <em>z.f = w</em>（<em>z.f</em> 满足条件是 <em>y.f</em> 的别名）的 <em>store</em> 语句，将所有变量 <em>w</em> 对应的值做 <em>meet</em> 操作并赋值给 <em>x</em></p><p>满足互为别名的条件：</p><ul><li>实例字段（<em>x.f</em> 和 <em>y.g</em>）<ul><li>字段 <em>f</em> 和字段 <em>g</em> 相同</li><li>变量 <em>x</em> 和变量 <em>y</em> 对应的指针集有交集</li></ul></li><li>静态字段（<em>T.f</em> 和 <em>Q.g</em>）<ul><li>字段 <em>f</em> 和字段 <em>g</em> 相同</li><li>类 <em>T</em> 和类 <em>Q</em> 相同</li></ul></li><li>数组元素（<em>a[i]</em> 和 *b[j]*）<ul><li>变量 <em>a</em> 和变量 <em>b</em> 对应的指针集有交集</li><li>变量 <em>i</em> 和变量 <em>j</em> 都不是 <em>UNDEF</em> 并且变量 <em>i</em> 和变量 <em>j</em> 都是常量时其值相等</li></ul></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101501773.png" alt="image-20220810150109665" style="zoom:50%;" /><p>修改 <em>transferNonCallNode</em> 方法，对所有 <strong><em>load</em> 语句和 <em>store</em> 语句</strong>进行单独处理：</p><ul><li>对于 <em>load</em> 语句，不做 A4 中的常量传播，找出将所有满足别名关系的 <em>store</em> 语句加以处理</li><li>对于 <em>store</em> 语句，需要将所有满足别名关系的 <em>load</em> 语句加入到 <em>solver</em> 的 <em>worklist</em> 中（本质上来讲，满足别名关系的 <em>load</em> 语句会动态地成为对应 <em>store</em> 语句的后继）</li></ul><h3 id="A8"><a href="#A8" class="headerlink" title="A8"></a>A8</h3><blockquote><p>开放性作业</p></blockquote><ul><li>为 Java 实现污点分析</li></ul><p>污点分析和指针分析的不同之处在于，污点可以在对象之间传播（因为污点和数据内容相关），所以不仅需要在方法调用处处理 <em>sources</em> 和 <em>sinks</em>（获取污点数据/得到污点流），还需要额外进行污点传播</p><p>在方法调用中特殊的污点传播：由 <em>base</em> 变量传给 <em>result</em>；由参数传给 <em>base</em> 变量；由参数传给 <em>result</em>，这些规则会在初始化的时候作为输入给出，可以通过 <em>TaintConfig</em> 类的 <em>getTransfer</em> 方法调用</p><p>总的来说，污点分析需要与 A6 中实现的指针分析相结合，并实现以下规则：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208111805794.png" alt="image-20220811180518725" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208111806418.png" alt="image-20220811180603335" style="zoom:50%;" /><p><strong>我的思路：</strong></p><ul><li><p><em>TaintAnalysiss</em> 中添加（实现）的主要 API：</p><ul><li><em>captureTaintObj</em>：执行 <em>Call(source)</em> 规则，返回一个新的污点对象</li><li><em>captureTaintTransfer</em>：执行特殊的污点传播规则，方法内部调用链三个私有方法 <em>captureBaseToResult</em>、<em>captureArgToBase</em> 和 <em>captureArgToResult</em>，分别执行规则 <em>Call(base-to-result)<em>、</em>Call(arg-to-base)</em> 和 <em>Call(arg-to-result)</em>  </li><li><em>collectTaintFlows</em>：执行 <em>Call(sink)</em> 规则，返回一个污点流的集合，即污点分析的结果</li></ul></li><li><p>在分析有返回值的方法调用时，调用 <em>taintAnalysis.captureTaintObj</em> 获取污点对象，并将其加入 <em>result</em> 变量的指针集中</p></li><li><p>在分析方法调用时，调用 <em>taintAnalysis.captureTaintTransfer</em> 处理污点传播</p></li></ul><p><strong>出现的问题及解决方式：</strong></p><p>当污点对象传播到某个变量的指针集中时，以该变量作为参数的方法调用可能已经被分析过，并且可能不会被再一次加入 <em>worklist</em>，导致分析结果有所遗漏（方法调用中特殊的污点传播的分析是安插在指针分析过程中的）</p><p>对 <em>propagate</em> 方法进行改进，若一个变量的指针集中有新流入污点对象，则从现有的调用图中获取所有的调用点，找到以该变量作为参数的调用点，并对该调用点单独执行一次 <em>captureTaintTransfer</em></p>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 静态分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
