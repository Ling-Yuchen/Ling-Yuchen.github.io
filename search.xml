<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 虚拟机搭建安卓测试环境</title>
      <link href="/2023/10/29/Android-Env-in-Linux-VM/"/>
      <url>/2023/10/29/Android-Env-in-Linux-VM/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-环境"><a href="#Java-环境" class="headerlink" title="Java 环境"></a>Java 环境</h1><ol><li><p><strong>使用 apt 安装 JDK</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install openjdk-11-jdk</span></span><br></pre></td></tr></table></figure></li><li><p><strong>验证安装</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -version</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找可执行文件</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> java</span></span><br><span class="line">/usr/bin/java</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /usr/bin/java</span></span><br><span class="line">lrwxrwxrwx 1 root root 22 Oct 29 11:07 /usr/bin/java -&gt; /etc/alternatives/java</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /etc/alternatives/java</span></span><br><span class="line">lrwxrwxrwx 1 root root 43 Oct 29 11:07 /etc/alternatives/java -&gt; /usr/lib/jvm/java-11-openjdk-amd64/bin/java</span><br></pre></td></tr></table></figure></li><li><p><strong>配置环境变量</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim ~/.bashrc</span></span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure></li><li><p><strong>验证配置</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmp-s java <span class="variable">$JAVA_HOME</span>/bin/java</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Android-环境"><a href="#Android-环境" class="headerlink" title="Android 环境"></a>Android 环境</h1><ol><li><p><strong>安装 Android Studio</strong></p><ul><li><p><strong>官网下载安装包</strong>：<a href="https://developer.android.google.cn/studio">https://developer.android.google.cn/studio</a></p></li><li><p><strong>解压到指定目录</strong>（以 android-studio-2022.3.1.20-linux 为例）</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo tar -xzf android-studio-2022.3.1.20-linux.tat.gz -C /opt/android</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置环境变量</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim ~/.bashrc</span></span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/opt/android/android-studio/bin</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>安装 Android SDK</strong></p><ul><li><p><strong>启动 Android Studio</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">studio.sh</span></span><br></pre></td></tr></table></figure></li><li><p><strong>首次启动根据安装向导完成安装</strong>（安装 SDK 等）</p></li><li><p>在 Android Studio 中打开 SDK Manager，<strong>检查 Android SDK Location</strong> 是否已经存在（检查该路径下是否存在 platform-tools 文件夹；可以将系统默认的路径更改为自定义的路径）</p></li><li><p><strong>配置环境变量</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim ~/.bashrc</span></span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ANDROID_HOME=/opt/android/sdk</span><br><span class="line">export PATH=$PATH:$ANDROID_HOME/platform-tools</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>验证安装</strong></p><ul><li><p>VirtualBox 管理器 =&gt; 设置 =&gt; USB 设备 =&gt; 添加一个 USB 筛选器 =&gt; 勾选需要的设备</p></li><li><p>将测试用机（HUAWEI Mate 9 Pro LON-ALOO）使用 USB 数据线与主机相连</p></li><li><p>启动虚拟机，终端输入命令 <code>adb devices</code>，显示的设备列表中出现测试用机名称</p></li><li><p>简单尝试几个 adb 指令，如 <code>adb shell pm list packages</code>，检查输出是否正常</p></li></ul></li></ol><h1 id="Appium-环境"><a href="#Appium-环境" class="headerlink" title="Appium 环境"></a>Appium 环境</h1><ol><li><p><strong>安装 Node.js</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install nodejs npm</span></span><br></pre></td></tr></table></figure></li><li><p><strong>升级 Node.js</strong>（Node 版本过低会导致安装 Appium 失败）</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo npm cache clean -f  <span class="comment"># 清除 npm 缓存</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo npm install -g n  <span class="comment"># 安装 Node 版本管理器 n</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo n stable  <span class="comment"># 安装最新稳定版本</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo n latest  <span class="comment"># 安装最新版本</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo n [version.number]  <span class="comment"># 安装指定版本</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>Appium 安装</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo npm install -g appium</span> </span><br></pre></td></tr></table></figure></li><li><p><strong>Appium 驱动安装</strong>（针对 Appium 2.x）</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">appium driver install uiautomator2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>检查 Appium 运行环境</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo npm install -g appium-doctor</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">appium-doctor --android</span></span><br></pre></td></tr></table></figure></li><li><p><strong>客户端安装</strong>（Optional）</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install Appium-Python-Client</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 自动化测试 </tag>
            
            <tag> Linux </tag>
            
            <tag> Appium </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 HugeGraph 实现 Graph RAG</title>
      <link href="/2023/10/18/HugeGraph-Graph-RAG/"/>
      <url>/2023/10/18/HugeGraph-Graph-RAG/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>本项目是在完成对于基于 NebulaGraph 在 LlamaIndex 中实现 Graph RAG 的 <a href="https://www.yosonl.work/2023/09/20/NebulaGraph-LLM&KG/">Demo</a> 复现的基础上，将其基于 HugeGraph 进行移植，旨在为 Apache 开源社区 <a href="https://github.com/apache/incubator-hugegraph-ai">incubator-hugegraph-ai</a> 项目贡献 PR。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h3><p>以 Graph RAG for Existing KG + keyword 检索模式为例，原作者先根据 ”用户的问题/要求” 由 LLM 提取出关键词，然后根据关键词在图数据库中检索，得到子图（用 <code>flat_rel_map</code> 的形式表示），最后再根据查询结果由 LLM 整合进行回答。</p><p>其中，对 <code>flat_rel_map</code> 的解释如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The flat means for multi-hop relation path, we could get</span></span><br><span class="line"><span class="comment"># knowledge like: subj -rel-&gt; obj -rel-&gt; obj &lt;-rel- obj.</span></span><br><span class="line"><span class="comment"># This type of knowledge is useful for some tasks.</span></span><br><span class="line"><span class="comment"># +---------------------+---------------------------------------------...-----+</span></span><br><span class="line"><span class="comment"># | subj                | flattened_rels                              ...     |</span></span><br><span class="line"><span class="comment"># +---------------------+---------------------------------------------...-----+</span></span><br><span class="line"><span class="comment"># | &quot;&#123;name:Tony Parker&#125;&quot;| &quot;&#123;name: Tony Parker&#125;-[follow:&#123;degree:95&#125;]-&gt; ...ili&#125;&quot;|</span></span><br><span class="line"><span class="comment"># | &quot;&#123;name:Tony Parker&#125;&quot;| &quot;&#123;name: Tony Parker&#125;-[follow:&#123;degree:95&#125;]-&gt; ...r&#125;&quot;  |</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h3 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h3><ol><li><p>通过 LLM 获得关键词，样例提示词如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATE_TMPL = (</span><br><span class="line">    <span class="string">&quot;A question is provided below. Given the question, &quot;</span></span><br><span class="line">    <span class="string">&quot;extract up to &#123;max_keywords&#125; keywords from the text. &quot;</span></span><br><span class="line">    <span class="string">&quot;Focus on extracting the keywords that we can use &quot;</span></span><br><span class="line">    <span class="string">&quot;to best lookup answers to the question. &quot;</span></span><br><span class="line">    <span class="string">&quot;Avoid stopwords.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;question&#125;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;---------------------\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Provide keywords in the following comma-separated format: &#x27;KEYWORDS: &lt;keywords&gt;&#x27;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>解析 LLM 的回答得到其中列举出的关键词，对于包含空格（含有多个单词的关键词），在对其进行保留的基础上，将构成其的所有单词均视为关键词</p></li><li><p>对解析得到的关键词进行扩充（增加同义词或其他可能形式，如复数、时态等），样例提示词如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATE_TMPL =（</span><br><span class="line">    <span class="string">&quot;Generate synonyms or possible form of keywords up to &#123;max_keywords&#125; in total,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;considering possible cases of capitalization, pluralization, common expressions, etc.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Provide all synonyms of keywords in comma-separated format: &#x27;SYNONYMS: &lt;keywords&gt;&#x27;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Note, result should be in one-line with only one &#x27;SYNONYMS: &#x27; prefix\n&quot;</span></span><br><span class="line">    <span class="string">&quot;----\n&quot;</span></span><br><span class="line">    <span class="string">&quot;KEYWORDS: &#123;question&#125;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;----&quot;</span></span><br><span class="line">）</span><br></pre></td></tr></table></figure></li><li><p>重复执行步骤 2，并与步骤 2 得到的关键词去并集</p></li><li><p>根据关键词对图数据库进行查询（NebulaGraph 使用 Cypher 作为查询语言）</p><p>以下是原作者给出的一个查询样例，其中涉及到图数据库 Schema 相关信息的均为手动在构建 NebulaGraphStore 对象时声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">WITH map&#123;`true`: &quot;-[&quot;, `false`: &quot;&lt;-[&quot;&#125; AS arrow_l,</span><br><span class="line">     map&#123;`true`: &quot;]-&gt;&quot;, `false`: &quot;]-&quot;&#125; AS arrow_r,</span><br><span class="line">     map&#123;`follow`: &quot;degree&quot;, `serve`: &quot;start_year,end_year&quot;&#125; AS edge_type_map</span><br><span class="line">  MATCH p=(start)-[e:follow|serve*..2]-()</span><br><span class="line">    WHERE id(start) IN [&quot;player100&quot;, &quot;player101&quot;]</span><br><span class="line">  WITH start, id(start) AS vid, nodes(p) AS nodes, e AS rels,</span><br><span class="line">    length(p) AS rel_count, arrow_l, arrow_r, edge_type_map</span><br><span class="line">  WITH</span><br><span class="line">    REDUCE(s = vid + &#x27;&#123;&#x27;, key IN [key_ in [&quot;name&quot;]</span><br><span class="line">      WHERE properties(start)[key_] IS NOT NULL]  | s + key + &#x27;: &#x27; +</span><br><span class="line">        COALESCE(TOSTRING(properties(start)[key]), &#x27;null&#x27;) + &#x27;, &#x27;)</span><br><span class="line">        + &#x27;&#125;&#x27;</span><br><span class="line">      AS subj,</span><br><span class="line">    [item in [i IN RANGE(0, rel_count - 1) | [nodes[i], nodes[i + 1],</span><br><span class="line">        rels[i], typeid(rels[i]) &gt; 0, type(rels[i]) ]] | [</span><br><span class="line">     arrow_l[tostring(item[3])] +</span><br><span class="line">         item[4] + &#x27;:&#x27; +</span><br><span class="line">         REDUCE(s = &#x27;&#123;&#x27;, key IN SPLIT(edge_type_map[item[4]], &#x27;,&#x27;) |</span><br><span class="line">           s + key + &#x27;: &#x27; + COALESCE(TOSTRING(properties(item[2])[key]),</span><br><span class="line">           &#x27;null&#x27;) + &#x27;, &#x27;) + &#x27;&#125;&#x27;</span><br><span class="line">          +</span><br><span class="line">     arrow_r[tostring(item[3])],</span><br><span class="line">     REDUCE(s = id(item[1]) + &#x27;&#123;&#x27;, key IN [key_ in [&quot;name&quot;]</span><br><span class="line">          WHERE properties(item[1])[key_] IS NOT NULL]  | s + key + &#x27;: &#x27; +</span><br><span class="line">          COALESCE(TOSTRING(properties(item[1])[key]), &#x27;null&#x27;) + &#x27;, &#x27;) + &#x27;&#125;&#x27;</span><br><span class="line">     ]</span><br><span class="line">  ] AS rels</span><br><span class="line">  WITH</span><br><span class="line">      REPLACE(subj, &#x27;, &#125;&#x27;, &#x27;&#125;&#x27;) AS subj,</span><br><span class="line">      REDUCE(acc = collect(NULL), l in rels | acc + l) AS flattened_rels</span><br><span class="line">  RETURN</span><br><span class="line">    subj,</span><br><span class="line">    REPLACE(REDUCE(acc = subj,l in flattened_rels|acc + &#x27; &#x27; + l),</span><br><span class="line">      &#x27;, &#125;&#x27;, &#x27;&#125;&#x27;)</span><br><span class="line">      AS flattened_rels</span><br><span class="line">  LIMIT 30</span><br></pre></td></tr></table></figure></li><li><p>根据查询结果和图数据库元数据，构造一个 NodeWithScore 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">rel_map = &#123;</span><br><span class="line">    <span class="string">&#x27;Guardians of the Galaxy&#123;name: Guardians of the Galaxy&#125;&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;Guardians of the Galaxy&#123;name: Guardians of the Galaxy&#125; &lt;-[relationship:&#123;relationship: was fired from&#125;]- James Gunn&#123;name: James Gunn&#125; -[relationship:&#123;relationship: was fired from&#125;]-&gt; Marvel&#123;name: Marvel&#125;&#x27;</span>,</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;Marvel&#123;name: Marvel&#125;&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;Marvel&#123;name: Marvel&#125; &lt;-[relationship:&#123;relationship: was fired from&#125;]- James Gunn&#123;name: James Gunn&#125; -[relationship:&#123;relationship: take responsibility for&#125;]-&gt; tweets&#123;name: tweets&#125;&#x27;</span>,</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">knowledge_sequence = [</span><br><span class="line">    <span class="string">&#x27;Guardians of the Galaxy&#123;name: Guardians of the Galaxy&#125; &lt;-[relationship:&#123;relationship: was fired from&#125;]- James Gunn&#123;name: James Gunn&#125; -[relationship:&#123;relationship: was fired from&#125;]-&gt; Marvel&#123;name: Marvel&#125;&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;Marvel&#123;name: Marvel&#125; &lt;-[relationship:&#123;relationship: was fired from&#125;]- James Gunn&#123;name: James Gunn&#125; -[relationship:&#123;relationship: take responsibility for&#125;]-&gt; tweets&#123;name: tweets&#125;&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># rel_map 为查询结果，knowledge_sequence 为查询结果中所有 flattened_rel 的集合</span></span><br><span class="line"></span><br><span class="line">_new_line_char = <span class="string">&quot;\n&quot;</span></span><br><span class="line">context_string = (</span><br><span class="line">    <span class="string">f&quot;The following are knowledge sequence in max depth&quot;</span></span><br><span class="line">    <span class="string">f&quot; <span class="subst">&#123;self._graph_traversal_depth&#125;</span> &quot;</span></span><br><span class="line">    <span class="string">f&quot;in the form of directed graph like:\n&quot;</span></span><br><span class="line">    <span class="string">f&quot;`subject -[predicate]-&gt;, object, &lt;-[predicate_next_hop]-,&quot;</span></span><br><span class="line">    <span class="string">f&quot; object_next_hop ...`&quot;</span></span><br><span class="line">    <span class="string">f&quot; extracted based on key entities as subject:\n&quot;</span></span><br><span class="line">    <span class="string">f&quot;<span class="subst">&#123;_new_line_char.join(knowledge_sequence)&#125;</span>&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rel_node_info = &#123;</span><br><span class="line">    <span class="string">&quot;kg_rel_map&quot;</span>: rel_map,</span><br><span class="line">    <span class="string">&quot;kg_rel_text&quot;</span>: knowledge_sequence,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self._graph_schema != <span class="string">&quot;&quot;</span>:</span><br><span class="line">    rel_node_info[<span class="string">&quot;kg_schema&quot;</span>] = &#123;<span class="string">&quot;schema&quot;</span>: self._graph_schema&#125;</span><br><span class="line">    </span><br><span class="line">node = NodeWithScore(</span><br><span class="line">    node=TextNode(</span><br><span class="line">        text=context_string,</span><br><span class="line">        score=<span class="number">1.0</span>,</span><br><span class="line">        metadata=rel_node_info,</span><br><span class="line">        excluded_embed_metadata_keys=[<span class="string">&quot;kg_rel_map&quot;</span>, <span class="string">&quot;kg_rel_text&quot;</span>],</span><br><span class="line">        excluded_llm_metadata_keys=[<span class="string">&quot;kg_rel_map&quot;</span>, <span class="string">&quot;kg_rel_text&quot;</span>],</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [node]</span><br></pre></td></tr></table></figure></li><li><p>使用 LLM 进行答案整合，样例提示词如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATE_TMPL =（</span><br><span class="line">    <span class="string">&#x27;Context information is below.\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;---------------------\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;&#123;context_str&#125;\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;---------------------\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;Given the context information and not prior knowledge, answer the query.\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;Query: &#123;query_str&#125;\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;Answer: &#x27;</span></span><br><span class="line">）</span><br><span class="line"></span><br><span class="line"><span class="comment"># context_str 由 NodeWithScore 对象中包含的 metadata 等数据构成</span></span><br><span class="line">context_str = (</span><br><span class="line">    <span class="string">&quot;kg_schema: &#123;&#x27;schema&#x27;: \&quot;Node properties: [&#123;&#x27;tag&#x27;: &#x27;entity&#x27;, &#x27;properties&#x27;: [(&#x27;name&#x27;, &#x27;string&#x27;)]&#125;]\nEdge properties: [&#123;&#x27;edge&#x27;: &#x27;relationship&#x27;, &#x27;properties&#x27;: [(&#x27;relationship&#x27;, &#x27;string&#x27;)]&#125;]\nRelationships: [&#x27;(:entity)-[:relationship]-&gt;(:entity)&#x27;]\n\&quot;&#125;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The following are knowledge sequence in max depth 2 in the form of directed graph like:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;`subject -[predicate]-&gt;, object, &lt;-[predicate_next_hop]-, object_next_hop ...` extracted based on key entities as subject:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Guardians of the Galaxy&#123;name: Guardians of the Galaxy&#125; &lt;-[relationship:&#123;relationship: was fired from&#125;]- James Gunn&#123;name: James Gunn&#125; -[relationship:&#123;relationship: joined&#125;]-&gt; The Suicide Squad&#123;name: The Suicide Squad&#125;\n&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;Marvel&#123;name: Marvel&#125; &lt;-[relationship:&#123;relationship: was fired from&#125;]- James Gunn&#123;name: James Gunn&#125; -[relationship:&#123;relationship: take responsibility for&#125;]-&gt; tweets&#123;name: tweets&#125;\n&quot;</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><h3 id="总体要求"><a href="#总体要求" class="headerlink" title="总体要求"></a>总体要求</h3><ul><li>将 Graph RAG for Existing KG on NebulaGraph + keyword 检索模式，移植到 HugeGraph 上</li><li>支持链式调用，将逻辑分解到不同的算子中去处理，方便使用和调试，预留定制化和可扩展的空间</li><li>基于 HugeGraph 目前对 Gremlin 查询的支持，复现 NebulaGraph 中的查询效果</li><li>可根据需要指定用于关键词匹配的图数据库字段（NebulaGraph 中固定为节点 ID）</li></ul><h3 id="前置任务"><a href="#前置任务" class="headerlink" title="前置任务"></a>前置任务</h3><blockquote><p>快速上手部署 HugeGraph-server</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker pull hugegraph/hugegraph</span></span><br></pre></td></tr></table></figure><ul><li>启动一个空白的样例图数据库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker run -itd --name=graph -p 18080:8080 hugegraph/hugegraph</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">graph:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hugegraph/hugegraph</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">18080</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker-compose up -d</span></span><br></pre></td></tr></table></figure><ul><li>启动一个加载了预设定数据的样例图数据库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker run -itd --name=graph -p 18080:8080 -e PRELOAD=<span class="literal">true</span> hugegraph/hugegraph</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">graph:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hugegraph/hugegraph</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PRELOAD=true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">18080</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker-compose up -d</span></span><br></pre></td></tr></table></figure><ul><li>启动一个加载了自定义数据的样例图数据库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker run -itd --name=graph -p 18080:8080 -e PRELOAD=<span class="literal">true</span> -v /path/to/your_script:/hugegraph/scripts/example.groovy hugegraph/hugegraph</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">graph:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hugegraph/hugegraph</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PRELOAD=true</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/path/to/your_script:/hugegraph/scripts/example.groovy</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">18080</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker-compose up -d</span></span><br></pre></td></tr></table></figure><p><strong>补充说明</strong></p><p>在设置 <code>pre-load</code> 为 <code>true</code> 时，启动容器时会执行容器内的 <code>/hugegraph/scripts/example.groovy</code> 脚本对图数据库进行初始化，此时可以在容器外手动编辑 groovy 脚本，设置 volumes 映射将其映射到容器内并覆盖原有的 groovy 脚本 <code>/hugegraph/scripts/example.groovy</code> </p><p>groovy 脚本中可以完成图数据库的 schema 定义、索引构建和数据注入等操作</p><p>以下是系统内默认的 example.groovy 脚本：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hugegraph.HugeFactory</span><br><span class="line"><span class="keyword">import</span> org.apache.hugegraph.backend.id.IdGenerator</span><br><span class="line"><span class="keyword">import</span> org.apache.hugegraph.dist.RegisterUtil</span><br><span class="line"><span class="keyword">import</span> org.apache.hugegraph.type.define.NodeRole</span><br><span class="line"><span class="keyword">import</span> org.apache.tinkerpop.gremlin.structure.T</span><br><span class="line"></span><br><span class="line">RegisterUtil.registerRocksDB()</span><br><span class="line"></span><br><span class="line">conf = <span class="string">&quot;conf/graphs/hugegraph.properties&quot;</span></span><br><span class="line">graph = HugeFactory.open(conf)</span><br><span class="line">graph.serverStarted(IdGenerator.of(<span class="string">&quot;server-tinkerpop&quot;</span>), NodeRole.MASTER)</span><br><span class="line">schema = graph.schema()</span><br><span class="line"></span><br><span class="line">schema.propertyKey(<span class="string">&quot;name&quot;</span>).asText().ifNotExist().create()</span><br><span class="line">schema.propertyKey(<span class="string">&quot;age&quot;</span>).asInt().ifNotExist().create()</span><br><span class="line">schema.propertyKey(<span class="string">&quot;city&quot;</span>).asText().ifNotExist().create()</span><br><span class="line">schema.propertyKey(<span class="string">&quot;weight&quot;</span>).asDouble().ifNotExist().create()</span><br><span class="line">schema.propertyKey(<span class="string">&quot;lang&quot;</span>).asText().ifNotExist().create()</span><br><span class="line">schema.propertyKey(<span class="string">&quot;date&quot;</span>).asText().ifNotExist().create()</span><br><span class="line">schema.propertyKey(<span class="string">&quot;price&quot;</span>).asInt().ifNotExist().create()</span><br><span class="line"></span><br><span class="line">schema.vertexLabel(<span class="string">&quot;person&quot;</span>).properties(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;city&quot;</span>).primaryKeys(<span class="string">&quot;name&quot;</span>).ifNotExist().create()</span><br><span class="line">schema.vertexLabel(<span class="string">&quot;software&quot;</span>).properties(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lang&quot;</span>, <span class="string">&quot;price&quot;</span>).primaryKeys(<span class="string">&quot;name&quot;</span>).ifNotExist().create()</span><br><span class="line">schema.indexLabel(<span class="string">&quot;personByCity&quot;</span>).onV(<span class="string">&quot;person&quot;</span>).by(<span class="string">&quot;city&quot;</span>).secondary().ifNotExist().create()</span><br><span class="line">schema.indexLabel(<span class="string">&quot;personByAgeAndCity&quot;</span>).onV(<span class="string">&quot;person&quot;</span>).by(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;city&quot;</span>).secondary().ifNotExist().create()</span><br><span class="line">schema.indexLabel(<span class="string">&quot;softwareByPrice&quot;</span>).onV(<span class="string">&quot;software&quot;</span>).by(<span class="string">&quot;price&quot;</span>).range().ifNotExist().create()</span><br><span class="line">schema.edgeLabel(<span class="string">&quot;knows&quot;</span>).sourceLabel(<span class="string">&quot;person&quot;</span>).targetLabel(<span class="string">&quot;person&quot;</span>).properties(<span class="string">&quot;date&quot;</span>, <span class="string">&quot;weight&quot;</span>).ifNotExist().create()</span><br><span class="line">schema.edgeLabel(<span class="string">&quot;created&quot;</span>).sourceLabel(<span class="string">&quot;person&quot;</span>).targetLabel(<span class="string">&quot;software&quot;</span>).properties(<span class="string">&quot;date&quot;</span>, <span class="string">&quot;weight&quot;</span>).ifNotExist().create()</span><br><span class="line">schema.indexLabel(<span class="string">&quot;createdByDate&quot;</span>).onE(<span class="string">&quot;created&quot;</span>).by(<span class="string">&quot;date&quot;</span>).secondary().ifNotExist().create()</span><br><span class="line">schema.indexLabel(<span class="string">&quot;createdByWeight&quot;</span>).onE(<span class="string">&quot;created&quot;</span>).by(<span class="string">&quot;weight&quot;</span>).range().ifNotExist().create()</span><br><span class="line">schema.indexLabel(<span class="string">&quot;knowsByWeight&quot;</span>).onE(<span class="string">&quot;knows&quot;</span>).by(<span class="string">&quot;weight&quot;</span>).range().ifNotExist().create()</span><br><span class="line"></span><br><span class="line">marko = graph.addVertex(T.label, <span class="string">&quot;person&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;marko&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">29</span>, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;Beijing&quot;</span>)</span><br><span class="line">vadas = graph.addVertex(T.label, <span class="string">&quot;person&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;vadas&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">27</span>, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;Hongkong&quot;</span>)</span><br><span class="line">lop = graph.addVertex(T.label, <span class="string">&quot;software&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;lop&quot;</span>, <span class="string">&quot;lang&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="number">328</span>)</span><br><span class="line">josh = graph.addVertex(T.label, <span class="string">&quot;person&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;josh&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">32</span>, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;Beijing&quot;</span>)</span><br><span class="line">ripple = graph.addVertex(T.label, <span class="string">&quot;software&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;ripple&quot;</span>, <span class="string">&quot;lang&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="number">199</span>)</span><br><span class="line">peter = graph.addVertex(T.label, <span class="string">&quot;person&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;peter&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">35</span>, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;Shanghai&quot;</span>)</span><br><span class="line"></span><br><span class="line">marko.addEdge(<span class="string">&quot;knows&quot;</span>, vadas, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;20160110&quot;</span>, <span class="string">&quot;weight&quot;</span>, <span class="number">0.5</span>)</span><br><span class="line">marko.addEdge(<span class="string">&quot;knows&quot;</span>, josh, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;20130220&quot;</span>, <span class="string">&quot;weight&quot;</span>, <span class="number">1.0</span>)</span><br><span class="line">marko.addEdge(<span class="string">&quot;created&quot;</span>, lop, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;20171210&quot;</span>, <span class="string">&quot;weight&quot;</span>, <span class="number">0.4</span>)</span><br><span class="line">josh.addEdge(<span class="string">&quot;created&quot;</span>, lop, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;20091111&quot;</span>, <span class="string">&quot;weight&quot;</span>, <span class="number">0.4</span>)</span><br><span class="line">josh.addEdge(<span class="string">&quot;created&quot;</span>, ripple, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;20171210&quot;</span>, <span class="string">&quot;weight&quot;</span>, <span class="number">1.0</span>)</span><br><span class="line">peter.addEdge(<span class="string">&quot;created&quot;</span>, lop, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;20170324&quot;</span>, <span class="string">&quot;weight&quot;</span>, <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">graph.tx().commit()</span><br><span class="line"></span><br><span class="line">g = graph.traversal()</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt; query all vertices: size=&quot;</span> + g.V().toList().size())</span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt; query all edges: size=&quot;</span> + g.E().toList().size())</span><br></pre></td></tr></table></figure><p>对于需要使用<strong>自定义 ID</strong> 而非<strong>主键 ID</strong> 的场景，可以参考以下这个例子：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hugegraph.HugeFactory</span><br><span class="line"><span class="keyword">import</span> org.apache.hugegraph.backend.id.IdGenerator</span><br><span class="line"><span class="keyword">import</span> org.apache.hugegraph.dist.RegisterUtil</span><br><span class="line"><span class="keyword">import</span> org.apache.hugegraph.type.define.NodeRole</span><br><span class="line"><span class="keyword">import</span> org.apache.tinkerpop.gremlin.structure.T</span><br><span class="line"></span><br><span class="line">RegisterUtil.registerRocksDB()</span><br><span class="line"></span><br><span class="line">conf = <span class="string">&quot;conf/graphs/hugegraph.properties&quot;</span></span><br><span class="line">graph = HugeFactory.open(conf)</span><br><span class="line">graph.serverStarted(IdGenerator.of(<span class="string">&quot;server-tinkerpop&quot;</span>), NodeRole.MASTER)</span><br><span class="line">schema = graph.schema()</span><br><span class="line"></span><br><span class="line">schema.propertyKey(<span class="string">&quot;name&quot;</span>).asText().ifNotExist().create()</span><br><span class="line">schema.propertyKey(<span class="string">&quot;birthDate&quot;</span>).asText().ifNotExist().create()</span><br><span class="line"></span><br><span class="line">schema.vertexLabel(<span class="string">&quot;Person&quot;</span>).useCustomizeStringId().properties(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;birthDate&quot;</span>).ifNotExist().create()</span><br><span class="line">schema.vertexLabel(<span class="string">&quot;Movie&quot;</span>).useCustomizeStringId().properties(<span class="string">&quot;name&quot;</span>).ifNotExist().create()</span><br><span class="line"></span><br><span class="line">schema.indexLabel(<span class="string">&quot;PersonByName&quot;</span>).onV(<span class="string">&quot;Person&quot;</span>).by(<span class="string">&quot;name&quot;</span>).secondary().ifNotExist().create()</span><br><span class="line">schema.indexLabel(<span class="string">&quot;MovieByName&quot;</span>).onV(<span class="string">&quot;Movie&quot;</span>).by(<span class="string">&quot;name&quot;</span>).secondary().ifNotExist().create()</span><br><span class="line"></span><br><span class="line">schema.edgeLabel(<span class="string">&quot;ActedIn&quot;</span>).sourceLabel(<span class="string">&quot;Person&quot;</span>).targetLabel(<span class="string">&quot;Movie&quot;</span>).ifNotExist().create()</span><br><span class="line"></span><br><span class="line">p1 = graph.addVertex(T.label, <span class="string">&quot;Person&quot;</span>, T.id, <span class="string">&quot;Al Pacino&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Al Pacino&quot;</span>, <span class="string">&quot;birthDate&quot;</span>, <span class="string">&quot;1940-04-25&quot;</span>)</span><br><span class="line">p2 = graph.addVertex(T.label, <span class="string">&quot;Person&quot;</span>, T.id, <span class="string">&quot;Robert De Niro&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Robert De Niro&quot;</span>, <span class="string">&quot;birthDate&quot;</span>, <span class="string">&quot;1943-08-17&quot;</span>)</span><br><span class="line">m1 = graph.addVertex(T.label, <span class="string">&quot;Movie&quot;</span>, T.id, <span class="string">&quot;The Godfather&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;The Godfather&quot;</span>)</span><br><span class="line">m2 = graph.addVertex(T.label, <span class="string">&quot;Movie&quot;</span>, T.id, <span class="string">&quot;The Godfather Part II&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;The Godfather Part II&quot;</span>)</span><br><span class="line">m3 = graph.addVertex(T.label, <span class="string">&quot;Movie&quot;</span>, T.id, <span class="string">&quot;The Godfather Coda The Death of Michael Corleone&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;The Godfather Coda The Death of Michael Corleone&quot;</span>)</span><br><span class="line"></span><br><span class="line">p1.addEdge(<span class="string">&quot;ActedIn&quot;</span>, m1)</span><br><span class="line">p1.addEdge(<span class="string">&quot;ActedIn&quot;</span>, m2)</span><br><span class="line">p1.addEdge(<span class="string">&quot;ActedIn&quot;</span>, m3)</span><br><span class="line">p2.addEdge(<span class="string">&quot;ActedIn&quot;</span>, m2)</span><br><span class="line"></span><br><span class="line">graph.tx().commit()</span><br><span class="line"></span><br><span class="line">g = graph.traversal()</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt; query all vertices: size=&quot;</span> + g.V().toList().size())</span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt; query all edges: size=&quot;</span> + g.E().toList().size()) </span><br></pre></td></tr></table></figure><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="算子定义"><a href="#算子定义" class="headerlink" title="算子定义"></a>算子定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个含有 `run(**kwargs)` 方法的 `Runnable` 接口，所有算子都要实现该接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runnable</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><ul><li><p>将整个 Graph RAG 过程定义为一个算子，该算子包含三个步骤，即三个子算子</p></li><li><p>整个 Graph RAG 过程需要用一个 Python 字典 context 来维护其上下文信息，子算子的执行结果均保存在 context 中，并向下一个子算子传递</p></li><li><p>子算子工作所需的参数可以在构造子算子时传入或运行子算子时通过上下文信息传入</p></li></ul><h4 id="算子描述"><a href="#算子描述" class="headerlink" title="算子描述"></a>算子描述</h4><ol><li>关键词提取：由 LLM 提取 query 中的关键词并进行扩展，得到关键词集 keywords，并加入上下文中</li><li>图数据库查询：根据 keywords 中的关键词匹配图数据库中的节点，以匹配到的节点提取子图并格式化为字符串，得到知识集合 knowledge，并加入上下文中</li><li>答案整合：根据原始 query 和 knowledge 中的知识构造 Prompt，由 LLM 给出答案 answer，并加入上下文中</li></ol><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphRAG</span>(<span class="title class_ inherited__">Runnable</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name: <span class="built_in">str</span> = name</span><br><span class="line">        self.operators: <span class="type">List</span>[Runnable] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extract_keyword</span>(<span class="params">self, text: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span><br><span class="line">        self.operators.append(KeywordExtract(text=text))</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query_graph_for_rag</span>(<span class="params">self, graph_store: <span class="type">Optional</span>[HugeGraphStore] = <span class="literal">None</span></span>):</span><br><span class="line">        self.operators.append(RAGGraphQuery(graph_store=graph_store))</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">synthesize_answer</span>(<span class="params">self</span>):</span><br><span class="line">        self.operators.append(AnswerSynthesize())</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.operators) == <span class="number">0</span>:</span><br><span class="line">            self.extract_keyword().query_graph_for_rag().synthesize_answer()</span><br><span class="line"></span><br><span class="line">        context = kwargs</span><br><span class="line">        <span class="keyword">for</span> op <span class="keyword">in</span> self.operators:</span><br><span class="line">            context = op.run(context=context)</span><br><span class="line">        <span class="keyword">return</span> context</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KeywordExtract</span>(<span class="title class_ inherited__">Runnable</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        text: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        llm: <span class="type">Optional</span>[BaseLLM] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        max_keywords: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        extract_template: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        expand_template: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        self._llm = llm</span><br><span class="line">        self._query = text</span><br><span class="line">        self._max_keywords = max_keywords <span class="keyword">or</span> <span class="number">5</span></span><br><span class="line">        self._extract_template = extract_template <span class="keyword">or</span> DEFAULT_KEYWORDS_EXTRACT_TEMPLATE_TMPL</span><br><span class="line">        self._expand_template = expand_template <span class="keyword">or</span> DEFAULT_KEYWORDS_EXPAND_TEMPLATE_TMPL</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, context: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> context</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RAGGraphQuery</span>(<span class="title class_ inherited__">Runnable</span>):</span><br><span class="line">    ID_RAG_GREMLIN_QUERY_TEMPL = (</span><br><span class="line">        <span class="string">&quot;g.V().hasId(&#123;keywords&#125;).as(&#x27;subj&#x27;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.repeat(&quot;</span></span><br><span class="line">        <span class="string">&quot;   bothE(&#123;edge_labels&#125;).as(&#x27;rel&#x27;).otherV().as(&#x27;obj&#x27;)&quot;</span></span><br><span class="line">        <span class="string">&quot;).times(&#123;max_deep&#125;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.path()&quot;</span></span><br><span class="line">        <span class="string">&quot;.by(project(&#x27;label&#x27;, &#x27;id&#x27;, &#x27;props&#x27;)&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(label())&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(id())&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(valueMap().by(unfold()))&quot;</span></span><br><span class="line">        <span class="string">&quot;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.by(project(&#x27;label&#x27;, &#x27;inV&#x27;, &#x27;outV&#x27;, &#x27;props&#x27;)&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(label())&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(inV().id())&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(outV().id())&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(valueMap().by(unfold()))&quot;</span></span><br><span class="line">        <span class="string">&quot;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.limit(&#123;max_items&#125;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.toList()&quot;</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    PROP_RAG_GREMLIN_QUERY_TEMPL = (</span><br><span class="line">        <span class="string">&quot;g.V().has(&#x27;&#123;prop&#125;&#x27;, within(&#123;keywords&#125;)).as(&#x27;subj&#x27;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.repeat(&quot;</span></span><br><span class="line">        <span class="string">&quot;   bothE(&#123;edge_labels&#125;).as(&#x27;rel&#x27;).otherV().as(&#x27;obj&#x27;)&quot;</span></span><br><span class="line">        <span class="string">&quot;).times(&#123;max_deep&#125;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.path()&quot;</span></span><br><span class="line">        <span class="string">&quot;.by(project(&#x27;label&#x27;, &#x27;props&#x27;)&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(label())&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(valueMap().by(unfold()))&quot;</span></span><br><span class="line">        <span class="string">&quot;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.by(project(&#x27;label&#x27;, &#x27;inV&#x27;, &#x27;outV&#x27;, &#x27;props&#x27;)&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(label())&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(inV().values(&#x27;&#123;prop&#125;&#x27;))&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(outV().values(&#x27;&#123;prop&#125;&#x27;))&quot;</span></span><br><span class="line">        <span class="string">&quot;   .by(valueMap().by(unfold()))&quot;</span></span><br><span class="line">        <span class="string">&quot;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.limit(&#123;max_items&#125;)&quot;</span></span><br><span class="line">        <span class="string">&quot;.toList()&quot;</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        graph_store: <span class="type">Optional</span>[HugeGraphStore] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        max_deep: <span class="built_in">int</span> = <span class="number">2</span>,</span></span><br><span class="line"><span class="params">        max_items: <span class="built_in">int</span> = <span class="number">30</span>,</span></span><br><span class="line"><span class="params">        prop_to_match: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="string">&#x27;name&#x27;</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    self._graph = graph_store</span><br><span class="line">    self._max_deep = max_deep</span><br><span class="line">    self._max_items = max_items</span><br><span class="line">    self._prop_to_match = prop_to_match</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, context: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> context</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnswerSynthesize</span>(<span class="title class_ inherited__">Runnable</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        llm: <span class="type">Optional</span>[BaseLLM] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        template: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        self._llm = llm</span><br><span class="line">        self._prompt_template = template <span class="keyword">or</span> DEFAULT_ANSWER_SYNTHESIZE_TEMPLATE_TMPL</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, context: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> context</span><br></pre></td></tr></table></figure><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><ol><li>关键词提取：<ol><li>与原 Demo 的实现方式基本一致</li><li>搬运了原 Demo 中的提示词模板</li><li>搬运了 LlamaIndex 中的工具函数 <code>get_cache_dir()</code> 和 <code>get_stopwords()</code>（需要 <code>import nltk</code>）</li></ol></li><li>图数据库查询：<ol><li>与原 Demo 的实现思路基本一致，方式上根据 HugeGraph 做出了调整</li><li>查询语言由 Cypher 改为 Gremlin</li><li>关键词匹配字段由 id 改为可自定义，设置了进行关键词匹配的字段，默认为 None 即 id</li><li>增加了对用于关键词匹配的属性自动创建索引</li><li>在查询结果的基础上进行 flattened_rels 字符串的构造（原 Demo 在查询过程中便完成了该步骤）</li><li>额外增加了删除环形路径的处理逻辑，即将 A=&gt;B&lt;=A 变为 A=&gt;B</li></ol></li><li>答案整合：<ol><li>与原 Demo 的实现方式基本一致</li><li>搬运了原 Demo 中的提示词模板</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 知识图谱 </tag>
            
            <tag> 图数据库 </tag>
            
            <tag> RAG </tag>
            
            <tag> HugeGraph </tag>
            
            <tag> Gremlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《高级软件工程技术方向实践》项目（ing）</title>
      <link href="/2023/09/30/NJU-ASETP/"/>
      <url>/2023/09/30/NJU-ASETP/</url>
      
        <content type="html"><![CDATA[<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><p>从 StackOverflow 的问答中爬取数据，用于构造后端知识库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">api_url = <span class="string">&quot;https://api.stackexchange.com/2.3/search&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置查询参数，使用关键字搜索与异常和报错相关的问题</span></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;site&quot;</span>: <span class="string">&quot;stackoverflow&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pagesize&quot;</span>: <span class="number">100</span>,  <span class="comment"># 每次请求获取的问题数量</span></span><br><span class="line">    <span class="string">&quot;intitle&quot;</span>: <span class="string">&quot;exception&quot;</span>,  <span class="comment"># 使用关键字搜索</span></span><br><span class="line">    <span class="string">&quot;key&quot;</span>: <span class="string">&quot;OcugRWcRkGc4BmksZoNdag((&quot;</span>  <span class="comment"># 替换为你的Stack Exchange API密钥</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建空的 questions 列表</span></span><br><span class="line">questions = []</span><br><span class="line">page = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 CSV 文件并写入标题行</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(</span><br><span class="line">    <span class="string">&quot;stackoverflow_data_exception.csv&quot;</span>,</span><br><span class="line">    mode=<span class="string">&quot;w&quot;</span>,</span><br><span class="line">    newline=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    encoding=<span class="string">&quot;utf-8&quot;</span></span><br><span class="line">) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;Question ID&quot;</span>, <span class="string">&quot;Question Title&quot;</span>, <span class="string">&quot;Answer ID&quot;</span>, <span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用多线程并行获取数据</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(questions) &lt; <span class="number">5000</span>:</span><br><span class="line">        <span class="comment"># 发送请求</span></span><br><span class="line">        response = requests.get(api_url, params=params)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            data = response.json()</span><br><span class="line">            items = data.get(<span class="string">&quot;items&quot;</span>, [])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> items:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            questions.extend(items)</span><br><span class="line">            page += <span class="number">1</span></span><br><span class="line">            params[<span class="string">&quot;page&quot;</span>] = page</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理问题及答案，这里处理逻辑与之前的代码类似</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_question</span>(<span class="params">question</span>):</span><br><span class="line">        question_id = question[<span class="string">&quot;question_id&quot;</span>]</span><br><span class="line">        title = question[<span class="string">&quot;title&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取问题的答案</span></span><br><span class="line">        answers_api_url = <span class="string">f&quot;https://api.stackexchange.com/2.3/questions/<span class="subst">&#123;question_id&#125;</span>/answers&quot;</span></span><br><span class="line"></span><br><span class="line">        answers_params = &#123;</span><br><span class="line">            <span class="string">&quot;site&quot;</span>: <span class="string">&quot;stackoverflow&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pagesize&quot;</span>: <span class="number">3</span>,  <span class="comment"># 获取前3个答案，修改为你想要的数量</span></span><br><span class="line">            <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sort&quot;</span>: <span class="string">&quot;votes&quot;</span>,  <span class="comment"># 根据投票数排序</span></span><br><span class="line">            <span class="string">&quot;filter&quot;</span>: <span class="string">&quot;withbody&quot;</span>,  <span class="comment"># 只获取包含答案内容的数据</span></span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;OcugRWcRkGc4BmksZoNdag((&quot;</span>  <span class="comment"># 替换为你的Stack Exchange API密钥</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answers_response = requests.get(answers_api_url, params=answers_params)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> answers_response.status_code == <span class="number">200</span>:</span><br><span class="line">            answers_data = answers_response.json()</span><br><span class="line">            answers = answers_data.get(<span class="string">&quot;items&quot;</span>, [])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 仅处理有至少一个回答且回答数大于等于3的问题</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(answers) &gt;= <span class="number">3</span>:</span><br><span class="line">                <span class="comment"># 输出问题标题</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Question ID: <span class="subst">&#123;question_id&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Title: <span class="subst">&#123;title&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 输出问题的前三个回答并写入CSV文件</span></span><br><span class="line">                <span class="keyword">for</span> answer <span class="keyword">in</span> answers[:<span class="number">3</span>]:</span><br><span class="line">                    answer_id = answer[<span class="string">&quot;answer_id&quot;</span>]</span><br><span class="line">                    answer_body = answer[<span class="string">&quot;body&quot;</span>]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Answer ID: <span class="subst">&#123;answer_id&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 写入CSV文件的stackoverflow_data_每一行</span></span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(</span><br><span class="line">                        <span class="string">&quot;stackoverflow_data_exception.csv&quot;</span>,</span><br><span class="line">                        mode=<span class="string">&quot;a&quot;</span>,</span><br><span class="line">                        newline=<span class="string">&quot;&quot;</span>,</span><br><span class="line">                        encoding=<span class="string">&quot;utf-8&quot;</span></span><br><span class="line">                    ) <span class="keyword">as</span> file:</span><br><span class="line">                        writer = csv.writer(file)</span><br><span class="line">                        writer.writerow([question_id, title, answer_id, answer_body])</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">50</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error getting answers for question <span class="subst">&#123;question_id&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用多线程处理问题</span></span><br><span class="line">    <span class="keyword">for</span> question <span class="keyword">in</span> questions:</span><br><span class="line">        executor.submit(process_question, question)</span><br></pre></td></tr></table></figure><h2 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h2><p>由于该项目为课程作业，本着能跑就行的原则，数据标注环节全面简化，直接取用爬取的数据的原文</p><p>图数据库 schema 设计如下：</p><ul><li><p>Vertex: Question{ title, tags, embedding }</p></li><li><p>Vertex: Answer{ content }</p></li><li><p>Edge: SolvedBy {}</p></li></ul><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>由于数据量较小，选择直接使用 Cypher 语句进行数据导入</p><p>以一个 Question 和其对应的三个 Answer 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE (q:Question&#123;title:&quot;java error installing running elastic stack in Windows 10&quot;,tags:&quot;java;elastic-stack&quot;&#125;);</span><br><span class="line"></span><br><span class="line">MATCH</span><br><span class="line">(q:Question&#123;title:&quot;java error installing running elastic stack in Windows 10&quot;,tags:&quot;java;elastic-stack&quot;&#125;)</span><br><span class="line">CREATE</span><br><span class="line">(a1:Answer&#123;content:&quot;You&#x27;r facing this problem due to wrong java folder location. Change or move your java folder to program files/Java and updated java path to ur system path and this will solve your problem .. !! This worked for me.. &quot;&#125;),</span><br><span class="line">    (a2:Answer&#123;content:&quot;First chack your JAVA_HOME, it shoud point to &amp;quot;C:/Program Files/Java/jdk-15&amp;quot; if you open service.bat you will see elasticsearch use %JAVA_HOME%/bin/java.exe, so your JAVA_HOME shoud not have /bin part. &quot;&#125;), </span><br><span class="line">    (a3:Answer&#123;content:&quot;Try using the docker ELK Stack instead installing everything manually - https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html And you can run this in a VirtualBox instance of Fedora or Ubuntu so that you don&#x27;t break your windows environment. &quot;&#125;),</span><br><span class="line">    (q)-[:SolvedBy]-&gt;(a1),</span><br><span class="line">    (q)-[:SolvedBy]-&gt;(a2),</span><br><span class="line">    (q)-[:SolvedBy]-&gt;(a3);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openai.embeddings_utils <span class="keyword">import</span> get_embedding</span><br><span class="line"></span><br><span class="line">g = Neo4jGraph()</span><br><span class="line">title = <span class="string">&quot;java error installing running elastic stack in Windows 10&quot;</span></span><br><span class="line">embedding = get_embedding(text=title, engine=<span class="string">&quot;text-embedding-ada-002&quot;</span>)</span><br><span class="line">query = <span class="string">f&quot;MATCH (n:Question) WHERE n.title=$title SET n.embedding=$embedding&quot;</span></span><br><span class="line">g.query(query=query, param_map=&#123;<span class="string">&quot;title&quot;</span>: title, <span class="string">&quot;embedding&quot;</span>: embedding&#125;)</span><br></pre></td></tr></table></figure><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h2><p>FastAPI 是一个用于构建 API 的现代、快速（高性能）的 Web 框架，使用 Python 3.8+ 并基于标准的 Python 类型提示</p><p>关键特性:</p><ul><li><strong>快速</strong>：可与 Node.js 和 Go 并肩的极高性能（归功于 Starlette 和 Pydantic），<a href="https://fastapi.tiangolo.com/zh/#_11">最快的 Python web 框架之一</a></li><li><strong>高效编码</strong>：提高功能开发速度约 200％ 至 300％</li><li><strong>更少 bug</strong>：减少约 40％ 的人为（开发者）导致错误</li><li><strong>智能</strong>：极佳的编辑器支持；处处皆可自动补全，减少调试时间</li><li><strong>简单</strong>：设计的易于使用和学习，阅读文档的时间更短</li><li><strong>简短</strong>：使代码重复最小化；通过不同的参数声明实现丰富功能，bug 更少</li><li><strong>健壮</strong>：生产可用级别的代码；还有自动生成的交互式文档</li><li><strong>标准化</strong>：基于（并完全兼容）API 的相关开放标准：<a href="https://github.com/OAI/OpenAPI-Specification">OpenAPI</a></li></ul><h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><p><strong>Query 接口</strong>：</p><p>输入：用户提问（自然语言）</p><p>处理流程：</p><ol><li>调用 OpenAI Embedding API 生成 ”用户提问（自然语言）“ 的嵌入向量</li><li>查询所有 Question 节点的嵌入向量，分别计算与用户提问嵌入向量的余弦相似度</li><li>取相似度最高的 K 个 Question 节点，保留其中相似度超过相似度阈值的节点，作为 “相关 Question 节点”</li><li>查询 “相关 Question 节点” 的所有对应 Answer 节点</li><li>将查询结果序列化为字符串，作为上下文信息，结合自然语言的用户提问，生成提示词</li><li>调用 OpenAI Chat Completion API 生成最终回答</li></ol><p>输出：LLM 基于知识图谱查询结果给出的回答</p><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h2><ul><li>制作 Docker 镜像</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> OPENAI_API_BASE <span class="string">&quot;https://api.openai-proxy.com/v1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./requirements.txt /code/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir --upgrade -r /code/requirements.txt -i https://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app /code/app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;uvicorn&quot;</span>, <span class="string">&quot;app.main:app&quot;</span>, <span class="string">&quot;--host&quot;</span>, <span class="string">&quot;0.0.0.0&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;80&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li>使用 Github Action 自动化测试和部署</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> .github/workflows</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> .github/workflows</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> deploy.yml</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Docker</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Cloud</span> <span class="string">Server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">unittest:</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">OPENAI_API_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.OPENAI_API_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">OPENAI_API_BASE:</span> <span class="string">&quot;https://api.openai-proxy.com/v1&quot;</span></span><br><span class="line">  <span class="attr">steps:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="number">3.8</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">        pip install -r requirements.txt</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">tests</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">unittest</span> <span class="string">discover</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">unittest</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">steps:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">    <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">files</span> <span class="string">to</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">uses:</span> <span class="string">appleboy/scp-action@master</span></span><br><span class="line">    <span class="attr">with:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_IP</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">source:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">      <span class="attr">target:</span> <span class="string">&quot;/path/to/backend&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Run</span> <span class="string">Docker</span> <span class="string">on</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">    <span class="attr">with:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_IP</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cd /path/to/backend</span></span><br><span class="line"><span class="string">        docker build -t asetp_backend .</span></span><br><span class="line"><span class="string">        docker stop asetp_backend_container || true</span></span><br><span class="line"><span class="string">        docker rm asetp_backend_container || true</span></span><br><span class="line"><span class="string">        docker rm asetp_backend_container || true</span></span><br><span class="line"><span class="string">        docker run -d --name asetp_backend_container -p 8000:80 -e OPENAI_API_KEY=$&#123;&#123; secrets.OPENAI_API_KEY &#125;&#125; asetp_backend</span></span><br><span class="line"><span class="string">        docker image prune -f</span></span><br></pre></td></tr></table></figure><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> LLM </tag>
            
            <tag> 后端开发 </tag>
            
            <tag> Docker </tag>
            
            <tag> 知识图谱 </tag>
            
            <tag> 图数据库 </tag>
            
            <tag> RAG </tag>
            
            <tag> Neo4j </tag>
            
            <tag> CI/CD </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> 数据标注 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KG &amp; Vison Augmented LLM in GUI Test Automation</title>
      <link href="/2023/09/30/KG-&amp;-Vison-Augmented-LLM-in-GUI-Test-Automation/"/>
      <url>/2023/09/30/KG-&amp;-Vison-Augmented-LLM-in-GUI-Test-Automation/</url>
      
        <content type="html"><![CDATA[<p>哈哈哈又是新坑…</p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> NJU-iSE </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> 自动化测试 </tag>
            
            <tag> LLM </tag>
            
            <tag> 知识图谱 </tag>
            
            <tag> 图像理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将博客同步部署到个人服务器</title>
      <link href="/2023/09/29/blog-deployment/"/>
      <url>/2023/09/29/blog-deployment/</url>
      
        <content type="html"><![CDATA[<p><strong>以 root 用户的身份登录服务器，执行以下命令：</strong></p><ul><li>安装相关依赖（Optional）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt install git nginx -y</span></span><br></pre></td></tr></table></figure><ul><li>创建文件路径并修改权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /opt/hexo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /opt/hexo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> -R 755 /opt/hexo</span></span><br></pre></td></tr></table></figure><ul><li>创建 Git 仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /opt/hexo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init --bare blog.git</span></span><br></pre></td></tr></table></figure><ul><li>配置 Nginx 托管文件目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /var/www/hexo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /var/www/hexo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> -R 755 /var/www/hexo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/nginx/sites-available/default</span></span><br><span class="line">---</span><br><span class="line">root /var/www/hexo;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>配置 Git-hooks</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /opt/hexo/blog.git/hooks/post-receive</span></span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/opt/hexo/blog.git checkout -f</span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x /opt/hexo/blog.git/hooks/post-receive</span></span><br></pre></td></tr></table></figure><p><strong>在本机的博客 Git 仓库内，执行以下操作：</strong></p><ul><li>编辑站点配置文件 <code>_config.yml</code> ，修改 Deployment 配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Original</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"> <span class="attr">repository:</span> <span class="string">git@github.com:Ling-Yuchen/Ling-Yuchen.github.io.git</span></span><br><span class="line"> <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Now</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span>  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">   <span class="attr">repository:</span> <span class="string">git@github.com:Ling-Yuchen/Ling-Yuchen.github.io.git</span></span><br><span class="line">   <span class="attr">branch:</span> <span class="string">master</span> </span><br><span class="line"><span class="bullet">-</span>  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">   <span class="attr">repository:</span> <span class="string">root@&lt;ip-address&gt;:/opt/hexo/blog.git</span></span><br><span class="line">   <span class="attr">branch:</span> <span class="string">master</span> </span><br></pre></td></tr></table></figure><ul><li>打开 Git Bash 终端，执行以下命令尝试部署：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo g -d</span></span><br></pre></td></tr></table></figure><p><strong>补充：什么是 Git-hooks ？</strong></p><p><code>git hooks</code> 是 Git 提供的一个特性，允许脚本在某些 Git 操作的关键点被自动执行。这些钩子都被存储在 Git 仓库的 <code>.git/hooks</code> 目录下。当你用 <code>git init</code> 初始化一个新的仓库时，Git 会默认为这个仓库设置一些示例钩子。</p><p>每个钩子都是一个脚本，可以是 Bash 脚本、Python 脚本、Ruby 脚本等。默认情况下，示例钩子都是不会执行的，除非你修改它们并去掉<code>.sample</code>的后缀。</p><p>以下是一些常见的 <code>git hooks</code> 以及它们的使用场景：</p><ol><li><strong>pre-commit</strong>：在提交之前运行。它用于检查即将提交的快照，例如，检查代码风格、运行单元测试、检查lint错误等。如果这个脚本退出时返回非零值，Git 将放弃此次提交。</li><li><strong>prepare-commit-msg</strong>：在提交消息编辑器打开前运行。可以用于格式化提交消息，或者根据提交的内容和提交者等因素设置默认的提交消息。</li><li><strong>commit-msg</strong>：在提交时检查提交消息。可以用来确保提交信息遵循特定的模板。</li><li><strong>post-commit</strong>：在提交完成后运行。通常用于通知或其它不影响提交本身的操作。</li><li><strong>pre-push</strong>：在 <code>git push</code> 命令上传到远程之前。可以用来运行测试，确保不会把有问题的代码推送到主分支。</li><li><strong>post-receive</strong>：在远程仓库中，当推送完成后执行。通常用于部署任务或向其他服务发出通知。</li></ol><p>这只是钩子的一部分，Git 提供了很多其他类型的钩子。</p><p>总之，git hooks 提供了一种强大的机制，使开发者可以在各种Git操作过程中自动运行脚本，从而帮助团队遵循代码质量标准、运行自动化任务、增强开发流程等。</p><blockquote><p>回答来自 GPT-4</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Linux </tag>
            
            <tag> 博客部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM 与 KG 的结合案例 Demo</title>
      <link href="/2023/09/20/NebulaGraph-LLM&amp;KG/"/>
      <url>/2023/09/20/NebulaGraph-LLM&amp;KG/</url>
      
        <content type="html"><![CDATA[<h1 id="关于-NebulaGraph"><a href="#关于-NebulaGraph" class="headerlink" title="关于 NebulaGraph"></a>关于 NebulaGraph</h1><p>一个可靠的分布式、线性扩容、 性能高效的图数据库，擅长处理千亿节点万亿条边的超大数据集，同时保持毫秒级查询延时的图数据库解决方案</p><h2 id="部署-NebulaGraph-集群"><a href="#部署-NebulaGraph-集群" class="headerlink" title="部署 NebulaGraph 集群"></a>部署 NebulaGraph 集群</h2><h3 id="使用-Docker-Compose-部署-NebulaGraph-集群"><a href="#使用-Docker-Compose-部署-NebulaGraph-集群" class="headerlink" title="使用 Docker Compose 部署 NebulaGraph 集群"></a>使用 Docker Compose 部署 NebulaGraph 集群</h3><p>参考资料：<a href="https://docs.nebula-graph.com.cn/">https://docs.nebula-graph.com.cn/</a></p><blockquote><p>使用 Docker Compose 可以基于准备好的配置文件快速部署 NebulaGraph 服务，仅建议在测试NebulaGraph 功能时使用该方式</p></blockquote><p>主机 Linux 系统：Ubuntu 20.04.6</p><p><strong>安装 Docker</strong></p><blockquote><p>使用 Apt repository 进行安装</p><p>参考文档：<a href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository">https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository</a></p></blockquote><ol><li>创建 Docker 的 Apt repository.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add Docker<span class="string">&#x27;s official GPG key:</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">sudo apt-get update</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">sudo apt-get install ca-certificates curl gnupg</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">sudo install -m 0755 -d /etc/apt/keyrings</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">sudo chmod a+r /etc/apt/keyrings/docker.gpg</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Add the repository to Apt sources:</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">echo \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">sudo apt-get update</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装最新的 Docker packages</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span></span><br></pre></td></tr></table></figure><ol start="3"><li>验证 Docker Engine 是否安装成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker run hello-world</span></span><br></pre></td></tr></table></figure><p><strong>安装 Docker Compose</strong></p><blockquote><p>参考文档：<a href="https://docs.docker.com/compose/install/standalone/">https://docs.docker.com/compose/install/standalone/</a></p></blockquote><ol><li>下载并安装 Compose standalone</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -SL https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span></span><br></pre></td></tr></table></figure><ol start="2"><li>验证 Compose standalone 是否安装成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose</span></span><br></pre></td></tr></table></figure><p><strong>部署 NebulaGraph</strong></p><ol><li>通过 Git 克隆 <code>nebula-docker-compose</code> 仓库的分支到主机，并切换工作目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> -b release-3.6 https://github.com/vesoft-inc/nebula-docker-compose.git</span></span><br></pre></td></tr></table></figure><p>注：执行该命令时出现报错 <code>GnuTLS recv error (-54): Error in the pull function</code>，没有解决，尝试将 <code>release-3.6</code> 更换为 <code>release-3.5</code> 之后连接超时，没有解决，尝试将 <code>release-3.6</code> 更换为 <code>release-3.4</code> 之后成功克隆仓库（具体原因未知）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> nebula-docker-compose</span></span><br></pre></td></tr></table></figure><ol start="2"><li>启动 NebulaGraph 服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose up -d</span></span><br></pre></td></tr></table></figure><p><strong>连接 NebulaGraph</strong>（两种方式）</p><ol><li><p>在容器外通过 Nebula Console 连接</p><blockquote><p>因为容器配置文件中将 Graph 服务的外部映射端口也固定为 9669，因此可以直接通过默认端口连接</p></blockquote><ul><li><p>下载所需版本的 NebulaGraph Console 二进制文件</p><ul><li><a href="https://github.com/vesoft-inc/nebula-console/releases">https://github.com/vesoft-inc/nebula-console/releases</a></li></ul></li><li><p>可选：重命名文件为 <code>nebula-console</code>（方便使用）</p></li><li><p>授予 <code>nebula-console</code> 文件的执行权限： <code>sudo chmod 111 nebula-console</code></p></li><li><p>运行 <code>nebula-console</code>，连接 NebulaGraph</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./nebula-console -addr 127.0.0.1 -port 9669 -u root -p nebula</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>登录安装了 NebulaGraph Console 的容器，然后再连接 Graph 服务</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it nebuladockercompose_console_1 /bin/sh</span></span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ # ./usr/local/bin/nebula-console -u root -p nebula --address=graphd --port=9669</span><br></pre></td></tr></table></figure></li></ol><p><strong>查看 NebulaGraph 服务的状态和端口</strong></p><blockquote><p>NebulaGraph 默认使用 <code>9669</code> 端口为客户端提供服务，如果需要修改端口，需要修改目录 <code>nebula-docker-compose</code> 内的文件 <code>docker-compose.yaml</code>，然后重启 NebulaGraph 服务</p></blockquote> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose ps</span></span><br></pre></td></tr></table></figure><p><strong>关闭 NebulaGraph 服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker-compose down</span></span><br></pre></td></tr></table></figure><h1 id="关于-LLM-与-KG-的结合"><a href="#关于-LLM-与-KG-的结合" class="headerlink" title="关于 LLM 与 KG 的结合"></a>关于 LLM 与 KG 的结合</h1><h1 id="核心内容概述"><a href="#核心内容概述" class="headerlink" title="核心内容概述"></a>核心内容概述</h1><h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a><strong>要点总结</strong></h2><p>整个 Demo 对 LLM 与 KG 的结合作出了一定的探索并已经将具体实现整合到 langchain 与 llama_index 中，大致分为三个方向（其中，第一个方向主要涉及借助 LLM 构建 KG，后两个方向主要涉及借助 KG 增强 LLM）：</p><ul><li><strong>Construct</strong> <strong>KG</strong> <strong>via</strong> <strong>LLM</strong>：从已有的文档中按照确定的规则抽取知识（三元组）并存入图数据库中</li><li><strong>Text2Cypher</strong>：对于用户提出的问题，由 LLM 将自然语言的询问转换为对图数据库的 Cypher 查询，获取到查询结果后，再经由 LLM 整合并输出回答 (类似 <a href="https://hugegraph.feishu.cn/wiki/JqfPwpg61iCm4QklTp6cOpcDnEd">前端 Hubble 打通 LLM 方案梳理</a>)</li><li><strong>Graph</strong> <strong>RAG</strong>：对于用户提出的问题，由 LLM 提取问题中所涉及的 Entity，以此来从 KG 中获取与问题相关的 sub-KG 作为上下文，再由 LLM 对该上下文信息进行理解并输出回答（该方法分为两个使用场景：一是使用 llama_index 等框架/工具基于已有的文档构建 KG 并使用，二是基于已有的 KG 使用，案例中两者均给出了具体实现）<ul><li>对比 <strong>Vector RAG</strong>：与 Graph RAG 不同的地方在于，将文档（构建 KG 的原始文档）分为多个 chunk，通过向量搜索找到 K 个最语义相关的 chunk 作为 上下文信息</li><li>尝试 <strong>Graph</strong> <strong>+</strong> <strong>Vector</strong> <strong>RAG</strong>：结合 Graph RAG 与 Vector RAG （并与单独的 Vector RAG 和单独的 Graph RAG 对比效果）</li></ul></li></ul><h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a><strong>实验结论</strong></h2><p>原作者针对 Demo 进行了对比试验，实验结果指出：</p><ul><li>pure-KG-based 和 otherwise：<ul><li>Text2Cypher 和 Graph RAG 均能给出精确的答案，并且 Token 开销远小于 Vector RAG 和 Graph + Vector RAG<ul><li>关于此处 Token 开销，原作者仅在实验文档中对比了 Response 的 Token 数量而没有对比 Prompt 的 Token 数量</li><li>pure-KG-based 方法得到的回答更加简短精炼（作者想表达的意思应该是其信息密度较高 ）</li></ul></li><li>Graph + Vector RAG 在问题涉及的知识广泛分布在文档的<strong>不同段落</strong>时，能够给出更加综合和完整的回答 (意思是说 –&gt; 更适合复杂问题?)</li></ul></li><li>Text2Cypher 和 Graph RAG：<ul><li>Text2Cypher 仅结合查询结果作出回答，Graph RAG 结合所有相关上下文进行回答，因此，对于答案本身属于细节性、碎片性信息的，Text2Cypher 效果更好，反之 Graph RAG 效果更好</li><li>对于以下情形优先使用 Graph RAG：<ul><li>需要考虑潜在相关信息</li><li>KG 的 schema 相对复杂</li><li>KG 本身的数据质量不高</li><li>问题包含多个 Starting Entity</li></ul></li></ul></li></ul><h1 id="详细复现过程"><a href="#详细复现过程" class="headerlink" title="详细复现过程"></a>详细复现过程</h1><ol><li>添加环境变量</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;OPENAI_API_KEY&#x27;</span>] = <span class="string">&#x27;sk-xxxxxxxxxxx&#x27;</span> </span><br><span class="line">os.environ[<span class="string">&#x27;NEBULA_USER&#x27;</span>] = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">os.environ[<span class="string">&#x27;NEBULA_PASSWORD&#x27;</span>] = <span class="string">&#x27;nebula&#x27;</span></span><br><span class="line">os.environ[<span class="string">&#x27;NEBULA_ADDRESS&#x27;</span>] = <span class="string">&#x27;127.0.0.1:9669&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>图数据库的 space 创建与 schema 定义（in nebula-console）</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SPACE guardians(vid_type<span class="operator">=</span>FIXED_STRING(<span class="number">256</span>), partition_num<span class="operator">=</span><span class="number">1</span>, replica_factor<span class="operator">=</span><span class="number">1</span>);</span><br><span class="line">USE guardians;</span><br><span class="line"><span class="keyword">CREATE</span> TAG entity(name string);</span><br><span class="line"><span class="keyword">CREATE</span> EDGE relationship(relationship string);</span><br><span class="line"><span class="keyword">CREATE</span> TAG INDEX entity_index <span class="keyword">ON</span> entity(name(<span class="number">256</span>));</span><br></pre></td></tr></table></figure><ol><li>LLM 服务的构建与准备</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> LLMPredictor</span><br><span class="line"><span class="keyword">from</span> llama_index.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> ServiceContext</span><br><span class="line"></span><br><span class="line">llm = OpenAI(model=<span class="string">&#x27;text-davinci-002&#x27;</span>, temperature=<span class="number">0</span>)</span><br><span class="line">service_context = ServiceContext.from_defaults(llm=llm, chunk_size=<span class="number">512</span>)</span><br></pre></td></tr></table></figure><ol><li>图存储的构建与准备（基于 NebulaGraph）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.graph_stores <span class="keyword">import</span> NebulaGraphStore</span><br><span class="line"><span class="keyword">from</span> llama_index.storage.storage_context <span class="keyword">import</span> StorageContext</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;NEBULA_USER&#x27;</span>] = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">os.environ[<span class="string">&#x27;NEBULA_PASSWORD&#x27;</span>] = <span class="string">&#x27;nebula&#x27;</span></span><br><span class="line">os.environ[<span class="string">&#x27;NEBULA_ADDRESS&#x27;</span>] = <span class="string">&#x27;127.0.0.1:9669&#x27;</span></span><br><span class="line">space_name = <span class="string">&#x27;guardians&#x27;</span></span><br><span class="line">edge_types, rel_prop_names= [<span class="string">&#x27;relationship&#x27;</span>], [<span class="string">&#x27;relationship&#x27;</span>]</span><br><span class="line">tags = [<span class="string">&#x27;entity&#x27;</span>]</span><br><span class="line">graph_store = NebulaGraphStore(</span><br><span class="line">    space_name=space_name,</span><br><span class="line">    edge_types=edge_types,</span><br><span class="line">    rel_prop_names=rel_prop_names,</span><br><span class="line">    tags=tags,</span><br><span class="line">)</span><br><span class="line">storage_context = StorageContext.from_defaults(graph_store=graph_store)</span><br></pre></td></tr></table></figure><ol><li>样例文档数据的准备</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> download_loader</span><br><span class="line"></span><br><span class="line">WikipediaReader = download_loader(<span class="string">&#x27;WikipediaReader&#x27;</span>)</span><br><span class="line">loader = WikipediaReader()</span><br><span class="line">documents = loader.load_data(pages=[<span class="string">&#x27;Guardians of the Galaxy Vol. 3&#x27;</span>], auto_suggest=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ol><li>提取文档中的知识并存入图数据库（for Cypher Query &amp; Graph RAG）</li></ol><blockquote><p>Construct KG via LLM 的核心步骤</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> KnowledgeGraphIndex</span><br><span class="line"></span><br><span class="line">kg_index = KnowledgeGraphIndex.from_documents(</span><br><span class="line">    documents=documents,</span><br><span class="line">    storage_context=storage_context,</span><br><span class="line">    max_triplets_per_chunk=<span class="number">10</span>,</span><br><span class="line">    service_context=service_context,</span><br><span class="line">    space_name=space_name,</span><br><span class="line">    edge_types=edge_types,</span><br><span class="line">    rel_prop_names=rel_prop_names,</span><br><span class="line">    tags=tags,</span><br><span class="line">    include_embeddings=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>为文档生成向量索引（for Vector RAG）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> VectorStoreIndex</span><br><span class="line"></span><br><span class="line">vector_index = VectorStoreIndex.from_documents(</span><br><span class="line">    documents=documents,</span><br><span class="line">    service_context=service_context</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>将相关数据固定在磁盘并支持重复读取（可选）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> load_index_from_storage</span><br><span class="line"><span class="keyword">from</span> llama_index.storage.storage_context <span class="keyword">import</span> StorageContext</span><br><span class="line">  </span><br><span class="line">kg_index.storage_context.persist(persist_dir=<span class="string">&#x27;./storage_graph&#x27;</span>)</span><br><span class="line">vector_index.storage_context.persist(persist_dir=<span class="string">&#x27;./storage_vector&#x27;</span>)</span><br><span class="line"></span><br><span class="line">storage_context = StorageContext.from_defaults(</span><br><span class="line">    persist_dir=<span class="string">&#x27;./storage_graph&#x27;</span>,</span><br><span class="line">    graph_store=graph_store,</span><br><span class="line">)</span><br><span class="line">kg_index = load_index_from_storage(</span><br><span class="line">    storage_context=storage_context,</span><br><span class="line">    service_context=service_context,</span><br><span class="line">    max_triplets_per_chunk=<span class="number">10</span>,</span><br><span class="line">    space_name=space_name,</span><br><span class="line">    edge_types=edge_types,</span><br><span class="line">    rel_prop_names=rel_prop_names,</span><br><span class="line">    tags=tags,</span><br><span class="line">    include_embeddings=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line">storage_context_vector = StorageContext.from_defaults(persist_dir=<span class="string">&#x27;./storage_vector&#x27;</span>)</span><br><span class="line">vector_index = load_index_from_storage(</span><br><span class="line">    service_context=service_context,</span><br><span class="line">    storage_context=storage_context_vector,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>Text2Cypher 的构建</li></ol><blockquote><p>Text2Cypher 的核心步骤</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.query_engine <span class="keyword">import</span> KnowledgeGraphQueryEngine</span><br><span class="line"><span class="keyword">from</span> llama_index.storage.storage_context <span class="keyword">import</span> StorageContext</span><br><span class="line"><span class="keyword">from</span> llama_index.graph_stores <span class="keyword">import</span> NebulaGraphStore</span><br><span class="line"></span><br><span class="line">nl2kg_query_engine = KnowledgeGraphQueryEngine(</span><br><span class="line">    storage_context=storage_context,</span><br><span class="line">    service_context=service_context,</span><br><span class="line">    llm=llm,</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>Graph RAG 的构建</li></ol><blockquote><p>Graph RAG 的核心步骤</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kg_rag_query_engine = kg_index.as_query_engine(</span><br><span class="line">    include_text=<span class="literal">False</span>,</span><br><span class="line">    retriever_mode=<span class="string">&#x27;keyword&#x27;</span>,</span><br><span class="line">    response_mode=<span class="string">&#x27;tree_summarize&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line"><span class="keyword">from</span> llama_index.query_engine <span class="keyword">import</span> RetrieverQueryEngine</span><br><span class="line"><span class="keyword">from</span> llama_index.retrievers <span class="keyword">import</span> KnowledgeGraphRAGRetriever</span><br><span class="line"></span><br><span class="line">graph_rag_retriever = KnowledgeGraphRAGRetriever(</span><br><span class="line">    storage_context=storage_context,</span><br><span class="line">    service_context=service_context,</span><br><span class="line">    llm=llm,</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">kg_rag_query_engine = RetrieverQueryEngine.from_args(</span><br><span class="line">    retriever=graph_rag_retriever,</span><br><span class="line">    service_context=service_context,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>Vector RAG 的构建</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector_rag_query_engine = vector_index.as_query_engine()</span><br></pre></td></tr></table></figure><ol><li>Graph + Vector RAG 的构建</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> QueryBundle</span><br><span class="line"><span class="keyword">from</span> llama_index.schema <span class="keyword">import</span> NodeWithScore</span><br><span class="line"><span class="keyword">from</span> llama_index.retrievers <span class="keyword">import</span> BaseRetriever, VectorIndexRetriever, KGTableRetriever</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomRetriever</span>(<span class="title class_ inherited__">BaseRetriever</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Custom retriever that performs both Vector search and Knowledge Graph search&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        vector_retriever: VectorIndexRetriever,</span></span><br><span class="line"><span class="params">        kg_retriever: KGTableRetriever,</span></span><br><span class="line"><span class="params">        mode: <span class="built_in">str</span> = <span class="string">&quot;OR&quot;</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Init params.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self._vector_retriever = vector_retriever</span><br><span class="line">        self._kg_retriever = kg_retriever</span><br><span class="line">        <span class="keyword">if</span> mode <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&quot;AND&quot;</span>, <span class="string">&quot;OR&quot;</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid mode.&quot;</span>)</span><br><span class="line">        self._mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_retrieve</span>(<span class="params">self, query_bundle: QueryBundle</span>) -&gt; <span class="type">List</span>[NodeWithScore]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Retrieve nodes given query.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        vector_nodes = self._vector_retriever.retrieve(query_bundle)</span><br><span class="line">        kg_nodes = self._kg_retriever.retrieve(query_bundle)</span><br><span class="line"></span><br><span class="line">        vector_ids = &#123;n.node.node_id <span class="keyword">for</span> n <span class="keyword">in</span> vector_nodes&#125;</span><br><span class="line">        kg_ids = &#123;n.node.node_id <span class="keyword">for</span> n <span class="keyword">in</span> kg_nodes&#125;</span><br><span class="line"></span><br><span class="line">        combined_dict = &#123;n.node.node_id: n <span class="keyword">for</span> n <span class="keyword">in</span> vector_nodes&#125;</span><br><span class="line">        combined_dict.update(&#123;n.node.node_id: n <span class="keyword">for</span> n <span class="keyword">in</span> kg_nodes&#125;)</span><br><span class="line"></span><br><span class="line">        retrieve_ids = vector_ids.intersection(kg_ids) <span class="keyword">if</span> self._mode == <span class="string">&quot;AND&quot;</span> <span class="keyword">else</span> vector_ids.union(kg_ids)</span><br><span class="line"></span><br><span class="line">        retrieve_nodes = [combined_dict[rid] <span class="keyword">for</span> rid <span class="keyword">in</span> retrieve_ids]</span><br><span class="line">        <span class="keyword">return</span> retrieve_nodes</span><br><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> get_response_synthesizer</span><br><span class="line"><span class="keyword">from</span> llama_index.query_engine <span class="keyword">import</span> RetrieverQueryEngine</span><br><span class="line"></span><br><span class="line"><span class="comment"># create custom retriever</span></span><br><span class="line">vector_retriever = VectorIndexRetriever(index=vector_index)</span><br><span class="line">kg_retriever = KGTableRetriever(</span><br><span class="line">    index=kg_index,</span><br><span class="line">    retriever_mode=<span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">    include_text=<span class="literal">False</span>,</span><br><span class="line">)</span><br><span class="line">custom_retriever = CustomRetriever(vector_retriever, kg_retriever)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create response synthesizer</span></span><br><span class="line">response_synthesizer = get_response_synthesizer(</span><br><span class="line">    service_context=service_context,</span><br><span class="line">    response_mode=<span class="string">&quot;tree_summarize&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">graph_vector_rag_query_engine = RetrieverQueryEngine(</span><br><span class="line">    retriever=custom_retriever,</span><br><span class="line">    response_synthesizer=response_synthesizer,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>提问并获取回答</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">seperator = <span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;#&#x27;</span>*<span class="number">50</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">response_nl2kg = nl2kg_query_engine.query(<span class="string">&quot;Tell me about Peter Quill.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response_nl2kg, end=seperator)</span><br><span class="line"></span><br><span class="line">graph_query = nl2kg_query_engine.generate_query(<span class="string">&quot;Tell me about Peter Quill?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(graph_query.replace(<span class="string">&quot;WHERE&quot;</span>, <span class="string">&quot;\n  WHERE&quot;</span>).replace(<span class="string">&quot;RETURN&quot;</span>, <span class="string">&quot;\nRETURN&quot;</span>), end=seperator)</span><br><span class="line"></span><br><span class="line">response_graph_rag = kg_rag_query_engine.query(<span class="string">&quot;Tell me about Peter Quill.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response_graph_rag, end=seperator)</span><br><span class="line"></span><br><span class="line">response_vector_rag = vector_rag_query_engine.query(<span class="string">&quot;Tell me about Peter Quill.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response_vector_rag, end=seperator)</span><br><span class="line"></span><br><span class="line">response_graph_vector_rag = graph_vector_rag_query_engine.query(<span class="string">&quot;Tell me about Peter Quill.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response_graph_vector_rag, end=seperator)</span><br></pre></td></tr></table></figure><p><strong>经代码整合后的完整案例复现代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> KnowledgeGraphIndex, VectorStoreIndex</span><br><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> QueryBundle</span><br><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> ServiceContext</span><br><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> download_loader</span><br><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> get_response_synthesizer</span><br><span class="line"><span class="keyword">from</span> llama_index <span class="keyword">import</span> load_index_from_storage</span><br><span class="line"><span class="keyword">from</span> llama_index.graph_stores <span class="keyword">import</span> NebulaGraphStore</span><br><span class="line"><span class="keyword">from</span> llama_index.indices.knowledge_graph.retrievers <span class="keyword">import</span> KGRetrieverMode</span><br><span class="line"><span class="keyword">from</span> llama_index.indices.query.base <span class="keyword">import</span> BaseQueryEngine</span><br><span class="line"><span class="keyword">from</span> llama_index.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> llama_index.llms.base <span class="keyword">import</span> LLM</span><br><span class="line"><span class="keyword">from</span> llama_index.response_synthesizers <span class="keyword">import</span> ResponseMode</span><br><span class="line"><span class="keyword">from</span> llama_index.retrievers <span class="keyword">import</span> BaseRetriever, VectorIndexRetriever, KGTableRetriever</span><br><span class="line"><span class="keyword">from</span> llama_index.schema <span class="keyword">import</span> NodeWithScore</span><br><span class="line"><span class="keyword">from</span> llama_index.storage.storage_context <span class="keyword">import</span> StorageContext</span><br><span class="line"><span class="keyword">from</span> llama_index.query_engine <span class="keyword">import</span> RetrieverQueryEngine, KnowledgeGraphQueryEngine</span><br><span class="line"><span class="keyword">from</span> llama_index.retrievers <span class="keyword">import</span> KnowledgeGraphRAGRetriever</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomRetriever</span>(<span class="title class_ inherited__">BaseRetriever</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Custom retriever that performs both Vector search and Knowledge Graph search&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        vector_retriever: VectorIndexRetriever,</span></span><br><span class="line"><span class="params">        kg_retriever: KGTableRetriever,</span></span><br><span class="line"><span class="params">        mode: <span class="built_in">str</span> = <span class="string">&quot;OR&quot;</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Init params.&quot;&quot;&quot;</span></span><br><span class="line">        self._vector_retriever = vector_retriever</span><br><span class="line">        self._kg_retriever = kg_retriever</span><br><span class="line">        <span class="keyword">if</span> mode <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&quot;AND&quot;</span>, <span class="string">&quot;OR&quot;</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid mode.&quot;</span>)</span><br><span class="line">        self._mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_retrieve</span>(<span class="params">self, query_bundle: QueryBundle</span>) -&gt; <span class="type">List</span>[NodeWithScore]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Retrieve nodes given query.&quot;&quot;&quot;</span></span><br><span class="line">        vector_nodes = self._vector_retriever.retrieve(query_bundle)</span><br><span class="line">        kg_nodes = self._kg_retriever.retrieve(query_bundle)</span><br><span class="line">        vector_ids = &#123;n.node.node_id <span class="keyword">for</span> n <span class="keyword">in</span> vector_nodes&#125;</span><br><span class="line">        kg_ids = &#123;n.node.node_id <span class="keyword">for</span> n <span class="keyword">in</span> kg_nodes&#125;</span><br><span class="line">        combined_dict = &#123;n.node.node_id: n <span class="keyword">for</span> n <span class="keyword">in</span> vector_nodes&#125;</span><br><span class="line">        combined_dict.update(&#123;n.node.node_id: n <span class="keyword">for</span> n <span class="keyword">in</span> kg_nodes&#125;)</span><br><span class="line">        retrieve_ids = vector_ids.intersection(kg_ids) <span class="keyword">if</span> self._mode == <span class="string">&quot;AND&quot;</span> <span class="keyword">else</span> vector_ids.union(kg_ids)</span><br><span class="line">        retrieve_nodes = [combined_dict[rid] <span class="keyword">for</span> rid <span class="keyword">in</span> retrieve_ids]</span><br><span class="line">        <span class="keyword">return</span> retrieve_nodes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_llm</span>() -&gt; LLM:</span><br><span class="line">    <span class="keyword">return</span> OpenAI(model=<span class="string">&#x27;text-davinci-002&#x27;</span>, temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_service_context</span>(<span class="params">llm: LLM</span>) -&gt; ServiceContext:</span><br><span class="line">    service_context = ServiceContext.from_defaults(llm=llm, chunk_size=<span class="number">512</span>)</span><br><span class="line">    <span class="keyword">return</span> service_context</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_storage_context</span>(<span class="params">mode: <span class="built_in">str</span> = <span class="string">&#x27;reload&#x27;</span></span>) -&gt; (<span class="built_in">tuple</span>, StorageContext):</span><br><span class="line">    space_name = <span class="string">&#x27;guardians&#x27;</span></span><br><span class="line">    edge_types, rel_prop_names = [<span class="string">&#x27;relationship&#x27;</span>], [<span class="string">&#x27;relationship&#x27;</span>]</span><br><span class="line">    tags = [<span class="string">&#x27;entity&#x27;</span>]</span><br><span class="line">    graph_store = NebulaGraphStore(</span><br><span class="line">        space_name=space_name,</span><br><span class="line">        edge_types=edge_types,</span><br><span class="line">        rel_prop_names=rel_prop_names,</span><br><span class="line">        tags=tags,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;reload&#x27;</span>:</span><br><span class="line">        storage_context = StorageContext.from_defaults(</span><br><span class="line">            persist_dir=<span class="string">&#x27;./storage_graph&#x27;</span>,</span><br><span class="line">            graph_store=graph_store,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        storage_context = StorageContext.from_defaults(graph_store=graph_store)</span><br><span class="line">    <span class="keyword">return</span> (space_name, edge_types, rel_prop_names, tags), storage_context</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_data</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    llm = prepare_llm()</span><br><span class="line">    service_context = prepare_service_context(llm)</span><br><span class="line">    kg_settings, storage_context = prepare_storage_context(mode=<span class="string">&#x27;prepare&#x27;</span>)</span><br><span class="line">    space_name, edge_types, rel_prop_names, tags = kg_settings</span><br><span class="line">    WikipediaReader = download_loader(<span class="string">&#x27;WikipediaReader&#x27;</span>)</span><br><span class="line">    loader = WikipediaReader()</span><br><span class="line">    documents = loader.load_data(</span><br><span class="line">        pages=[<span class="string">&#x27;Guardians of the Galaxy Vol. 3&#x27;</span>],</span><br><span class="line">        auto_suggest=<span class="literal">False</span>,</span><br><span class="line">    )</span><br><span class="line">    kg_index = KnowledgeGraphIndex.from_documents(</span><br><span class="line">        documents=documents,</span><br><span class="line">        storage_context=storage_context,</span><br><span class="line">        max_triplets_per_chunk=<span class="number">10</span>,</span><br><span class="line">        service_context=service_context,</span><br><span class="line">        space_name=space_name,</span><br><span class="line">        edge_types=edge_types,</span><br><span class="line">        rel_prop_names=rel_prop_names,</span><br><span class="line">        tags=tags,</span><br><span class="line">        include_embeddings=<span class="literal">True</span>,</span><br><span class="line">    )</span><br><span class="line">    kg_index.storage_context.persist(persist_dir=<span class="string">&#x27;./storage_graph&#x27;</span>)</span><br><span class="line">    vector_index = VectorStoreIndex.from_documents(</span><br><span class="line">        documents=documents,</span><br><span class="line">        service_context=service_context</span><br><span class="line">    )</span><br><span class="line">    vector_index.storage_context.persist(persist_dir=<span class="string">&#x27;./storage_vector&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_query_engin</span>(<span class="params">method: <span class="built_in">str</span>, llm: LLM</span>) -&gt; <span class="type">Optional</span>[BaseQueryEngine]:</span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&#x27;graph-rag-prebuilt&#x27;</span>:</span><br><span class="line">        service_context = prepare_service_context(llm=llm)</span><br><span class="line">        kg_settings, storage_context = prepare_storage_context()</span><br><span class="line">        space_name, edge_types, rel_prop_names, tags = kg_settings</span><br><span class="line">        kg_index = load_index_from_storage(</span><br><span class="line">            storage_context=storage_context,</span><br><span class="line">            service_context=service_context,</span><br><span class="line">            max_triplets_per_chunk=<span class="number">10</span>,</span><br><span class="line">            space_name=space_name,</span><br><span class="line">            edge_types=edge_types,</span><br><span class="line">            rel_prop_names=rel_prop_names,</span><br><span class="line">            tags=tags,</span><br><span class="line">            include_embeddings=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">        query_engine = kg_index.as_query_engine(</span><br><span class="line">            include_text=<span class="literal">False</span>,</span><br><span class="line">            retriever_mode=<span class="string">&#x27;keyword&#x27;</span>,</span><br><span class="line">            response_mode=<span class="string">&#x27;tree_summarize&#x27;</span>,</span><br><span class="line">            verbose=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&#x27;graph-rag-existing&#x27;</span>:</span><br><span class="line">        service_context = prepare_service_context(llm=llm)</span><br><span class="line">        _, storage_context = prepare_storage_context(mode=<span class="string">&#x27;no-index&#x27;</span>)</span><br><span class="line">        graph_rag_retriever = KnowledgeGraphRAGRetriever(</span><br><span class="line">            storage_context=storage_context,</span><br><span class="line">            service_context=service_context,</span><br><span class="line">            llm=llm,</span><br><span class="line">            verbose=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">        query_engine = RetrieverQueryEngine.from_args(</span><br><span class="line">            retriever=graph_rag_retriever,</span><br><span class="line">            service_context=service_context,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&#x27;vector-rag&#x27;</span>:</span><br><span class="line">        service_context = prepare_service_context(llm=llm)</span><br><span class="line">        storage_context_vector = StorageContext.from_defaults(persist_dir=<span class="string">&#x27;./storage_vector&#x27;</span>)</span><br><span class="line">        vector_index = load_index_from_storage(</span><br><span class="line">            service_context=service_context,</span><br><span class="line">            storage_context=storage_context_vector</span><br><span class="line">        )</span><br><span class="line">        query_engine = vector_index.as_query_engine()</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&#x27;text-to-cypher&#x27;</span>:</span><br><span class="line">        service_context = prepare_service_context(llm=llm)</span><br><span class="line">        _, storage_context = prepare_storage_context()</span><br><span class="line">        query_engine = KnowledgeGraphQueryEngine(</span><br><span class="line">            storage_context=storage_context,</span><br><span class="line">            service_context=service_context,</span><br><span class="line">            llm=llm,</span><br><span class="line">            verbose=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&#x27;graph-vector-rag&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;vector-graph-rag&#x27;</span>:</span><br><span class="line">        service_context = prepare_service_context(llm=llm)</span><br><span class="line">        storage_context_vector = StorageContext.from_defaults(persist_dir=<span class="string">&#x27;./storage_vector&#x27;</span>)</span><br><span class="line">        vector_index = load_index_from_storage(</span><br><span class="line">            service_context=service_context,</span><br><span class="line">            storage_context=storage_context_vector</span><br><span class="line">        )</span><br><span class="line">        kg_settings, storage_context = prepare_storage_context()</span><br><span class="line">        space_name, edge_types, rel_prop_names, tags = kg_settings</span><br><span class="line">        kg_index = load_index_from_storage(</span><br><span class="line">            storage_context=storage_context,</span><br><span class="line">            service_context=service_context,</span><br><span class="line">            max_triplets_per_chunk=<span class="number">10</span>,</span><br><span class="line">            space_name=space_name,</span><br><span class="line">            edge_types=edge_types,</span><br><span class="line">            rel_prop_names=rel_prop_names,</span><br><span class="line">            tags=tags,</span><br><span class="line">            include_embeddings=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># create custom retriever</span></span><br><span class="line">        vector_retriever = VectorIndexRetriever(index=vector_index)</span><br><span class="line">        kg_retriever = KGTableRetriever(</span><br><span class="line">            index=kg_index,</span><br><span class="line">            retriever_mode=KGRetrieverMode.KEYWORD,</span><br><span class="line">            include_text=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">        custom_retriever = CustomRetriever(vector_retriever, kg_retriever)</span><br><span class="line">        <span class="comment"># create response synthesizer</span></span><br><span class="line">        response_synthesizer = get_response_synthesizer(</span><br><span class="line">            service_context=service_context,</span><br><span class="line">            response_mode=ResponseMode.TREE_SUMMARIZE,</span><br><span class="line">        )</span><br><span class="line">        query_engine = RetrieverQueryEngine(</span><br><span class="line">            retriever=custom_retriever,</span><br><span class="line">            response_synthesizer=response_synthesizer</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Invalid method!&#x27;</span>)</span><br><span class="line">        query_engine = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> query_engine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_response</span>(<span class="params">response: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    result = response.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> result:</span><br><span class="line">        sentence = <span class="string">f&#x27;<span class="subst">&#123;line.strip()&#125;</span>.&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sentence.strip()) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(sentence)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># prepare_data()</span></span><br><span class="line">    llm = prepare_llm()</span><br><span class="line">    <span class="comment"># query_engin = get_query_engin(method=&#x27;vector-rag&#x27;, llm=llm)</span></span><br><span class="line">    <span class="comment"># query_engin = get_query_engin(method=&#x27;text-to-cypher&#x27;, llm=llm)</span></span><br><span class="line">    <span class="comment"># query_engin = get_query_engin(method=&#x27;graph-rag-prebuilt&#x27;, llm=llm)</span></span><br><span class="line">    <span class="comment"># query_engin = get_query_engin(method=&#x27;graph-rag-existing&#x27;, llm=llm)</span></span><br><span class="line">    query_engin = get_query_engin(method=<span class="string">&#x27;graph-vector-rag&#x27;</span>, llm=llm)</span><br><span class="line">    <span class="keyword">if</span> query_engin <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response = query_engin.query(<span class="string">&#x27;Tell me about Peter Quill.&#x27;</span>)</span><br><span class="line">        print_response(response.response)</span><br></pre></td></tr></table></figure><h1 id="源码实现细节"><a href="#源码实现细节" class="headerlink" title="源码实现细节"></a>源码实现细节</h1><h2 id="Text2Cypher-过程解析"><a href="#Text2Cypher-过程解析" class="headerlink" title="Text2Cypher 过程解析"></a>Text2Cypher 过程解析</h2><ul><li><code>service_context</code> 对象提供 LLM 服务的上下文（可用其他 LLM 替换 OpenAI 提供的服务）</li><li><code>storage_context</code> 对象提供图数据库存储的上下文<ul><li>由 <code>NebulaGraphStore</code> 类实现（<code>./llama_index/graph_stores/nebulagraph.py</code>）</li><li> 继承自 <code>GraphStore</code> 类（<code>./llama_index/graph_stores/types.py</code> ）</li></ul></li><li><code>query_engine</code> 对象提供向图数据库进行查询的接口<ul><li>由 <code>KnowledgeGraphQueryEngine</code> 类实现（<code>./llama_index/query_engine/knowledge_graph_query_engine.py</code> ）</li><li>使用 <code>service_context</code> 对象与 <code>storage_context</code> 对象作为参数实例化<code>KnowledgeGraphQueryEngine</code> 类</li><li>在与 LLM 交互时使用了为 NebulaGraph 定制的提示模板（<code>./llama_index/query_engine/knowledge_graph_query_engine.py</code> ）</li></ul></li><li><code>query_engine</code> 对象的 <code>query</code> 方法完成了提示词构建以及与 LLM 和 KG 的交互<ul><li>自然语言转换为查询语句 &amp; 通过查询语句从图数据库中得到查询结果（<strong>Retrieve</strong>）</li><li>查询结果转换为自然语言回答（<strong>Response Synthesize</strong>）</li></ul></li></ul><p><strong>Text2Cypher Prompt 解析</strong></p><p>任务阐述：根据自然语言询问生成图数据库查询语句</p><p>辅助信息：图数据库相关 schema；自然语言询问语句</p><p>约束限制：只能用提供 schema 中涉及的关系类型和属性</p><p>特殊提示：NebulaGraph 的 Cypher 方言规范（语言描述 + 举例说明）</p><ul><li>对比 Neo4j 图数据库的定制化提示模板，特殊提示中还可以添加：<ul><li>回答中不要包含解释或道歉</li><li>不要回答任何可能要求构建 Cypher 语句以外的问题</li><li>回答中不要包含除了生成的 Cypher 语句以外的内容</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./llama_index/query_engine/knowledge_graph_query_engine.py</span></span><br><span class="line"></span><br><span class="line">DEFAULT_NEBULAGRAPH_NL2CYPHER_PROMPT_TMPL = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Generate NebulaGraph query from natural language.</span></span><br><span class="line"><span class="string">Use only the provided relationship types and properties in the schema.</span></span><br><span class="line"><span class="string">Do not use any other relationship types or properties that are not provided.</span></span><br><span class="line"><span class="string">Schema:</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">&#123;schema&#125;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">Note: NebulaGraph speaks a dialect of Cypher, comparing to standard Cypher:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">it uses double equals sign for comparison: == rather than =</span></span><br><span class="line"><span class="string">it needs explicit label specification when referring to node properties, i.e.</span></span><br><span class="line"><span class="string">v is a variable of a node, and we know its label is Foo, v.foo.name is correct</span></span><br><span class="line"><span class="string">while v.name is not.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For example, see this diff between standard and NebulaGraph Cypher dialect:</span></span><br><span class="line"><span class="string">```diff</span></span><br><span class="line"><span class="string">&lt; MATCH (p:person)-[:directed]-&gt;(m:movie) WHERE m.name = &#x27;The Godfather&#x27;</span></span><br><span class="line"><span class="string">&lt; RETURN p.name;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">&gt; MATCH (p:`person`)-[:directed]-&gt;(m:`movie`) WHERE m.`movie`.`name` == &#x27;The Godfather&#x27;</span></span><br><span class="line"><span class="string">&gt; RETURN p.`person`.`name`;</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question: &#123;query_str&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NebulaGraph Cypher dialect query:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">DEFAULT_NEBULAGRAPH_NL2CYPHER_PROMPT = PromptTemplate(</span><br><span class="line">    DEFAULT_NEBULAGRAPH_NL2CYPHER_PROMPT_TMPL,</span><br><span class="line">    prompt_type=PromptType.TEXT_TO_GRAPH_QUERY,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Graph-RAG-过程解析"><a href="#Graph-RAG-过程解析" class="headerlink" title="Graph RAG 过程解析"></a>Graph RAG 过程解析</h2><h3 id="Graph-RAG-for-LlamaIndex-Built-KG"><a href="#Graph-RAG-for-LlamaIndex-Built-KG" class="headerlink" title="Graph RAG for LlamaIndex Built KG"></a>Graph RAG for LlamaIndex Built KG</h3><p>对于基于已有的文档使用 LlamaIndex 构建的 KG，已经在构建时保存了相关索引，由 <code>KnowledgeGraphIndex</code> 类封装（<code>./llama_index/indices/knowledge_graph/base.py</code>），继承自 <code>BaseIndex</code> 类（<code>./llama_index/indices/base.py</code>）</p><ul><li>调用索引对象的 as_query_engine() 获得一个 <code>RetrieverQueryEngine</code> 类对象（<code>./llama_index/query_engine/retriever_query_engine.py</code>），继承自 BaseQueryEngine 类（<code>./llama_index/indices/query/base.py</code>）<ul><li>核心仍是由 <strong>Retriever</strong> 和 <strong>Response Synthesizer</strong> 构成</li><li>Retriever 由 KGTableRetriever 类对象承担（<code>./llama_index/indices/knowledge_graph/retrievers.py</code>），继承自 <code>BaseRetriever</code> 类（<code>./llama_index/indices/base_retriever.py</code>）</li><li>Response Synthesizer 的具体类型由 response_mode 参数决定，如本案例中使用了 TreeSummarize（<code>./llama_index/response_synthesizers/tree_summarize.py</code>），继承自 BaseSynthesizer（<code>./llama_index/response_synthesizers/base.py</code>）</li></ul></li><li>检索过程：（详见 <code>./llama_index/indices/knowledge_graph/retrievers.py</code> 中 <code>KGTableRetriever</code> 类的 <code>_retrieve</code> 方法）<ul><li>根据问题归纳相关关键词（由 LLM 完成）</li><li>根据关键词找到对应的实体</li><li>根据相关实体以固定深度提取 SubGraph</li><li>将 SubGraph 转换为上下文信息（字符串化等处理）</li></ul></li><li>回答整合过程：（详见 <code>./llama_index/response_synthesizers/tree_summarize.py</code> 中 <code>TreeSummarize</code> 类的 <code>get_response</code> 方法）</li></ul><h3 id="Graph-RAG-for-Existing-KG"><a href="#Graph-RAG-for-Existing-KG" class="headerlink" title="Graph RAG for Existing KG"></a>Graph RAG for Existing KG</h3><p>与 Graph RAG for LlamaIndex Built KG 流程基本相同，不同之处在于：</p><ul><li>前者 query_engine（包括其中的 retriever）直接通过索引构建，并且其 retriever 是一个 KGTableRetriever 对象</li><li>后者需要手动构建 retriever 和 query_engine，其中 retriever 是一个 KnowledgeGraphRAGRetriever 对象</li><li>两者 retriever 的实现方式不同，详见<code>./llama_index/indices/knowledge_graph/retrievers.py</code></li></ul><p>注：搜索相关实体的方式可以是基于关键字的提取，也可以是基于嵌入的提取，这由 <code>KnowledgeGraphRAGRetriever</code> 的参数 <code>retriever_mode</code> 控制，支持的选项有</p><ul><li>keyword</li><li>embedding（尚未实现）</li><li>keyword_embedding（尚未实现）</li></ul><h1 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h1><ul><li><a href="https://www.siwei.io/graph-enabled-llama-index/">https://www.siwei.io/graph-enabled-llama-index/</a></li><li><a href="https://www.siwei.io/llm-text-to-nebulagraph-query/">https://www.siwei.io/llm-text-to-nebulagraph-query/</a></li><li><a href="https://www.siwei.io/graph-rag/">https://www.siwei.io/graph-rag/</a></li><li><a href="https://www.siwei.io/demos/graph-rag/">https://www.siwei.io/demos/graph-rag/</a></li><li><a href="https://gpt-index.readthedocs.io/en/stable/examples/query_engine/knowledge_graph_rag_query_engine.html">https://gpt-index.readthedocs.io/en/stable/examples/query_engine/knowledge_graph_rag_query_engine.html</a></li><li><a href="https://www.siwei.io/demo-dumps/local-llm/Graph_RAG_Local.html">https://www.siwei.io/demo-dumps/local-llm/Graph_RAG_Local.html</a> （本地 LLM 构建案例）</li><li><a href="https://github.com/jerryjliu/llama_index/tree/main/docs/examples/index_structs/knowledge_graph">https://github.com/jerryjliu/llama_index/tree/main/docs/examples/index_structs/knowledge_graph</a> （LlamaIndex KG）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> Docker </tag>
            
            <tag> 知识图谱 </tag>
            
            <tag> 图数据库 </tag>
            
            <tag> NebulaGraph </tag>
            
            <tag> RAG </tag>
            
            <tag> Docker-Compose </tag>
            
            <tag> LlamaIndex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LangChain 学习笔记</title>
      <link href="/2023/08/02/LangChain-Learning-Notes/"/>
      <url>/2023/08/02/LangChain-Learning-Notes/</url>
      
        <content type="html"><![CDATA[<p>主要参考资料：</p><ul><li><p><a href="https://cookbook.langchain.com.cn/docs/">https://cookbook.langchain.com.cn/docs/</a></p></li><li><p><a href="https://python.langchain.com.cn/docs/">https://python.langchain.com.cn/docs/</a></p></li></ul><p>实际用例介绍：<a href="https://python.langchain.com.cn/docs/use_cases">https://python.langchain.com.cn/docs/use_cases</a></p><p>相关视频教程检索：<a href="https://python.langchain.com.cn/docs/additional_resources/youtube">https://python.langchain.com.cn/docs/additional_resources/youtube</a></p><p>LangChain API 文档：<a href="https://api.python.langchain.com/en/latest/api_reference.html">https://api.python.langchain.com/en/latest/api_reference.html</a></p><h1 id="什么是-LangChain？"><a href="#什么是-LangChain？" class="headerlink" title="什么是 LangChain？"></a>什么是 LangChain？</h1><p>LangChain 是一个用于开发由语言模型驱动的应用程序的框架。</p><p>LangChain 提供了一些组件和接口，集成了多元的生态，包括各类向量数据库服务、源数据集、LLM 应用开发相关工具等，可以让开发者方便地使用语言模型来实现各种功能，例如文档分析和摘要、聊天机器人、代码分析等。</p><p>使用 LangChain 可以在 LLM 应用开发中：灵活构建和管理提示词模板；便捷地处理多轮对话的上下文记忆问题；使用外部知识库增强 LLM；构造代理和自定义工具，为复杂的 LLM 应用调用链服务。</p><h2 id="从主要模块的视角出发-…"><a href="#从主要模块的视角出发-…" class="headerlink" title="从主要模块的视角出发 …"></a>从主要模块的视角出发 …</h2><p><strong>模型输入输出</strong>：与语言模型进行接口交互，便捷地实现和组织与 LLM 进行交互的过程</p><ul><li>提示 prompts：将模型输入模板化、动态选择和管理</li><li>语言模型 models：通过常见接口调用语言模型</li><li>输出解析器 output_parsers：从模型输出中提取信息</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230825000153273.webp" alt="image-20230825000153273" style="zoom:50%;" /><p><strong>数据连接</strong>：与特定应用程序数据进行接口交互，对接 LLM 相关的全流程数据处理支持</p><ul><li>文档加载器 Document loaders：从许多不同的源加载文档</li><li>文档转换器 Document transformers：分割文档、删除冗余文档等</li><li>文本嵌入模型 Text embedding models：将非结构化文本转换为浮点数列表</li><li>向量存储 Vector stores：存储和检索嵌入数据</li><li>检索器 Retrievers：查询数据</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230825001104470.webp" alt="image-20230825001104470" style="zoom:50%;" /><p><strong>链</strong>：构造调用序列，支持实现使用 LLM 构建复杂应用所必须的链式调用（与其他 LLM 进行链式调用 / 与其他组件进行链式调用）</p><p><strong>记忆</strong>：在链式调用的运行之间保持应用程序状态，管理并使用与 LLM 对话的上下文（历史消息）</p><p><strong>代理人</strong>：实现根据用户输入，对 LLM 和其他工具进行灵活的调用链（类似 LLM-plugin）</p><ul><li>动作代理人 Action agents：在每个时间步上，使用所有先前动作的输出决定下一个动作</li><li>计划执行代理人 Plan-and-execute agents：预先决定所有动作的完整顺序，然后按照计划执行，不更新计划</li></ul><p><strong>回调函数</strong>：记录和流式传输任何链式调用的中间步骤，在 LLM 应用程序的各个阶段进行钩子处理（如日志记录、监控、流式处理和其他任务）</p><h2 id="从实践领域角度出发-…"><a href="#从实践领域角度出发-…" class="headerlink" title="从实践领域角度出发 …"></a>从实践领域角度出发 …</h2><h3 id="一、提示工程-Prompting-Engineering"><a href="#一、提示工程-Prompting-Engineering" class="headerlink" title="一、提示工程 - Prompting Engineering"></a>一、提示工程 - Prompting Engineering</h3><p><strong>更好地管理和使用提示模板</strong>：LangChain 所提供的提示模板对象本质上可以用 <em>f-strings</em> 替换，但能规范化提示过程，灵活添加参数，以面向对象的方式构建提示，并和 LangChain 的其他的功能模块更好地结合</p><ul><li><strong>使用  <code>PromptTemplate</code> 对象</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">openai = OpenAI(</span><br><span class="line">    model_name=<span class="string">&quot;text-davinci-003&quot;</span>,</span><br><span class="line">    openai_api_key=os.getenv(<span class="string">&#x27;OPENAI_API_KEY&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">template = <span class="string">&quot;Question: &#123;query&#125;\nAnswer: &quot;</span></span><br><span class="line">prompt_template = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;query&quot;</span>],</span><br><span class="line">    template=template</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">prompt = prompt_template.<span class="built_in">format</span>(query=<span class="string">&quot;Who&#x27;s Jackie Chan?&quot;</span>)</span><br><span class="line"></span><br><span class="line">response = openai(prompt)</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用 <code>FewShotPromptTemplate</code> 对象</strong></p><p>  将 few-shot example 用 <code>PromptTemplate</code> 对象封装</p><p>  将 few-shot prompt 结构上分解，由 prefix + examples + suffix 共同组成</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> FewShotPromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># create examples</span></span><br><span class="line">examples = [</span><br><span class="line">    &#123;<span class="string">&quot;query&quot;</span>: <span class="string">&quot;xxx?&quot;</span>, <span class="string">&quot;answer&quot;</span>: <span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;query&quot;</span>: <span class="string">&quot;xxx?&quot;</span>, <span class="string">&quot;answer&quot;</span>: <span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a example template</span></span><br><span class="line">example_template = <span class="string">&quot;User: &#123;query&#125;\nAI: &#123;answer&#125;“</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># create a prompt example from above template</span></span><br><span class="line"><span class="string">example_prompt = PromptTemplate(</span></span><br><span class="line"><span class="string">    input_variables=[&quot;</span>query<span class="string">&quot;, &quot;</span>answe<span class="string">r&quot;],</span></span><br><span class="line"><span class="string">    template=example_template</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"># now break our previous prompt into a prefix and suffix</span></span><br><span class="line"><span class="string"># the prefix is our instructions</span></span><br><span class="line"><span class="string">prefix = &quot;</span><span class="string">&quot;&quot;</span>The following are excerpts <span class="keyword">from</span> conversations</span><br><span class="line"><span class="keyword">with</span> an AI assistant. The assistant <span class="keyword">is</span> typically sarcastic</span><br><span class="line"><span class="keyword">and</span> witty, producing creative <span class="keyword">and</span> funny responses to the</span><br><span class="line">users questions. Here are some examples: <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># and the suffix our user input and output indicator</span></span><br><span class="line"><span class="string">suffix = &quot;User: &#123;query&#125;\nAI: &quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># now create the few shot prompt template</span></span><br><span class="line"><span class="string">few_shot_prompt_template = FewShotPromptTemplate(</span></span><br><span class="line"><span class="string">    examples=examples,</span></span><br><span class="line"><span class="string">    example_prompt=example_prompt,</span></span><br><span class="line"><span class="string">    prefix=prefix,</span></span><br><span class="line"><span class="string">    suffix=suffix,</span></span><br><span class="line"><span class="string">    input_variables=[&quot;query&quot;],</span></span><br><span class="line"><span class="string">    example_separator=&quot;\n\n&quot;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">prompt= few_shot_prompt_template.format(query=&quot;What is the meaning of life?&quot;)</span></span><br></pre></td></tr></table></figure><p>在 examples 数量较多的情况下，动态地选择和构造 few-shot prompt</p><p>基于长度：可以限制过多的标记使用，并避免超出 LLM 的最大上下文窗口而导致错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts.example_selector <span class="keyword">import</span> LengthBasedExampleSelector</span><br><span class="line"></span><br><span class="line">example_selector = LengthBasedExampleSelector(</span><br><span class="line">    examples=examples,</span><br><span class="line">    example_prompt=example_prompt,</span><br><span class="line">    max_length=<span class="number">50</span>  <span class="comment"># this sets the max length that examples should be</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">dynamic_prompt_template = FewShotPromptTemplate(</span><br><span class="line">    example_selector = example_selector,  <span class="comment"># use example_selector instead of examples</span></span><br><span class="line">    example_prompt=example_prompt,</span><br><span class="line">    prefix=prefix,</span><br><span class="line">    suffix=suffix,</span><br><span class="line">    input_variables=[<span class="string">&quot;query&quot;</span>],</span><br><span class="line">    example_separator=<span class="string">&quot;\n\n&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="二、会话记忆-Conversational-Memory"><a href="#二、会话记忆-Conversational-Memory" class="headerlink" title="二、会话记忆 - Conversational Memory"></a>二、会话记忆 - Conversational Memory</h3><p><strong>便捷地管理和组织连续对话的上下文</strong>：</p><ul><li>帮助无状态的 LLM 以类似于有状态的环境的方式进行交互，能够考虑并参考过去的交互</li><li>可以实现自己的记忆模块，在同一链中使用多种类型的记忆，将它们与代理结合使用等等</li></ul><p><strong>使用 <code>ConversationChain</code> 来管理 LLM 的会话记忆</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> ConversationChain</span><br><span class="line"></span><br><span class="line"><span class="comment"># first initialize the large language model</span></span><br><span class="line">llm = OpenAI(</span><br><span class="line">    temperature=<span class="number">0</span>,</span><br><span class="line">    openai_api_key=os.getenv(<span class="string">&#x27;OPENAI_API_KEY&#x27;</span>),</span><br><span class="line">    model_name=<span class="string">&quot;text-davinci-003&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># now initialize the conversation chain</span></span><br><span class="line">conversation = ConversationChain(llm=llm)</span><br></pre></td></tr></table></figure><p><code>conversation.prompt.template</code> 中包含了 <code>&#123;history</code>} 和 <code>&#123;input&#125;</code> 两个参数，其中 <code>history</code> 是使用对话记忆的地方，<code>input</code> 是放置最新的人类查询的地方。</p><p>我们可以使用多种类型的对话记忆来使用 <code>ConversationChain</code> 。它们会修改传递给 <code>&#123;history&#125;</code> 参数的文本。</p><p><strong>LangChain 对于 <code>ConversationChain</code> 中的 <code>memory</code> 提供了不同的实现方式</strong></p><ul><li><strong>使用 <code>ConversationBufferMemory</code>，缓冲区直接保存了聊天历史中的每个交互</strong></li></ul><p>每次交互消耗的 Token 数量近似呈线性增长，容易超出上下文窗口的限制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.conversation.memory <span class="keyword">import</span> ConversationBufferMemory</span><br><span class="line"></span><br><span class="line">conversation_buf = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=ConversationBufferMemory()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><strong>使用 <code>ConversationSummaryMemory</code>，总结每个新的交互并将其附加到所有过去交互的运行汇总中</strong></li></ul><p>每次交互消耗的 Token 数量增长速度低于线性但不收敛，对话轮数较少时消耗的 Token 数量反而相对较高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.conversation.memory <span class="keyword">import</span> ConversationSummaryMemory</span><br><span class="line"></span><br><span class="line">conversation = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=ConversationSummaryMemory(llm=llm)  <span class="comment"># 总结由LLM提供支持</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>生成 Summary 的详细提示模板见 <code>conversation_sum.memory.prompt.template</code></p><ul><li><strong>使用 <code>ConversationBufferWindowMemory</code>，在忘记之前只保留给定数量的过去交互</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.conversation.memory <span class="keyword">import</span> ConversationBufferWindowMemory</span><br><span class="line"></span><br><span class="line">conversation = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memor=ConversationBufferWindowMemory(k=<span class="number">6</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><strong>使用 <code>ConversationSummaryBufferMemory</code>，既能记住远程交互又能以其原始形式存储最近的交互</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.conversation.memory <span class="keyword">import</span> ConversationSummaryBufferMemory</span><br><span class="line"></span><br><span class="line">conversation_sum_bufw = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=ConversationSummaryBufferMemory(llm=llm, max_token_limit=<span class="number">650</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230823182259070.webp" alt="image-20230823182259070" style="zoom:50%;" /><ul><li><strong>使用其他记忆类型，如 <code>ConversationKnowledgeGraphMemory</code>、<code>ConversationEntityMemory</code></strong></li></ul><h3 id="三、知识库-Knowledge-Bases"><a href="#三、知识库-Knowledge-Bases" class="headerlink" title="三、知识库 - Knowledge Bases"></a>三、知识库 - Knowledge Bases</h3><p><strong>便捷地使用外部知识库增强 LLM</strong>：</p><ul><li>使用检索增强技术，从外部知识库中检索相关信息并提供给 LLM</li><li>使用向量数据库作为知识库来为 LLM 提供源知识的支撑</li></ul><ol><li><strong>获取知识库数据</strong></li></ol><ul><li>可以是 LLM 需要帮助编写代码的代码文档，也可以是内部聊天机器人的公司文档，或者其他任何东西</li></ul><p>以使用 Hugging Face 数据集获取维基百科的一个子集为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line">data = load_dataset(<span class="string">&quot;wikipedia&quot;</span>, <span class="string">&quot;20220301.simple&quot;</span>, split =<span class="string">&#x27;train [: 10000]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Dataset(&#123;</span></span><br><span class="line"><span class="string">    features: [&#x27;id&#x27;, &#x27;url&#x27;, &#x27;title&#x27;, &#x27;text&#x27;],</span></span><br><span class="line"><span class="string">    num_rows: 10000</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建文本块</strong></li></ol><p>为什么要将文本分割成较小的块？</p><ul><li>提高 ”嵌入准确性“</li><li>减少输入 LLM 的文本量：限制输入可以提高 LLM 遵循指示的能力，减少生成成本，获得更快的响应</li><li>将信息源缩小到更小的文本块，提供更精确的信息源</li><li>将非常长的（超过最大上下文窗口）文本块拆分，使其可以被添加到知识库中</li></ul><p><strong>使用 <code>RecursiveCharacterTextSplitter</code>，将文本分割成不超过 <code>chunk_size</code>长度的块</strong></p><ul><li>注：这里使用了 tiktoken 库来完成计算 token 数量的计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tiktoken  <span class="comment"># ! pip install tiktoken</span></span><br><span class="line">tokenizer = tiktoken.get_encoding(<span class="string">&#x27;p50k_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create the length function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tiktoken_len</span>(<span class="params">text</span>):</span><br><span class="line">    tokens = tokenizer.encode(text, disallowed_special=())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(tokens)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">    chunk_size=<span class="number">400</span>,</span><br><span class="line">    chunk_overlap=<span class="number">20</span>,</span><br><span class="line">    length_function=tiktoken_len,</span><br><span class="line">    separators=[<span class="string">&quot;\n\n&quot;</span>, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chunks = text_splitter.split_text(data[<span class="number">6</span>][<span class="string">&#x27;text&#x27;</span>])[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>创建嵌入</strong></li></ol><p>嵌入结果存储在向量数据库中，并且可以通过计算向量空间中嵌入之间的距离来找到具有相似含义的文本块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.embeddings.openai <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"></span><br><span class="line">embed = OpenAIEmbeddings(</span><br><span class="line">    document_model_name=<span class="string">&#x27;text-embedding-ada-002&#x27;</span>,</span><br><span class="line">    query_model_name=<span class="string">&#x27;text-embedding-ada-002&#x27;</span>,</span><br><span class="line">    openai_api_key=os.getenv(<span class="string">&#x27;OPENAI_API_KEY&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">texts = [</span><br><span class="line">    <span class="string">&#x27;first chunk of text&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;second chunk of text&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;third chunk of text&#x27;</span></span><br><span class="line">]</span><br><span class="line">res = embed.embed_documents(texts)</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>使用向量数据库</strong></li></ol><p>主流的开源向量数据库：Milvus 等；主流的闭源向量数据库：Pinecone 等</p><p>以 Pinecone 向量数据库为例（需要一个 API 密钥 <a href="https://app.pinecone.io/%EF%BC%89%EF%BC%9A">https://app.pinecone.io/）：</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pinecone</span><br><span class="line"></span><br><span class="line">pinecone.init(</span><br><span class="line">api_key=<span class="string">&quot;YOUR_API_KEY&quot;</span>,  <span class="comment"># find api key in console at app.pinecone.io</span></span><br><span class="line">environment=<span class="string">&quot;YOUR_ENV&quot;</span>  <span class="comment"># find next to api key in console</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a new index</span></span><br><span class="line">pinecone.create_index(</span><br><span class="line">name=index_name,</span><br><span class="line">metric=<span class="string">&#x27;dotproduct&#x27;</span>,</span><br><span class="line">dimension=<span class="built_in">len</span>(res[<span class="number">0</span>]) <span class="comment"># 1536 dim of text-embedding-ada-002</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># link to new index</span></span><br><span class="line">Index = pinecone.GRPCIndex(index_name)</span><br><span class="line"></span><br><span class="line">Index.describe_index_stats()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;dimension&#x27;: 1536,</span></span><br><span class="line"><span class="string"> &#x27;index_fullness&#x27;: 0.0,</span></span><br><span class="line"><span class="string"> &#x27;namespaces&#x27;: &#123;&#125;,</span></span><br><span class="line"><span class="string"> &#x27;total_vector_count&#x27;: 0&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>此时尚未添加任何向量，故新 Pinecone 索引的 <code>total_vector_count</code> 为 0。</p><p>索引过程包括：遍历想要添加到知识库中的数据，为其创建ID、嵌入和元数据，然后将其添加到索引中。</p><ul><li>可以批量处理此过程以加快速度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"></span><br><span class="line">batch_limit = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">texts = []</span><br><span class="line">metadatas = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, record <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(data)):</span><br><span class="line">    <span class="comment"># get metadata fields for this record</span></span><br><span class="line">    metadata = &#123;</span><br><span class="line">        <span class="string">&#x27;wiki-id&#x27;</span>: <span class="built_in">str</span>(record[<span class="string">&#x27;id&#x27;</span>]),</span><br><span class="line">        <span class="string">&#x27;source&#x27;</span>: record[<span class="string">&#x27;url&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: record[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># create chunks from the record text</span></span><br><span class="line">    record_texts = text_splitter.split_text(record[<span class="string">&#x27;text&#x27;</span>])</span><br><span class="line">    <span class="comment"># create individual metadata dicts for each chunk</span></span><br><span class="line">    record_metadatas = [&#123;</span><br><span class="line">        <span class="string">&quot;chunk&quot;</span>: j, <span class="string">&quot;text&quot;</span>: text, **metadata</span><br><span class="line">    &#125; <span class="keyword">for</span> j, text <span class="keyword">in</span> <span class="built_in">enumerate</span>(record_texts)]</span><br><span class="line">    <span class="comment"># append these to current batches</span></span><br><span class="line">    texts.extend(record_texts)</span><br><span class="line">    metadatas.extend(record_metadatas)</span><br><span class="line">    <span class="comment"># if we have reached the batch_limit we can add texts</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(texts) &gt;= batch_limit:</span><br><span class="line">        ids = [<span class="built_in">str</span>(uuid4()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(texts))]</span><br><span class="line">        embeds = embed.embed_documents(texts)</span><br><span class="line">        Index.upsert(vectors=<span class="built_in">zip</span>(ids, embeds, metadatas))</span><br><span class="line">        texts = []</span><br><span class="line">        metadatas = []</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Index.describe_index_stats()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;dimension&#x27;: 1536,</span></span><br><span class="line"><span class="string"> &#x27;index_fullness&#x27;: 0.1,</span></span><br><span class="line"><span class="string"> &#x27;namespaces&#x27;: &#123;&#x27;&#x27;: &#123;&#x27;vector_count&#x27;: 27437&#125;&#125;,</span></span><br><span class="line"><span class="string"> &#x27;total_vector_count&#x27;: 27437&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>向量存储与查询</strong></li></ol><p><strong>通过 LangChain 库重新连接到创建的索引</strong></p><ul><li>上一步中独立构建的索引与 LangChain 无关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> Pinecone</span><br><span class="line"></span><br><span class="line">text_field = <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># switch back to normal index for langchain</span></span><br><span class="line"></span><br><span class="line">Index = pinecone.Index(index_name)</span><br><span class="line"></span><br><span class="line">vectorstore = Pinecone(</span><br><span class="line">    index, embed.embed_query, text_field</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>使用 <code>similarity search</code> 方法直接进行查询</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query = <span class="string">&quot;who was Benito Mussolini?&quot;</span></span><br><span class="line"></span><br><span class="line">vectorstore.similarity_search(</span><br><span class="line">    query=<span class="string">&quot;who was Jakie Chan?&quot;</span>,</span><br><span class="line">    k=<span class="number">3</span>  <span class="comment"># return 3 most relevant docs</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>得到检索到的相关上下文信息，从而可以进一步使用 LLM 来生成答案。</p><p>以生成式问答（将问题传递给 LLM，指示它基于从知识库返回的信息来回答问题）为例：</p><p><strong>使用 <code>RetrievalQA</code> 链，根据向量数据库检索到的信息生成回答</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQA</span><br><span class="line"></span><br><span class="line"><span class="comment"># completion llm</span></span><br><span class="line">llm = ChatOpenAI(</span><br><span class="line">    openai_api_key=os.getenv(<span class="string">&#x27;OPENAI_API_KEY&#x27;</span>),</span><br><span class="line">    model_name=<span class="string">&#x27;gpt-3.5-turbo&#x27;</span>,</span><br><span class="line">    temperature=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">qa = RetrievalQA.from_chain_type(</span><br><span class="line">    llm=llm,</span><br><span class="line">    chain_type=<span class="string">&quot;stuff&quot;</span>,</span><br><span class="line">    retriever=vectorstore.as_retriever()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response = qa.run(query=<span class="string">&quot;who was Jakie Chan?&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>使用 <code>RetrievalQAWithSourcesChain</code>，允许用户看到信息的来源，提高对所提供答案的信任</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQAWithSourcesChain</span><br><span class="line"></span><br><span class="line">qa_with_sources = RetrievalQAWithSourcesChain.from_chain_type(</span><br><span class="line">    llm=llm,</span><br><span class="line">    chain_type=<span class="string">&quot;stuff&quot;</span>,</span><br><span class="line">    retriever=vectorstore.as_retriever()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response = qa_with_sources.run(query=<span class="string">&quot;who was Jakie Chan?&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="四、会话代理-Conversational-Agents"><a href="#四、会话代理-Conversational-Agents" class="headerlink" title="四、会话代理 - Conversational Agents"></a>四、会话代理 - Conversational Agents</h3><p><strong>代理可以被视为 LLM 的工具，比如：代理是可以使用计算器、搜索或执行代码的 LLM</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230825214911980.webp" alt="image-20230825214911980" style="zoom:50%;" /><p><strong>代理三要素</strong>：基本的 LLM，要进行交互的工具，控制交互的代理</p><p>LangChain 库提供了大量预置的工具，以下示例中包含了计算器工具和常规对话工具，Agent 可以根据需要进行工具的选择，既能够精确处理计算问题，也能够应对常规对话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Basic LLM&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">llm = OpenAI(</span><br><span class="line">    openai_api_key=os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>),</span><br><span class="line">    temperature=<span class="number">0</span>,</span><br><span class="line">    model_name=<span class="string">&quot;text-davinci-003&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;Tool(s) to be interacted&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> LLMMathChain</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> Tool</span><br><span class="line"></span><br><span class="line">llm_math = LLMMathChain(llm=llm)</span><br><span class="line"><span class="comment"># initialize the math tool</span></span><br><span class="line">math_tool = Tool(</span><br><span class="line">    name=<span class="string">&#x27;Calculator&#x27;</span>,</span><br><span class="line">    func=llm_math.run,</span><br><span class="line">    description=<span class="string">&#x27;Useful for when you need to answer questions about math.&#x27;</span></span><br><span class="line">)</span><br><span class="line">llm_tool = Tool(</span><br><span class="line">    name =<span class="string">&#x27;Language Model&#x27;</span>,</span><br><span class="line">    func = llm_chain.run,</span><br><span class="line">    description =<span class="string">&#x27;use this tool for general purpose queries and logic&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># when giving tools to LLM, we must pass as list of tools</span></span><br><span class="line">tools = [math_tool, llm_tool]</span><br><span class="line"><span class="comment"># directly load pre-constructed tools</span></span><br><span class="line"><span class="comment"># from langchain.agents import load_tools</span></span><br><span class="line"><span class="comment"># tools = load_tools([&#x27;llm-math&#x27;], llm=llm)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;Agent&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> initialize_agent</span><br><span class="line"></span><br><span class="line">zero_shot_agent = initialize_agent(</span><br><span class="line">    agent=<span class="string">&quot;zero-shot-react-description&quot;</span>,  <span class="comment"># stateless + ReAct method</span></span><br><span class="line">    tools=tools,</span><br><span class="line">    llm=llm,</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">    max_iterations=<span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zero_shot_agent(<span class="string">&quot;what is (4.5*2.1)^2.2?&quot;</span>)</span><br><span class="line">zero_shot_agent(<span class="string">&quot;what is the capital of Norway?&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>代理的类型</strong>：</p><ul><li><p>Zero Shot ReAct (“zero-shot-react-description”)：无状态（无记忆）</p></li><li><p>ReAct Conversational ReAct (“conversational-react-description”)：有状态（有记忆）</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferMemory</span><br><span class="line"></span><br><span class="line">memory = ConversationBufferMemory(memory_key=<span class="string">&quot;chat_history&quot;</span>)</span><br><span class="line"></span><br><span class="line">conversational_agent = initialize_agent(</span><br><span class="line">    agent=<span class="string">&#x27;conversational-react-description&#x27;</span>, </span><br><span class="line">    tools=tools, </span><br><span class="line">    llm=llm,</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">    max_iterations=<span class="number">3</span>,</span><br><span class="line">    memory=memory,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>ReAct Docstore (“react-docstore”)：使用 LangChain 的 <em>docstore</em> 进行信息搜索和查找</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> Wikipedia</span><br><span class="line"><span class="keyword">from</span> langchain.agents.react.base <span class="keyword">import</span> DocstoreExplorer</span><br><span class="line"></span><br><span class="line">docstore = DocstoreExplorer(Wikipedia())</span><br><span class="line">tools = [</span><br><span class="line">    Tool(</span><br><span class="line">        name = <span class="string">&quot;Search&quot;</span>,  <span class="comment"># Search for relevant articles</span></span><br><span class="line">        func = docstore.search,</span><br><span class="line">        description =<span class="string">&#x27;search wikipedia&#x27;</span></span><br><span class="line">    ),</span><br><span class="line">    Tool(</span><br><span class="line">        name = <span class="string">&quot;Lookup&quot;</span>,  <span class="comment"># Find relevant chunks of information in retrieved articles</span></span><br><span class="line">        func = docstore.lookup,</span><br><span class="line">        description =<span class="string">&#x27;lookup a term in wikipedia&#x27;</span></span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">docstore_agent = initialize_agent(</span><br><span class="line">    tools=tools, </span><br><span class="line">    llm=llm, </span><br><span class="line">    agent=<span class="string">&quot;react-docstore&quot;</span>, </span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">    max_iterations=<span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">docstore_agent(<span class="string">&quot;What were Archimedes&#x27; last words?&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>Self-ask With Search (“self-ask-with-search”)：根据需要执行搜索和提问步骤，以获得最终答案</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> SerpAPIWrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize the search chain</span></span><br><span class="line">search = SerpAPIWrapper(serpapi_api_key =<span class="string">&#x27;serp_api_key&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a search tool</span></span><br><span class="line">tools = [</span><br><span class="line">    Tool(</span><br><span class="line">        name=<span class="string">&quot;Intermediate Answer&quot;</span>,</span><br><span class="line">        func=search.run,</span><br><span class="line">        description=<span class="string">&#x27;google search&#x27;</span></span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize the search enabled agent</span></span><br><span class="line">self_ask_with_search = initialize_agent(</span><br><span class="line">    tools=tools,</span><br><span class="line">    llm=llm,</span><br><span class="line">    agent=<span class="string">&quot;self-ask-with-search&quot;</span>,</span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">self_ask_with_search(<span class="string">&quot;who lived longer; Plato, Socrates, or Aristotle?&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="五、自定义工具-Custom-Tools"><a href="#五、自定义工具-Custom-Tools" class="headerlink" title="五、自定义工具 - Custom Tools"></a>五、自定义工具 - Custom Tools</h3><p><strong>简单的订制工具</strong></p><p>以一个简单的计算圆周长的工具为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.tools <span class="keyword">import</span> BaseTool  <span class="comment"># Necessary template of LangChain tools</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircumferenceTool</span>(<span class="title class_ inherited__">BaseTool</span>):</span><br><span class="line">    <span class="comment"># Necessary attribute of a LangChain tool</span></span><br><span class="line">self.name = <span class="string">&quot;Circumference calculator&quot;</span></span><br><span class="line">self.description = <span class="string">&quot;use this tool when you need to calculate a circumference using the radius of a circle&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Synchronous call (default)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run</span>(<span class="params">self, radius: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(radius) * <span class="number">2.0</span> * pi</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Asynchronous call</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_arun</span>(<span class="params">self, radius: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;This tool does not support async&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chains.conversation.memory <span class="keyword">import</span> ConversationBufferWindowMemory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize LLM (we use ChatOpenAI because we&#x27;ll later define a `chat` agent)</span></span><br><span class="line">llm = ChatOpenAI(</span><br><span class="line">openai_api_key=os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>),</span><br><span class="line">temperature=<span class="number">0</span>,</span><br><span class="line">model_name=<span class="string">&#x27;gpt-3.5-turbo&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize conversational memory</span></span><br><span class="line">conversational_memory = ConversationBufferWindowMemory(</span><br><span class="line">memory_key=<span class="string">&#x27;chat_history&#x27;</span>,</span><br><span class="line">k=<span class="number">5</span>,</span><br><span class="line">return_messages=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> initialize_agent</span><br><span class="line"></span><br><span class="line">tools = [CircumferenceTool()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize agent with tools</span></span><br><span class="line">agent = initialize_agent(</span><br><span class="line">    agent=<span class="string">&#x27;chat-conversational-react-description&#x27;</span>,</span><br><span class="line">    tools=tools,</span><br><span class="line">    llm=llm,</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">    max_iterations=<span class="number">3</span>,</span><br><span class="line">    early_stopping_method=<span class="string">&#x27;generate&#x27;</span>,</span><br><span class="line">    memory=conversational_memory</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent(<span class="string">&quot;can you calculate the circumference of a circle that has a radius of 7.81mm&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们发现代理给出了不准确的答案，查看调用链可以看出，这是由于代理决定<strong>不</strong>使用圆周计算器工具导致的。</p><p>查看代理内置的提示词，并基于此添加一句话，告诉模型永远不应该尝试进行数学计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(agent.agent.llm_chain.prompt.messages[<span class="number">0</span>].prompt.template)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sys_msg = <span class="string">&quot;&quot;&quot;Assistant is a large language model trained by OpenAI.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Assistant is designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, Assistant is able to generate human-like text based on the input it receives, allowing it to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Assistant is constantly learning and improving, and its capabilities are constantly evolving. It is able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. Additionally, Assistant is able to generate its own text based on the input it receives, allowing it to engage in discussions and provide explanations and descriptions on a wide range of topics.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Unfortunately, Assistant is terrible at maths. When provided with math questions, no matter how simple, assistant always refers to it&#x27;s trusty tools and absolutely does NOT try to answer math questions by itself</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Overall, Assistant is a powerful system that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether you need help with a specific question or just want to have a conversation about a particular topic, Assistant is here to assist.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">new_prompt = agent.agent.create_prompt(</span><br><span class="line">    system_message=sys_msg,</span><br><span class="line">    tools=tools</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">agent.agent.llm_chain.prompt = new_prompt</span><br></pre></td></tr></table></figure><p><strong>带有多个参数的工具</strong></p><p>下面是一个 <code>三角形斜边计算器工具</code> 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt, cos, sin</span><br><span class="line"></span><br><span class="line">desc = (</span><br><span class="line">    <span class="string">&quot;use this tool when you need to calculate the length of a hypotenuse&quot;</span></span><br><span class="line">    <span class="string">&quot;given one or two sides of a triangle and/or an angle (in degrees). &quot;</span></span><br><span class="line">    <span class="string">&quot;To use the tool, you must provide at least two of the following parameters &quot;</span></span><br><span class="line">    <span class="string">&quot;[&#x27;adjacent_side&#x27;, &#x27;opposite_side&#x27;, &#x27;angle&#x27;].&quot;</span></span><br><span class="line">)  <span class="comment"># Teach LLM about input format / requirement</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PythagorasTool</span>(<span class="title class_ inherited__">BaseTool</span>):</span><br><span class="line">    self.name = <span class="string">&quot;Hypotenuse calculator&quot;</span></span><br><span class="line">    self.description = desc</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        adjacent_side: <span class="type">Optional</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        opposite_side: <span class="type">Optional</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        angle: <span class="type">Optional</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="comment"># check for the values we have been given</span></span><br><span class="line">        <span class="keyword">if</span> adjacent_side <span class="keyword">and</span> opposite_side:</span><br><span class="line">            <span class="keyword">return</span> sqrt(<span class="built_in">float</span>(adjacent_side)**<span class="number">2</span> + <span class="built_in">float</span>(opposite_side)**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> adjacent_side <span class="keyword">and</span> angle:</span><br><span class="line">            <span class="keyword">return</span> adjacent_side / cos(<span class="built_in">float</span>(angle))</span><br><span class="line">        <span class="keyword">elif</span> opposite_side <span class="keyword">and</span> angle:</span><br><span class="line">            <span class="keyword">return</span> opposite_side / sin(<span class="built_in">float</span>(angle))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Could not calculate the hypotenuse of the triangle. Need two or more of `adjacent_side`, `opposite_side`, or `angle`.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_arun</span>(<span class="params">self, query: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;This tool does not support async&quot;</span>)</span><br><span class="line"></span><br><span class="line">tools = [PythagorasTool()]</span><br></pre></td></tr></table></figure><p><strong>更高级的工具使用</strong></p><ul><li>将（能够完成 LLM 无法做到的任务的）专家模型作为工具添加进来，使得代理作为这些模型的控制器。</li><li>除此之外，工具可以用于与无尽的功能和服务集成，或者与一系列专家模型进行通信。</li><li>通常可以使用 LangChain 的默认工具来运行 SQL 查询，执行计算或进行向量搜索。但当这些默认工具无法满足要求时，需要构建自己的工具。</li></ul><p>如：开源专家模型 <code>Salesforce/blip-image-captioning-large</code> ：接收一张图片并对其进行描述（托管在 Hugging Face 上）</p>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 向量数据库 </tag>
            
            <tag> LangChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程文本情感分析实战</title>
      <link href="/2023/06/15/SE-Text-Sentiment-Analysis/"/>
      <url>/2023/06/15/SE-Text-Sentiment-Analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><ol><li><p><strong>关于开源项目 SentiStrength</strong></p><ul><li><p><code>SentiStrength</code> 为 Mike Thelwall 等人根据 MySpace 网站数据开发的社交文本情感分析工具</p></li><li><p>其官网地址为：<a href="http://sentistrength.wlv.ac.uk/">http://sentistrength.wlv.ac.uk</a></p></li><li><p>官网提供了该工具的原版 jar 包，各种使用手册，以及可以试运行的 demo 等</p></li><li><p>除此之外，它还罗列了与该工具有关的若干论文，并提供了工具开发过程中标注的数据集</p></li><li><p>官网 jar 包的反编译结果以发布于：<a href="https://github.com/skx980810/SentiStrength">https://github.com/skx980810/SentiStrength</a></p></li></ul></li></ol><ol start="2"><li><strong>关于软工文本情感分析</strong></li></ol><p>软件工程文本的情感分析已广泛应用于软件工程研究，例如评估应用程序评论或分析开发人员在提交信息中的情感。但是，为分析社交媒体文本或产品评论而开发的情感分析工具在软件工程数据集上效果不佳。</p><p>研究发现开发人员在各种软件工程活动中表达了情感，因此需要一种针对软件工程领域的定制情感分析工具。</p><p>为了更好地支持在软件工程任务中使用自动情感分析，研究人员使用了多种技术手段，如建立软件工程领域指定的情感字典、使用经过标注的软件工程领域文本来训练机器学习模型，以进一步提高结果的准确性。</p><ol start="3"><li><strong>关于大模型时代的机器学习</strong></li></ol><p>随着硬件计算能力的提高、数据的积累和模型结构的进步，我们开始能够训练出更大、更复杂的模型，前言的机器学习进入真正意义上的 “大模型时代”。</p><ul><li><p>更强的表达能力：更多的参数意味着更好地拟合复杂的数据分布 能力，理论上能够表示更丰富的函数空间</p></li><li><p>更好的泛化能力：虽然存在过拟合的可能，但在大数据背景下，大模型往往能够实现更好的泛化</p></li><li><p>转移学习能力强：可以被用作预训练模型，对其他相关任务进行微调，大大减少了从头训练模型的需要、</p></li></ul><p>对于下游的科研任务，大模型可以带来研究方法的变革。例如，传统上，机器学习研究重视特征工程和模型的选择；而在大模型时代，端到端的训练、预训练-微调的范式、自监督学习等方法逐渐占据主导地位。</p><h2 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h2><ol><li><strong>数据集构建</strong><ul><li>助教提供了两个已构建的软工文本数据集 <code>sof-4423</code> 和 <code>app-review</code></li><li>通过爬虫从以相关网站获取软工文本数据，人工标注并对结果进行过滤，新构建了 1000 条数据的数据集<ul><li>使用多线程加速，提高爬虫效率：<code>ThreadPoolExecutor</code></li><li>使用爬虫代理 IP 池规避 API 限流：<a href="https://github.com/jhao104/proxy_pool">https://github.com/jhao104/proxy_pool</a></li></ul></li></ul></li></ol><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230828220342187.webp" alt="image-20230828220342187" style="zoom:25%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230828220357281.webp" alt="image-20230828220357281" style="zoom:25%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230828220408235.webp" alt="image-20230828220408235" style="zoom:25%;" /></center>    <ol start="2"><li><p><strong>预处理规则构建</strong></p><ul><li>参考论文 SentiCR 中的预处理方式：<a href="https://github.com/senticr/SentiCR">https://github.com/senticr/SentiCR</a></li></ul> <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230828221323323.webp" alt="image-20230828221323323" style="zoom: 25%;" /> <ul><li>额外引入新的词性分析及相关处理</li></ul> <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230828221754276.webp" alt="image-20230828221754276" style="zoom:33%;" /> <ul><li>额外处理斜体、全大写和一些软件工程领域特定词汇</li></ul></li><li><p><strong>模型训练与微调</strong></p><ul><li><p>将数据集分为训练集和测试集，训练集用于模型训练/微调，测试集用于评估模型预测准确性</p></li><li><p>分别采用传统的训练小型机器学习模型和微调大模型的方式来进行实践</p><ul><li><p>使用 Python中的机器学习库 scikit-learn 来构建并训练各种不同的机器学习模型</p></li><li><p>使用 OpenAI 开放可通过 API 进行在线微调的模型来做微调</p><ul><li>Ada：中小型语言模型，2 亿参数，可用于自然语言生成、回答问题和文本分类等任务</li><li>Babbage：中型语言模型，6 亿参数，可用于自然语言生成、回答问题和文本分类等任务</li><li>Curie：中大型语言模型，13 亿参数，可用于自然语言生成、回答问题和文本分类等任务</li><li>Davinci：大型的语言模型，175 亿参数，目前最先进、最强大的语言模型之一，能够执行多种自然语言任务，如问答、生成、摘要等</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230828215602686.webp" alt="image-20230828215602686" style="zoom:50%;" /><blockquote><p>OpenAI 目前可能已经关闭对以上模型的微调支持，最新可微调的模型信息详见 OpenAI 官网文档：<a href="https://platform.openai.com/docs/guides/fine-tuning">https://platform.openai.com/docs/guides/fine-tuning</a></p></blockquote></li></ul></li></ul></li></ol><h2 id="实验与总结"><a href="#实验与总结" class="headerlink" title="实验与总结"></a>实验与总结</h2><ol><li><p><strong>实验概述</strong></p><ul><li>训练一个三分类器对软工文本进行情感预测（1 positive，0 neutral，-1 negative）</li><li>训练数据集以助教提供的预划分的 <code>sof4423</code> 为基准，自行构建的数据集作为辅助进行对比实验</li></ul></li><li><p><strong>处理流程</strong></p><p> 以 SentiCR 为参考：<a href="https://github.com/senticr/SentiCR">https://github.com/senticr/SentiCR</a></p><ul><li>对文本数据进行预处理（使用 NLP 算法，进行展开缩写、去除 URL 等预处理）</li><li>将预处理后的文本数据转换成向量（使用 TF-IDF 算法将文本转化为向量）</li><li>使用训练集训练一个三分类器（使用 sikit-learn 库中不同的分类器进行训练和测试）</li><li>将训练好的模型在测试集上进行测试</li></ul></li><li><p><strong>改进思路</strong></p><ul><li>方向一：预处理，尝试不同的文本预处理方法</li><li>方向二：文本向量化，尝试不同的文本向量化方法或模型</li><li>方向三：分类器，尝试不同的分类器算法</li><li>方向四：端到端，微调大模型实现端到端的预测</li></ul></li></ol><p><strong>实验一</strong>：传统机器学习</p><ul><li>文本向量化方法： <ul><li>TF-IDF 算法</li><li> OpenAI 的 <code>text-embedding-ada-002</code> 模型</li></ul></li><li>分类算法选择 scikit-learn 库中的一系列机器学习分类器：<ul><li>LinearSVC</li><li>BernoulliNB</li><li>SGDClassifier</li><li>AdaBoostClassifier</li><li>RandomForestClassifier</li><li>GradientBoostingClassifier</li><li>DecisionTreeClassifier</li><li>MLPClassifier</li></ul></li><li>两两组合记录预测结果</li></ul><table><thead><tr><th>排名</th><th>文本向量化方法</th><th>分类器算法</th><th>预测准确率</th></tr></thead><tbody><tr><td>1</td><td>text-embedding-ada-002</td><td>SGDClassifier</td><td><strong>86.43%</strong></td></tr><tr><td>2</td><td>text-embedding-ada-002</td><td>LinearSVC</td><td><strong>85.67%</strong></td></tr><tr><td>3</td><td>TF-IDF</td><td>RandomForestClassifier</td><td><strong>83.79%</strong></td></tr><tr><td>4</td><td>TF-IDF</td><td>GradientBoostingClassifier</td><td><strong>83.33%</strong></td></tr><tr><td>5</td><td>TF-IDF</td><td>SGDClassifier</td><td><strong>82.96%</strong></td></tr><tr><td>6</td><td>TF-IDF</td><td>LinearSVC</td><td><strong>82.88%</strong></td></tr><tr><td>7</td><td>text-embedding-ada-002</td><td>MLPClassifier</td><td><strong>82.28%</strong></td></tr><tr><td>8</td><td>TF-IDF</td><td>MLPClassifier</td><td>81.98%</td></tr><tr><td>9</td><td>TF-IDF</td><td>AdaBoostClassifier</td><td>81.00%</td></tr><tr><td>10</td><td>text-embedding-ada-002</td><td>GradientBoostingClassifier</td><td>80.24%</td></tr><tr><td>11</td><td>TF-IDF</td><td>DecisionTreeClassifier</td><td>78.81%</td></tr><tr><td>12</td><td>text-embedding-ada-002</td><td>RandomForestClassifier</td><td>76.40%</td></tr><tr><td>13</td><td>text-embedding-ada-002</td><td>BernoulliNB</td><td>76.09%</td></tr><tr><td>14</td><td>TF-IDF</td><td>BernoulliNB</td><td>75.94%</td></tr><tr><td>15</td><td>text-embedding-ada-002</td><td>AdaBoostClassifier</td><td>71.95%</td></tr><tr><td>16</td><td>text-embedding-ada-002</td><td>DecisionTreeClassifier</td><td>56.49%</td></tr></tbody></table><p><strong>实验二</strong>：微调大模型</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230828230205656.webp" alt="image-20230828230205656" style="zoom: 67%;" /><p><strong>实验分析</strong></p><ul><li><p><strong>嵌入模型和 TF-IDF 算法对比分析</strong></p><ul><li><p><strong>TF-IDF</strong> 是一种用于信息检索与数据挖掘的常用加权技术，常用于挖掘文章中的关键词，算法简单高效、可解释性强，根据词频和逆文档频率，将目标文本转换为向量（长度不固定）</p></li><li><p><strong>Embedding</strong> 通过预训练的模型直接将单词映射到向量空间，更能表现词的上下文结构，由词向量叠加得到目标文本对应的向量（长度固定）</p></li><li><p>选用的分类器中非神经网络的模型（如决策树、随机森林）无法理解向量空间的特征，与 Embedding 模型不匹配，因此预测的效果反而较差，不如使用相对简单的 TF-IDF 算法</p></li></ul></li><li><p><strong>新增数据集没有效果的原因分析</strong></p><ol><li>同样是软件工程文本，不同数据来源的文本风格也存在较大的差异</li><li>爬取到的数据中，情感标注结果为中性的文本项较多，数据分布不平均</li></ol></li><li><p><strong>对微调大模型的对照实验分析</strong></p><ol><li><p>参数量更大的模型对于提升预测准确率有一定的帮助</p></li><li><p>基于同义词替换的数据增强对于参数量相对较少的 Ada 模型有效，但对更大的模型反而会抑制泛化效果</p></li><li><p>对文本的预处理对于参数量相对较少的 Ada 模型有效，但对更大的模型反而会抑制泛化效果</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 文本情绪分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《服务端开发》复习总结</title>
      <link href="/2023/04/07/NJU-Service-Side-Development/"/>
      <url>/2023/04/07/NJU-Service-Side-Development/</url>
      
        <content type="html"><![CDATA[<h2 id="01-Spring-Boot"><a href="#01-Spring-Boot" class="headerlink" title="01. Spring Boot"></a>01. Spring Boot</h2><ul><li>Spring Boot Devtools：开发期工具，runtime依赖，只在运行期起作用<ul><li>代码变更后自动重启应用</li><li>面向浏览器资源发生变化时自动刷新浏览器（LiveReload端口）</li><li>自动禁用模板缓存</li><li>内置H2控制台：<a href="http://localhost:8080/h2-console">http://localhost:8080/h2-console</a></li></ul></li><li>git/gitlab<ul><li>纳入版本控制：功能代码，测试代码，测试脚本，构建脚本，部署脚本</li><li>工作区？展存区？本地仓库？远端仓库？</li></ul></li></ul><h2 id="02-依赖注入（控制反转）"><a href="#02-依赖注入（控制反转）" class="headerlink" title="02. 依赖注入（控制反转）"></a>02. 依赖注入（控制反转）</h2><ul><li>核心技术：DI和AOP</li><li>Spring是一个容器</li><li>@Component对类进行实例化</li><li>@ComponentScan</li><li>@Autowired自动装配，将上下文中已实例化的对象注入到当前对象中，可放在构造方法/属性Setter方法/属性上</li><li>Bean的作用域@Scope <ul><li>默认为Singleton单例</li><li>Prototype原型，每次注入或通过上下文获取时创建新实例</li><li>Session会话，为每个会话创建一个bean实例</li><li>Request请求，为每个请求创建一个bean实例</li></ul></li></ul><h2 id="03-AOP"><a href="#03-AOP" class="headerlink" title="03. AOP"></a>03. AOP</h2><ul><li>AOP术语<ul><li>@Aspect没有@Component注解的效果，即spring不会扫描到当前类并实例化<ul><li>@controller，@Service，@Repository注解含有@Component</li></ul></li><li>通知：切面做什么、何时做（代码、@Before、@AfterReturning等）</li><li>切点：何处（切点表达式，类/方法/包路径）</li><li>切面：通知 + 切点</li><li>连接点：方法 / 字段修改 / 构造方法，spring只支持第一种</li><li>引入：动态给对象增加新的行为和状态（相对于实现一个子类）</li><li>织入：</li></ul></li><li>切点指示器<ul><li>@Pointcut 获取参数，限定到包路径，限定bean名称</li><li>@Around(“@annotation(xxx)”) 限定注解</li></ul></li></ul><h2 id="04-Web-MVC"><a href="#04-Web-MVC" class="headerlink" title="04. Web MVC"></a>04. Web MVC</h2><ul><li>lombok：只在编译期起作用，简化代码</li><li>SpringMVC请求映射注解：注意@RequestMapping既可以加在类也可以加在方法上面</li><li>程序入口@SpringBootApplication</li><li>SpringWeb开发框架分层：请求-控制器层-业务层-数据访问层-数据库<ul><li>路径参数@PathVariable</li><li>请求参数@RequestParam</li><li>表单参数(默认)对应model，可用@Valid校验</li><li>JSON请求体@RequestBody，将json转成java对象</li><li>前后端不分离：model的属性带到页面渲染中，控制器返回视图名，第三方找到模板文件路径并渲染并返回html页面</li><li>前后端分离：返回json格式的数据@ResponseBody，将java对象转成json格式@RestController</li></ul></li></ul><h2 id="05-Dao层实现"><a href="#05-Dao层实现" class="headerlink" title="05. Dao层实现"></a>05. Dao层实现</h2><ul><li>JDBC Template<ul><li>引入依赖spring-boot-starter-jdbc</li><li>解决样板式代码的问题，只需提供查询逻辑</li><li>需要自己定义并实现持久化接口，并维护各表之间的包含关系</li><li>需要提供schema.sql文件（表结构）</li></ul></li><li>Spring Data JDBC<ul><li>引入依赖spring-boot-starter-data-jdbc</li><li>只需要提供持久化接口定义，不需要自行实现</li><li>在实体内需要使用@Table，@Id等，定义实体类和数据库表的映射关系</li><li>需要提供schema.sql文件（表结构）</li></ul></li><li>Spring Data JPA<ul><li>引入依赖spring-boot-starter-data-jpa</li><li>只需要提供持久化接口定义，不需要自行实现</li><li>在实体内需要使用@Entity，@Id等，定义实体类和数据库表的映射关系</li><li>不需要提供schema.sql文件（表结构）</li><li>可以根据规则(领域特定语言/@Query声明自定义查询)自定义查询方法，无需实现</li><li>JPA、Hibernate 和 Spring Data JPA 的关系<ul><li>JPA 统一了 Java 应用程序访问 ORM 框架的规范，提供了 JPQL（面向对象的查询语言）等</li><li>Hibernate 是 JPA 的一种实现，是一个框架</li><li>Spring Data JPA 是一种 JPA 的抽象层，底层依赖 Hibernate</li></ul></li></ul></li></ul><h2 id="06-Spring-Security"><a href="#06-Spring-Security" class="headerlink" title="06. Spring Security"></a>06. Spring Security</h2><ul><li>用户信息存储<ul><li>内存用户存储</li><li>JDBC用户存储</li><li>LDAP用户存储</li></ul></li><li>实现服务接口，让SpringSecurity框架调用，输入用户名，返回用户详细信息</li><li>实现PasswordEncoder接口并实例化到spring上下文，决定加解密方式</li><li>Spring Security框架提供实现用户认证与授权</li><li>针对不同url(Web请求)进行保护<ul><li>HttpSecurity对象，对不同url实施控制配置，鉴权和控制实现由框架完成</li></ul></li><li>创建自定义登录页<ul><li>需要认证时转向登录页：.loginPage(“/login”)</li><li>视图控制器定义对应视图：registry.addViewController(“/login”)</li><li>登录的post请求由Spring Security自动处理，默认为username和password，可自行配置</li></ul></li></ul><h2 id="07-使用docker"><a href="#07-使用docker" class="headerlink" title="07. 使用docker"></a>07. 使用docker</h2><ul><li>docker run命令<ul><li>指定端口映射，-p：宿主机端口:容器端口</li><li>退出时自动删除容器，–rm</li><li>后台运行容器并返回容器ID，-d</li><li>设定环境变量，-e ENV_NAME=”xxx”</li></ul></li><li>使用cat /etc/hosts命令查看容器IP地址</li><li>docker管理命令<ul><li>管理：卷volume，网络network，容器container，镜像image</li></ul></li><li>停止运行中的容器：docker stop（可重新启动）</li></ul><h2 id="08-容器镜像构建与编排"><a href="#08-容器镜像构建与编排" class="headerlink" title="08. 容器镜像构建与编排"></a>08. 容器镜像构建与编排</h2><ul><li><p>dockerfile文件的指令</p><ul><li>RUN：构建镜像时执行的命令</li><li>ADD：将本地文件添加到容器中，tar文件自动解压</li><li>COPY：与ADD类似但不会自动解压文件</li><li>CMD：构建容器后调用（只有在容器启动时才能调用）</li><li>ENTRYPOINT：配置容器使其可执行化，配合CMD可省去“application”只使用参数，用于docker run时根据不同参数执行不同功能</li></ul></li><li><p>docker build</p><ul><li>编写dockerfile最佳实践<ul><li>使用.dockerignore文件（在创建镜像时排除不需要的文件）</li><li>容器只运行单个应用（利于管理）</li><li>将多个RUN指令合并为一个（减少镜像的分层）</li><li>基础镜像的标签不要用latest</li><li>每个RUN指令后删除多余文件</li><li>选择合适的基础镜像（alpha版本最好）</li><li>设置WORKDIR和CMD</li></ul></li></ul></li><li><p>服务编排工具docker-compose</p><ul><li>服务service：一个应用对应的容器（可能多个）</li><li>项目project：一组关联的应用容器组成的完整的业务单元，在docker-compose.yml中定义</li></ul></li><li><p>YAML文件</p><ul><li>用缩进表示层级关系</li><li>不允许使用tab键，只能使用空格</li><li>使用“#”表示注释</li><li>使用冒号结构表示对象 / 键值对：a:b，a:{b:c,d:e}</li><li>使用一组连词线“-”开头的行构成一个数组</li><li>使用行内表示法在一行中表示数组：a:[b,c,d,e]</li></ul></li><li><p>docker-compose常用命令</p><ul><li><p>docker-compose ps：只呈现当前目录下docker-compose.yml文件所部署的容器，不是所有的容器，docker-compose images同理</p></li><li><p>docker-compose logs -f [services…]：查看容器输出日志</p></li></ul></li></ul><h2 id="09-使用k8s"><a href="#09-使用k8s" class="headerlink" title="09. 使用k8s"></a>09. 使用k8s</h2><ul><li>k8s中的资源<ul><li>pod：k8s中调度的最小单元，支持多容器在pod中共享网络和文件系统<ul><li>共享：PID命名，network命名空间，IPC命名空间，UTS命名空间，volume</li></ul></li><li>ingress</li><li>service</li><li>deployment</li></ul></li><li>访问部署在k8s中的服务<ul><li>将pod或service的端口映射到本机端口（用于调试）<ul><li>kubectl port-forward pod/myspittr 8081:8080</li><li>kubectl port-forward service/demo 8081:80</li></ul></li><li>创建ingress，通过路由访问部署在k8s中的服务<ul><li>kubectl create ingress myspittr –class=nginx –rule=<a href="http://www.demo.com/*=myspittr:8080">www.demo.com/*=myspittr:8080</a></li></ul></li><li>使用curl工具访问部署在k8s中的服务<ul><li>kubectl run -i -t –rm=true mycurl –image=xxx -restart=Never –command –sh</li></ul></li></ul></li><li>服务通过label来找到对应的pod</li><li>自动伸缩（个数区间）<ul><li>kubectl autoscale deployment spittr –min=10 –max=15 –cpu-percent=80</li></ul></li><li>理解k8s中的service与中nacos的service的异同点<ul><li>通过一个服务名来访问多个动态的服务实例/pod</li><li>nacos的服务注册与发现与k8s的service可以二选一</li><li>nacos维护每个服务的元数据，服务的部署启动等需要借助底层的k8s</li></ul></li></ul><h2 id="10-REST服务、微服务开发与部署"><a href="#10-REST服务、微服务开发与部署" class="headerlink" title="10. REST服务、微服务开发与部署"></a>10. REST服务、微服务开发与部署</h2><ul><li>微服务架构模式的特征<ul><li>应用程序分解为具有明确定义了职责范围的细粒度组件</li><li>完全独立部署，独立测试，并可复用</li><li>使用轻量级通信协议，HTTP和JSON，松耦合</li><li>服务实现可使用多种编程语言和技术</li><li>将大型团队划分成多个小型开发团队，每个团队只负责他们各自的服务</li></ul></li><li>状态码<ul><li>1xx：表示服务器已接收了客户端的请求，客户端可以继续发送请求</li><li>2xx：表示服务器已成功接收到请求并进行处理</li><li>3xx：表示服务器要求客户端重定向</li><li>4xx：表示客户端的请求有非法内容</li><li>5xx：标识服务器未能正常处理客户端的请求而出现意外错误</li></ul></li><li>健康检查：添加actuator依赖<ul><li>localhost:8080/actuator/health</li></ul></li><li>运维实践<ul><li>除配置数据外，都在源代码库中</li><li>指定JAR依赖的版本号</li><li>配置与源代码分开，放在nacos中</li><li>已构建的服务是不可变的，不能再被修改</li><li>微服务应该是无状态的</li><li>并发，通过启动更多的微服务实例横向扩展，多线程是纵向扩展</li></ul></li></ul><h2 id="11-基于nacos的数据配置"><a href="#11-基于nacos的数据配置" class="headerlink" title="11. 基于nacos的数据配置"></a>11. 基于nacos的数据配置</h2><ul><li>基于nacos的配置管理来进行微服务开发<ul><li>添加依赖spring-cloud-starter-alibaba-nacos-config</li><li>在bootstrap.yml中定义nacos的访问地址、文件后缀名、服务名（用来组合dataId）</li><li>在ServiceConfig代码中获取某个属性的值@Value，及时获取最新配置数据@RefreshScope</li></ul></li><li>dataId的完整格式<ul><li>${prefix}-$(spring.profiles.active).${file-extension}</li><li>prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置，spring.profiles.active即为当前环境对应的profile</li><li>file-exetension为配置内容的数据格式，可以通过配置项spring.cloud.nacosconfig.file- extension来配置，目前只支持properties和yaml类型</li></ul></li></ul><h2 id="12-基于nacos的服务注册与发现"><a href="#12-基于nacos的服务注册与发现" class="headerlink" title="12. 基于nacos的服务注册与发现"></a>12. 基于nacos的服务注册与发现</h2><ul><li>服务发现的好处<ul><li>快速水平伸缩，而不是垂直伸缩，不影响客户端</li><li>提高应用程序的弹性</li></ul></li><li>spring cloud alibaba家族（spring cloud子项目）<ul><li>nacos</li><li>sentinel</li></ul></li><li>使用到的starter依赖<ul><li>服务配置: com.alibaba.cloud, spring-cloud-starter alibaba-nacos-config</li><li>服务注册: com.alibaba.cloud, spring-cloud-starter alibaba-nacos-discovery</li><li>客户端负载均衡: org.springframework.cloud, spring-cloud-starter-loadbalancer</li><li>简化客户端调用: org.springframework.cloud, spring-cloud-starter-openfeign</li></ul></li><li>调用服务的三种方式<ul><li>Spring DiscoveryClient</li><li>使用支持LoadBalanced的RestTemplate（可自动实现负载均衡）</li><li>使用OpenFeign (@FeignClient)（可自动实现负载均衡）<ul><li>OpenFeign是一 款造明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、 优雅地调用HTTP API</li></ul></li></ul></li><li>健康检查的机制<ul><li>临时实例的客户端主动上报机制，临时实例每隔5s发送一个心跳包给Nacos服务器端</li><li>永久实例的服务端反向探测机制，永久实例支持3种探测协议, TCP、HTTP 和MySQL,默认探测协议为TCP,也就是通过不断ping的方式来判断实例是否健康</li></ul></li><li>服务部署<ul><li>A向nacos获得B的IP地址和端口号，直接调用B</li></ul></li><li>实现基于nacos的服务注册与发现<ul><li>添加依赖com.alibaba.cloud, spring-cloud-starter alibaba-nacos-discovery；com.alibaba.cloud, spring-cloud-starter alibaba-nacos-config；org.springframework.cloud, spring-cloud-starter-openfeign；org.springframework.cloud, spring-cloud-starter-loadbalancer</li><li>在bootstrap.yml中定义nacos的访问地址</li><li>在启动类中添加注解@EnableFeignClients，@EnableDiscoveryClient</li><li>定义接口并添加注解@FeignClient(“&lt;服务名&gt;”)</li><li>将定义的接口注入并调用</li></ul></li></ul><h2 id="13-基于sentinel的流控与熔断"><a href="#13-基于sentinel的流控与熔断" class="headerlink" title="13. 基于sentinel的流控与熔断"></a>13. 基于sentinel的流控与熔断</h2><ul><li>定义资源<ul><li>代码直接定义</li><li>使用注释定义</li><li>自动定义</li><li>外置的文件只能定义规则不能定义资源</li></ul></li><li>规则的种类<ul><li>流量控制</li><li>熔断降级</li><li>系统保护</li><li>来源访问控制</li><li>热点参数</li></ul></li><li>熔断异常<ul><li>blockException</li></ul></li><li>熔断处理<ul><li>针对耗时长 / 业务本身的异常</li></ul></li><li>sentinel的组成<ul><li>控制台</li><li>服务核心库（java客户端）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 后端开发 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 微服务开发 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《面向服务的软件工程》复习笔记</title>
      <link href="/2023/04/05/NJU-Service-Oriented-Software-Engineering/"/>
      <url>/2023/04/05/NJU-Service-Oriented-Software-Engineering/</url>
      
        <content type="html"><![CDATA[<h2 id="1-服务、服务系统与面向服务的泛型"><a href="#1-服务、服务系统与面向服务的泛型" class="headerlink" title="1. 服务、服务系统与面向服务的泛型"></a>1. 服务、服务系统与面向服务的泛型</h2><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><ul><li>什么是服务<ul><li>为客户提供的非持久性的无形的体验</li><li>单一或一系列的活动，具有无形的天然属性，发生在客户和服务提供方的交互中，为客户提供解决方案</li></ul></li><li>服务模型 vs. 制造模式<ul><li>产出：服务 vs. 产品</li><li>交互：双向 vs. 单向</li></ul></li><li>制造和服务的融合<ul><li>以制造模式为主，更加定制化和长尾化</li><li>发展趋势越来越偏向于服务</li></ul></li><li>服务发展趋势<ul><li>单纯的制造持续减少，服务产业持续增长</li><li>服务变得越来越复杂（场景、规模、逻辑）</li><li>引入 <strong>IT 系统</strong>对服务的执行提供支撑（有无服务雇员均可）</li></ul></li></ul><h3 id="服务系统"><a href="#服务系统" class="headerlink" title="服务系统"></a>服务系统</h3><ul><li>服务系统<ul><li>用以实现业务服务的 IT 系统</li><li>只关注 IT 使能服务（包含 IT 服务和非 IT 服务）<ul><li>KPI（关键绩效指标）不同</li><li>需求管理不同</li><li>变化的步调不同</li></ul></li><li>大量的软件系统都是服务系统</li></ul></li><li>服务系统的问题<ul><li>服务系统的复杂性</li><li>服务系统的灵活性</li><li>专业化和外包模式</li><li>计算环境的演化</li><li>IT 专家和业务专家间的隔阂</li><li>新增价值和创新功能</li><li>系列有略微差异的服务系统（产品线）</li></ul></li></ul><h3 id="面向服务的泛型"><a href="#面向服务的泛型" class="headerlink" title="面向服务的泛型"></a>面向服务的泛型</h3><ul><li><p>命令式（过程式）泛型</p><ul><li>用程序状态和改变程序状态的语句来描述计算</li><li>对冯·诺依曼式计算机的顺序执行机制的直接抽象</li><li>由过程完成复用</li></ul></li><li><p>面向对象的泛型</p><ul><li>用封装了数据和操作的对象以及对象之间的消息传递描述计算</li><li>封装、继承、多态</li><li>为变化而设计<ul><li>使用设计模式（与泛型无关）</li></ul></li><li>最大的问题：对象所抽象的东西仍然是面向计算描述（实现）的<ul><li>底层实现逻辑的变化和上层实现接口变化都会使得对象发生变更和修改</li></ul></li></ul></li><li><p>基于构件的泛型</p><ul><li>构件：模块化的、可部署、可替换的软件系统组成部分（面向功能单位），封装了内部的具体实现并对外提供统一接口</li><li>将软件开发转变为：以构件的创建、构件的管理以及复用已有构件组装形成应用为基本活动</li><li>优点<ul><li>构件对外提供统一接口，针对特定业务功能进行抽象，业务接口极少发生变更</li><li>构件实现的功能单位比整个业务逻辑小很多</li></ul></li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230405205019654.webp" alt="image-20230405205019654" style="zoom:50%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230405205515301.webp" alt="image-20230405205515301" style="zoom: 40%;" /></li><li><p>面向服务的泛型</p><ul><li>服务：是自治、开放、自描述、与实现无关的网络构件</li><li>服务是中立的，独立于当前软件系统，独立于调用它的服务系统或应用</li><li>将软件开发转变为：：以服务的创建、服务的管理以及复用已有服务组装形成应用为基本活动</li><li>通过网络，使用标准方式互联（不再是共享代码和设计，而是共享计算）</li><li>服务：功能相关，简单且相对稳定，由 IT 专家开发；过程：应用相关，复杂多变，由业务专家开发，可以被封装为服务</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230405205949524.webp" alt="image-20230405205949524" style="zoom:50%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230405211506514.webp" alt="image-20230405211506514" style="zoom:40%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230405211536992.webp" alt="image-20230405211536992" style="zoom:40%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230405211611364.webp" alt="image-20230405211611364" style="zoom:40%;" /></li></ul><h2 id="2-服务生态系统与面向服务的计算"><a href="#2-服务生态系统与面向服务的计算" class="headerlink" title="2. 服务生态系统与面向服务的计算"></a>2. 服务生态系统与面向服务的计算</h2><h3 id="服务生态系统"><a href="#服务生态系统" class="headerlink" title="服务生态系统"></a>服务生态系统</h3><ul><li>服务组合<ul><li>面向服务的应用逻辑，遵循面向服务的设计原则，采用服务和服务组合加以实现</li><li>服务组合由多个装配在一起的服务所构成，用以提供业务任务或过程进行实现的功能</li><li>面向服务倾向于将服务打造成无关的企业资源，一个服务可以被多个消费者程序调用，能在不同的服务组合中组合同一个服务</li></ul></li><li>服务库存<ul><li>在组织或组织的合理部分边界内，一组独立标准化并治理的完备服务</li><li>服务库存可以按照服务模型进行分层<ul><li>应用服务层（必要）</li><li>业务服务层（必要）：以任务为中心 / 以实体为中心</li><li>编排服务层（可选）</li></ul></li><li>在构建前，服务库存的蓝图应当已经设计完毕</li><li>演化（按需开发，龙卷风模型：可重用的东西越来越多）<ul><li>初始服务交付项目</li><li>混合应用和成长中的服务库存</li><li>服务库存基本构建完毕</li></ul></li></ul></li><li>服务生态系统<ul><li>分析、设计、实现、治理、演化 $$\rightarrow$$ 构建起服务生态系统</li><li>从消费者角度出发<ul><li>垂直服务：可被同时、独立调用，用以满足消费者需求的服务</li><li>垂直服务可由多个可重用的跨领域的公共服务，即水平服务，构成</li><li>垂直服务和水平服务不是互斥的，只要在某一场景下被消费者直接调用即是垂直服务</li></ul></li></ul></li></ul><h3 id="面向服务的计算"><a href="#面向服务的计算" class="headerlink" title="面向服务的计算"></a>面向服务的计算</h3><ul><li>面向服务的计算<ul><li>从泛型角度出发<ul><li>面向服务的计算（SOC）是一种新型计算泛型，该泛型以服务作为基本概念以支持快速和低成本开发，和异构环境中分布式应用的灵活组合</li></ul></li><li>从软件架构角度出发<ul><li>面向服务的计算（SOC）是一组使用面向服务的架构（SOA）来表达计算的概念、原理和方法</li><li>在面向服务的架构（SOA）中，使用带有标准接口的独立构件服务来构造软件应用</li></ul></li><li>从服务的角度出发<ul><li>面向服务的计算（SOC）涵盖了运用计算机和信息技术建模、创建、操作和管理业务服务的科学与技术，从而在业务服务和 IT 服务之间建立连接，进一步改进业务服务</li></ul></li><li>从软件工程的角度出发<ul><li>面向服务的计算（SOC）涵盖了使用服务作为基本抽象元素，采用工程化方法，对服务系统进行分析、设计、开发、测试、部署、管理等活动所涉及的理论、技术和方法</li><li>面向服务的分析 vs. OOA</li><li>面向服务的设计 vs. OOD</li><li>面向服务的实现 vs. OOP</li><li>服务测试、部署和管理</li></ul></li></ul></li><li>面向服务的目标<ul><li>技术目标：灵活程度；鲁棒性；可扩展性；业务和技术的相关性；复用和可重用性</li><li>商业指标：实现供应商中立；潜在的可互操作性；企业灵活的组织化；形成商业联盟；降低 IT 成本；提高业务和技术的一致性；增加投资回报率</li></ul></li></ul><h2 id="3-面向服务的架构和-Web-Service"><a href="#3-面向服务的架构和-Web-Service" class="headerlink" title="3. 面向服务的架构和 Web Service"></a>3. 面向服务的架构和 Web Service</h2><h3 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h3><ul><li><p>SOA 架构</p><ul><li><p>从架构方面整体支持面向服务泛型的基本概念性架构模型</p></li><li><p>一种业务-IT 结合的方法，应用依赖于现有的服务来实现业务过程</p></li><li><p>实现 SOA 主要包括：</p><ul><li>面向服务的企业</li><li>采用服务开发应用</li><li>采用服务对应用进行封装，便于复用</li></ul></li><li><p>SOA 三角操作模型（引入第三方消除服务提供方和调用者间的紧耦合，可支持运行时确认服务提供者）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406003527432.webp" alt="image-20230406003527432" style="zoom:33%;" /></li></ul></li><li><p>SOA 的特点</p><ul><li><p>SOA 的好处</p><ul><li>从 IT 的角度<ul><li>松耦合，消除假依赖（复用）<ul><li>语言、平台、厂商中立</li><li>消除时间依赖</li><li>消除访问地址依赖</li><li>消除访问协议依赖</li></ul></li><li>服务间接寻址（灵活）</li></ul></li><li>从业务角度出发<ul><li>保护企业投资，提高 IT 资源作用，促进 IT 资源复用</li><li>提升企业灵敏度</li><li>支持企业外包管理模式</li></ul></li></ul></li><li><p>从“双角度”出发的 SOA</p><ul><li><p>在不同粒度上提供了本质性的指导：业务层、过程层、中间件层、编程层</p></li><li><p>在每个层次中按照“自顶向下”方式，将较大单元分解为较小的、以服务为中心的单元</p></li><li><p>在每个层次中按照“自底向上”方式，将可使用的较小单元组织成较大单元，提供全新服务</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406005829545.webp" alt="image-20230406005829545" style="zoom:40%;" /></li></ul></li></ul></li><li><p>SOA 参考架构</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406010014190.webp" alt="image-20230406010014190" style="zoom:40%;" /><ul><li>水平层：对功能性需求加以满足<ul><li>服务提供者（后台）<ul><li>操作型系统层：现存的打包应用 / 客户应用 / 遗留系统</li><li>服务组件层<ul><li>实现服务的代码容器</li><li>向下依赖于操作型系统层中的打包组件，向上依赖于服务层中的服务和业务过程层的业务过程</li><li>实现方式包括 Java 类、EJB、.NET 组件等</li><li>可能实现多个方法，但只有一部分会被封装成服务</li><li>从调用角度出发，负责完成输入转换和输出配置的自动化逻辑</li></ul></li><li>服务层（公共部分）<ul><li>将 SOA 三角操作模型扩展为综合逻辑层次，以支持服务注册、服务分解、服务发现、服务绑定、接口聚合和生命周期管理</li><li>以服务簇为核心概念</li><li>负责定位合适的服务提供者，并绑定到具体的目标服务接口</li><li>以服务组合的形式提供新的服务</li></ul></li></ul></li><li>服务消费者（前台）<ul><li>服务层（公共部分）</li><li>业务过程层<ul><li>以组合和分解的方式来处理业务逻辑</li><li>采用业务流程构建 SOA 解决方案</li><li>主要组合方式（两者在能力上是等价的）<ul><li>编排：引入中心协调者（主流方式）</li><li>编导：没有中心协调者，根据脚本完成协作</li></ul></li></ul></li><li>消费者层</li></ul></li></ul></li><li>垂直层：提供系统支持机制、满足非功能性需求<ul><li>集成层<ul><li>在服务请求者和服务提供者之间，完成服务请求的中介、路由和转换</li><li>ESB</li></ul></li><li>服务质量层（QoS）<ul><li>从各方面提供解决方案层级的 QoS 管理</li><li>不关注服务层级的 QoS 控制，着眼于为解决方案层级的 QoS 控制提供支持、跟踪、监视和管理</li></ul></li><li>数据架构层<ul><li>方便集成来自不同开发方的服务，为领域相关的数据架构提供统一的表达和支持机制</li></ul></li><li>治理层<ul><li>提供用以确保 SOA 解决方案的设计原则</li></ul></li></ul></li></ul></li></ul><h3 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h3><p>SOA 是概念层级的架构模型，其他技术都能用来实现 SOA 模型，如组件没服务、REST 服务等</p><ul><li><p>Web Service：面向服务事实上的行业协议（基于 Web Service 的 SOA）</p><ul><li>XML 定义数据并完成信息交换</li><li>XML schema 定义数据结构</li><li>Namespace 使得 XML 元素全球可用</li><li>SOAP 定义平台 / 技术无关的消息传递方式</li><li>WSDL 定义平台 / 技术无关的服务能力/调用方式，使得构建服务簇和服务仓库成为可能</li><li>WS-BPEL / WS-CDL 使用 XML 脚本，以平台 / 技术无关的方式定义服务组合</li><li>UDDI，WSIL 完成服务的发布和查找</li><li>WS-* 满足各种应用的非功能性需求</li></ul></li><li><p>Web Service 协议架构</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406014443720.webp" alt="image-20230406014443720" style="zoom:50%;" /></li><li><p>Web Service 抽象模型</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406014859429.webp" alt="image-20230406014859429" style="zoom: 40%;" /></li><li><p>Web Service 开发环境</p></li></ul><h2 id="4-XML-及相关协议"><a href="#4-XML-及相关协议" class="headerlink" title="4. XML 及相关协议"></a>4. XML 及相关协议</h2><h3 id="面向服务中的信息交换和数据类型"><a href="#面向服务中的信息交换和数据类型" class="headerlink" title="面向服务中的信息交换和数据类型"></a>面向服务中的信息交换和数据类型</h3><ul><li><p>电子信息交换</p><ul><li>应用内部（intra=application）</li><li>应用之间（inter-application）</li><li>系统之间（inter-system）</li><li>公司之间（inter-company）</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406122034924.webp" alt="image-20230406122034924" style="zoom:33%;" /></li><li><p>电子信息交换方式</p><ul><li>基于二进制的方式（与实现紧密相关）</li><li>XML（平台中立，语言中立，基于文本结构，能表达复杂数据结构）<ul><li>描述服务（接口及流程），查询服务的服务需求，服务的调用请求，其他在面向服务的计算中需要执行的信息交换</li><li>使用 XML Schema 脚本来对 XML 消息进行验证</li></ul></li></ul></li></ul><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul><li><p>XML 的概念和特点</p><ul><li>满足良好定义规则的格式化文本</li><li>XML 文档主要由标签和文本构成（树形）</li><li>XML 文档可以以 HTTP 消息 / 编程语言字符串 / 数据库 CLOB /其他文本数据的形式存储和展现</li></ul></li><li><p>XML 的良好格式化与合法性</p><ul><li><p>单根元素：单根树状结构而非森林结构</p></li><li><p>元素标签规则：&lt;label&gt;xxx&lt;/label&gt;，&lt;label attr=“xxx”&gt;xxx&lt;/label&gt;，&lt;label attr=“xxx” /&gt;，&lt;label /&gt;</p></li><li><p>元素嵌套规则：子元素未关闭时不能关闭父元素</p></li><li><p>元素规则</p><ul><li>首字母，大小写敏感，不含有空格，不含有“xml”作为前缀</li><li>PCDATA（默认使用）：解析时需对预定义实体进行转义</li><li>CDATA（在 XML 中嵌套其他语言的文本）：&lt;![CDATA[xxx]]&gt; 不被解析，按字面意思处理</li></ul></li><li><p>元素属性</p></li><li><p>XML 声明：可选，出现的 XML 文档第一行，描述一致性</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406130837525.webp" alt="image-20230406130837525" style="zoom: 33%;" /></li><li><p>合法的 XML 文档持有一个额外的词汇表，并遵循该表所定义的结构化规则（XML Schema / DTD）</p></li></ul></li></ul><h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><ul><li><p>名称空间的作用和概念</p><ul><li>解决元素和属性名称冲突</li><li>从概念上将元素和属性表达为“URI+名称”的形式，在全球范围内解决名称冲突问题</li><li>作为前缀的 URI 被称为名称空间</li><li>为了保证 XML 的格式良好，使用别名来代表 URI</li></ul></li><li><p>名称空间的语法</p><ul><li><p>QNames $$\rightarrow$$ prefix : localPart</p></li><li><p>声明并使用名称空间</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">books:book</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:books</span>=<span class="string">&#x27;http://www.libaray.com/books&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="attr">books:hadcover</span>=<span class="string">&#x27;true&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>名称空间前缀的作用域：定义该名称空间的元素（含嵌套子元素和所隶属的属性），除非子元素中重新定义了名称空间</p></li><li><p>默认名称空间（只作用于子元素，不做用于属性，属性默认没有名称空间）</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">xlmns</span>=<span class="string">&#x27;http://www.libaray.com/books&#x27;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:books</span>=<span class="string">&#x27;http://www.libaray.com/books&#x27;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">books:hadcover</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>重置默认名称空间</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">xlmns</span>=<span class="string">&#x27;http://www.libaray.com/books&#x27;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:amazon</span>=<span class="string">&#x27;http://www.amazon.com/products&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">isbn</span> <span class="attr">xlmns</span>=<span class="string">&#x27;&#x27;</span>&gt;</span>xxxxxxx<span class="tag">&lt;/<span class="name">isbn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">amazon:skuNo</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">amazon:skuNo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h3><ul><li><p>XML Schema 的作用和概念</p><ul><li>增加数据的表示能力，使用统一的数据结构表示方式，节省通信和集成的成本</li><li>采用 XML 语法来定义数据结构和约束条件，支持名称空间，能够表达数据元素之间的关系，对 XML 文档进行验证</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406140042633.webp" alt="image-20230406140042633" style="zoom:40%;" /></li><li><p>XML Schema 的语法和机制</p><ul><li><p>XML Schema 类型系统</p><ul><li><p>简单类型：不含有属性或子元素，原子类型，可用于定义其他类型，有40余种预定义的简单类型</p></li><li><p>复杂类型：可以含有属性、子元素，可用于定义其他复杂类型，不能用于定义其他简单类型</p></li><li><p>定义新的简单类型</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&#x27;quantityType&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&#x27;xsd:Integer&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:minInclusive</span> <span class="attr">value</span>=<span class="string">&#x27;2&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:maxInclusive</span> <span class="attr">value</span>=<span class="string">&#x27;5&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&#x27;quantity&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;quantityType&#x27;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&#x27;color&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&#x27;quantityType&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&#x27;xsd:string&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&#x27;red&#x27;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&#x27;green&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&#x27;blue&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>排序符</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span><span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:choice</span>&gt;</span><span class="tag">&lt;/<span class="name">xsd:choice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:all</span>&gt;</span><span class="tag">&lt;/<span class="name">xsd:all</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>含有属性的元素</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406144830717.webp" alt="image-20230406144830717" style="zoom:33%;" /></li></ul></li><li><p>将 XML Schema 定义的元素与名空间进行关联</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406145227500.webp" alt="image-20230406145227500" style="zoom:33%;" /></li><li><p>寻找 XML Schema</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406145331268.webp" alt="image-20230406145331268" style="zoom:33%;" /></li></ul></li></ul><h2 id="5-Web-Service-核心"><a href="#5-Web-Service-核心" class="headerlink" title="5. Web Service 核心"></a>5. Web Service 核心</h2><h3 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h3><ul><li><p>SOAP 的作用和概念</p><ul><li>通过网络来传递 XML 消息</li><li>提供了一种标准的方法，使运行在不同平台、使用不同的技术和编程语言的应用程序可以互相进行通信</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406150231287.webp" alt="image-20230406150231287" style="zoom:33%;" /><ul><li><p>从概念上提供了单向的、不带状态的消息交互范式</p></li><li><p>提供了以可扩展的方式传送应用相关信息的架构</p></li><li><p>提供了 SOAP 节点在接收到 SOAP 消息后所需执行的必要操作</p></li><li><p>不关心所携带相关数据的语义（envelope）</p></li><li><p>不关心 SOAP 消息路由、可靠消息传输、防火墙穿透等底层相关事项</p></li><li><p>SOAP 的使用方式（处理模式）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406150844211.webp" alt="image-20230406150844211" style="zoom:33%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406150909081.webp" alt="image-20230406150909081" style="zoom:33%;" /></li><li><p>SOAP 的交互模式</p><ul><li>RPC 模式：同步的请求 / 应答交互模式；发送请求并等待响应</li><li>面向文档模式：异步交互模式；发送复杂的 XML 文档并等待通知，结果会在处理后发回</li></ul></li></ul></li><li><p>SOAP 的语法和机制</p><ul><li><p>SOAP 的结构</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406151517635.webp" alt="image-20230406151517635" style="zoom:33%;" /></li><li><p>SOAP 绑定</p><ul><li>在抽象的消息交互框架中，SOAP 消息需要使用底层协议完成传输</li><li>SOAP 绑定完成 SOAP 消息的封装、处理和传输（如 HTTP、SMTP、MIME、HTTPS 绑定等）</li></ul></li><li><p>SOAP 的处理模型</p><ul><li>用 XML 打包请求<ul><li>将接口名作为根节点</li><li>方法和参数作为结点</li></ul></li><li>将请求发给服务器<ul><li>不创建自己的 TCP/IP 信息，利用 HTTP</li><li>将请求封装成 HTTP POST 请求格式发出</li></ul></li><li>服务器接收到请求，解码 XML，处理请求，以 XML 格式返回响应<ul><li>与请求比较，方法的结点名字变为请求的方法名后缀 Response</li><li>客户程序知道自己调用了哪个方法，根据方法名后缀 Response 寻找调用方法的返回值</li></ul></li></ul></li></ul></li><li><p>思考：SOAP 为什么被设计成两块？实际 SOAP 如何利用这两个信道？</p><ul><li>被设计成 header 和 body 两块，一方面分离了控制信息和主要数据，让信息结构更加清晰；另一方面，在复杂模式中，header 中的头块信息可以和中间节点进行角色上的转变</li><li>body是必须的部分，内嵌的 XML 是完成当前任务的主要数据；而如果是⼀些附加的、用来协助完成的控制信息，则放在 header 中</li></ul></li></ul><h3 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h3><ul><li><p>WSDL 的作用和概念</p><ul><li><p>提供了一种基于 XML 的标准接口定义语言/服务能力定义语言，用以在服务的提供者/调用者/服务注册之间，交换必要的有关 Web Service 的信息</p></li><li><p>可能携带了关于 Web Service的足够信息，也可能不够（商业上 / 技术上）</p></li><li><p>用以描述网络服务的 XML 格式，将服务描述为基于消息（面向文档 / 面向过程）运作的端点集合</p></li><li><p>回答了：服务是用来干什么 / 服务在哪 / 如何调用，这三个问题</p></li><li><p>提供了：功能 / 消息结构 / 协议绑定（抽象消息映射为具体网络传输）</p></li><li><p>通常与 SOAP 和 XML Schema 同时使用</p></li><li><p>WSDL 2.0 信息集</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406223648809.webp" alt="image-20230406223648809" style="zoom:33%;" /><ul><li>以 description 元素为根结点</li><li>import、include：拼装不同部门/组织定义的文档，形成完整的 WSDL 语义</li><li>抽象部分<ul><li>Types：定义消息结构，即使用到的数据结构 / 数据格式规范，独立于语言和平台</li><li>Interface：operation 的集合，即服务能力的集合，描述服务能力<ul><li>operation：input、output、infault、outfault</li></ul></li></ul></li><li>具体部分<ul><li>Binding：把抽象的消息格式转换为具体的消息格式，即特定端口类型的具体协议和数据格式规范的绑定</li><li>Service：对服务整体的抽象，包含若干个endpoint<ul><li>endpoint：将绑定与当前地址关联</li></ul></li></ul></li></ul></li></ul></li><li><p>WSDL 的语法和机制</p><ul><li><p>定义 WSDL2.0 目标名空间</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406223823828.webp" alt="image-20230406223823828" style="zoom:33%;" /></li><li><p>定义消息类型</p><ul><li>内嵌式</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406223935423.webp" alt="image-20230406223935423" style="zoom:33%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406224002908.webp" alt="image-20230406224002908" style="zoom:33%;" /><ul><li>使用 XML Schema 的 import（不同名空间之间）或 include（相同名空间）机制</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406224030605.webp" alt="image-20230406224030605" style="zoom:33%;" /></li><li><p>定义接口</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406224819338.webp" alt="image-20230406224819338" style="zoom:33%;" /><ul><li><p>四种基本 MEP</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406224900007.webp" alt="image-20230406224900007" style="zoom:33%;" /></li></ul></li><li><p>定义绑定</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406230458601.webp" alt="image-20230406230458601" style="zoom:33%;" /></li><li><p>定义服务</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406230543233.webp" alt="image-20230406230543233" style="zoom:33%;" /></li><li><p>WSDL 中的 RPC 风格</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406230909940.webp" alt="image-20230406230909940" style="zoom:33%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406230933229.webp" alt="image-20230406230933229" style="zoom:33%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406230958168.webp" alt="image-20230406230958168" style="zoom:33%;" /></li></ul></li><li><p>服务簇和 WSDL 版本差异</p><ul><li><p>服务簇中的服务，共享相同的抽象部分，具体部分采用不同的绑定、地址和实现方式</p></li><li><p>WSDL 1.1 vs. WSDL 2.0</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406231215450.webp" alt="image-20230406231215450" style="zoom:40%;" /></li></ul></li></ul><h2 id="6-Web-Service-扩展"><a href="#6-Web-Service-扩展" class="headerlink" title="6. Web Service 扩展"></a>6. Web Service 扩展</h2><h3 id="服务发布和查询"><a href="#服务发布和查询" class="headerlink" title="服务发布和查询"></a>服务发布和查询</h3><ul><li><p>UDDI 的作用和概念</p><ul><li><p>用来发布和查找 Web Service 的元服务</p></li><li><p>采用 XML 格式存放注册 Web Service 的描述信息</p><ul><li>业务的基本信息</li><li>分类信息</li><li>注册信息</li><li>服务接口的注册引用及其他属性</li></ul></li><li><p>使用注册实体记录 Web Service 的发布信息</p><ul><li>白页：名称、地址、具体联系方式等基本信息</li><li>黄页：针对业务或服务进行分类的信息</li><li>绿页：服务中的技术性信息</li></ul></li><li><p>UDDI 的主要元素</p><ul><li>businessEntitiy：商业实体的信息及其所提供的服务（对商业实体的抽象）</li><li>businessService：商业实体所提供的服务（对服务进行抽象）</li><li>bindingTemplate：如何调用一个服务（对调用服务方式的抽象）</li><li>Technical Models (tModel)：特定的概念和结构（对绿页的抽象）</li><li>publisherAssertion：表达商业关系</li></ul></li><li><p>UDDI 的工作流</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406233141268.webp" alt="image-20230406233141268" style="zoom:40%;" /></li></ul></li><li><p>UDDI 的语法和机制</p><ul><li><p>略</p></li><li><p>从 WSDL 到 UDDI 的映射</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230406234140637.webp" alt="image-20230406234140637" style="zoom:33%;" /></li></ul></li><li><p>使用 UDDI 进行 Web Service 的发布和查询</p><ul><li>Web Service实现后（部署在通过网络能够访问的应用服务器），为了方便消费者使用，需要通过网络将服务发布在服务注册</li><li>服务注册需要为服务调用者提供用以发现服务提供者极其所提供的 Web Service 的相关信息（无需提供具体实现）：<ul><li>服务名称</li><li>服务提供者名称</li><li>用来描述该服务的 WSDL 文件的 URL（作为服务合约的入口）</li></ul></li><li>服务消费者使用 UDDI 客户端来查询 UDDI 注册中的 Web Service</li><li>UDDI API<ul><li>对于分类、编目和管理Web服务，UDDI 注册库提供了一个标准方式，以便于能够发现和使用这些Web服务<ul><li>业务和提供者可以按标准方式使用UDDI来表示Web服务信息</li><li>UDDI 使用 SOAP 作为它的传输层</li></ul></li><li>UDDI API 是-一个接口，可以接受封装在 SOAP 信封中的 XML 消息<ul><li>所有的 UDDI 交互都使用请求 / 响应模式</li><li>可以使用出查询API来搜索和读取 UDDI 注册库中的数据，并可使用发布 API 来添加、更新和删除 UDDI 注册库中的数据</li></ul></li></ul></li><li>UDDI 发布 API<ul><li>授权：客户端可以获得相应的访问权限、获取授权令牌、终止会话和授权令牌<ul><li>get_authtoken：将客户端记录到注册</li><li>discard_authtoken：终止会话，并从注册库中删除客户端</li></ul></li><li>保存：客户端可以在 UDDI 中添加或更新信息</li><li>获取：可以获取客户端所发布的数据结构的概要数据</li><li>删除：客户端可以在 UDDI 中删除信息</li></ul></li><li>UDDI 查询 API<ul><li>浏览<ul><li>开发者可以使用浏览模式（发现 API 调用）来获取满足比较宽泛的查询标准的接入点、服务或者技术特性</li><li>浏览模式中，可以使用 find_business、find_relatedBusiness、find_service、find_binding 和 find_tModel 操作</li></ul></li><li>下钻<ul><li>使用下钻模式（获取API调用）来获取更具体的功能部件</li><li>下钻模式中，可以使用 get_businessDetail、get_BusinessDetailExt、get_serviceDetail、get_bindingDetail 和 get_tModelDetail操作</li></ul></li></ul></li></ul></li></ul><h3 id="WS-协议"><a href="#WS-协议" class="headerlink" title="WS-* 协议"></a>WS-* 协议</h3><ul><li><p>WS-* 的作用和概念</p><ul><li>略</li></ul></li><li><p>BPEL</p><ul><li>为什么需要复合服务（复用 &amp; 灵活）<ul><li>有些服务是垂直的，有些是水平的。为保证复用性，某些垂直服务被设计为由水平服务构造而来</li><li>如果活动由服务实现，那么由活动构成的（商业）流程由复合服务实现</li></ul></li><li>如何实现复合服务<ul><li>在传统编程环境中，调用子服务，再把编程单元封装成服务以供调用</li><li>采用标准协议的 XML 脚本描述服务组合方式</li></ul></li></ul></li><li><p>WS-Addressing</p><ul><li><p>Web Service 中的消息分发</p><ul><li>为了正确处理,消息接收者必须具备识别所需要调用的 Web Service 的能力</li><li>由于在 WSDL 中没有定义，服务提供者在开发服务时需要自己来区分消息的不同类型<ul><li>在单个地址上部署单个服务时，采用 XSD，为不同的服务能力的不同消息说明不同的 QNames</li><li>在单个地址上部署多个服务时， 必须在全局考虑所有服务中的消息类型</li></ul></li><li>如服务提供者不能达成上述目标,尤其在使用通配类型（#any, #none）时，必须提供消息分发机制</li><li>在带状态的 Web Service 中，也需要消息分发机制来识别同一服务的不同实例</li></ul></li><li><p>WS-Addressing 请求</p><ul><li>随机生成全局 ID 唯一标记当前会话进程</li><li>为 WSDL 定义的操作引入一个字段 Action，用以区分不同操作</li><li>在 SOAP 消息中增加 Go 字段，包含请求消息的相关信息</li><li>在 SOAP 消息中增加 Back 字段，包含响应请求消息的相关信息</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230407105025274.webp" alt="image-20230407105025274" style="zoom:33%;" /></li><li><p>WS-Addressing 响应</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230407105644464.webp" alt="image-20230407105644464" style="zoom:33%;" /></li><li><p>有状态和无状态的 Web Service</p><ul><li>无状态的 Web Service<ul><li>不获取和维护状态</li><li>无上下文</li><li>扩展性好、容错性好</li><li>轻量级</li></ul></li><li>有状态的 Web Service<ul><li>为不同消费者服务，提供个人化服务</li><li>持有状态</li><li>支持需要协作的复杂服务</li><li>需要更多编码和额外处理资源</li></ul></li></ul></li></ul></li><li><p>Web Service 资源框架（WSRF）</p><ul><li>定义带有资源的有状态的 Web Service</li><li>包含四组用来通过 Web Service 接口访问内部状态的接口<ul><li>WS-ResourceProperties</li><li>WS-ResourceLifetime</li><li>WS-BaseFault</li><li>WS-ServiceGroup</li></ul></li><li>支持资源属性的动态创建</li><li>支持资源的销毁<ul><li>立刻销毁</li><li>基于时间的计划销毁</li></ul></li></ul></li><li><p>WS-Security</p><ul><li><p>WS-Security SOAP 消息结构</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230407110937713.webp" alt="image-20230407110937713" style="zoom:33%;" /></li></ul></li><li><p>WS-Coordination</p><ul><li>用来发起、支持、完成多方参与、多消息的 Web service 协作的通用机制</li><li>定义了协作服务和协作上下文，是协作 Web service 交互的框架</li></ul></li></ul><h2 id="7-服务生态系统的构建"><a href="#7-服务生态系统的构建" class="headerlink" title="7. 服务生态系统的构建"></a>7. 服务生态系统的构建</h2><h3 id="面向服务的分析"><a href="#面向服务的分析" class="headerlink" title="面向服务的分析"></a>面向服务的分析</h3><p><strong>目标</strong></p><ul><li>讨论需要构建哪些服务，每个服务需要封装哪些逻辑</li></ul><p><strong>核心</strong></p><ul><li>业务服务（隔离业务领域和应用领域的变化，服务编排的对象，实现复用，促进面向服务）</li></ul><p><strong>流程</strong></p><ul><li>定义流程自动化需求（文档化的需求描述为服务候选建模的依据）</li><li>识别现有的自动化系统（确保服务边界不重叠）</li><li>对服务候选建模（识别服务操作候选，并将其分组）</li></ul><p><strong>业务分析方法</strong></p><ul><li>业务流程管理模型（BPM）</li><li>实体模型</li></ul><p><strong>业务服务派生类型</strong></p><ul><li>以任务为核心：灵活，较少分析工作，需对多个用例和业务流程模型进行分析以识别公共性，复用潜力有限</li><li>以实体为核心：稳定，较多分析工作，不包含业务流程逻辑，复用潜力高</li></ul><p><strong>业务服务与编排</strong></p><ul><li>组合以任务为核心的业务服务及以实体为核心的业务服务</li><li>在不影响业务服务和应用服务的前提下进行业务规则和业务逻辑的变更</li></ul><h3 id="面向服务的设计"><a href="#面向服务的设计" class="headerlink" title="面向服务的设计"></a>面向服务的设计</h3><p>从服务候选（逻辑）派生出具体的服务设计（物理），然后装配到实现业务流程的抽象组合中</p><p><strong>设计过程</strong></p><ul><li><p>组合 SOA：</p><ul><li><p>选择服务层</p></li><li><p>定义核心的 SOA 标准</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230404111031807.webp" alt="image-20230404111031807" style="zoom:50%;" /><ul><li>WS-I</li></ul></li><li><p>选择SOA扩展</p><ul><li>选择 SOA 特征</li><li>选择 WS-* 标准</li><li>选择 BPEL</li></ul></li></ul></li><li><p>设计服务</p><ul><li>以实体为核心的业务服务设计<ul><li>业务服务候选</li><li>审查现存服务（确保新服务没有已经被实现）</li><li>定义消息 schema 类型，并在 WSDL 中导入</li><li>提取抽象服务接口（确保服务候选操作适当；在 WSDL 文件中创建 portType/interface 并定义 operation；通过 message 元素和 part 子元素引用 XSD schema 类型讲提供给每个操作的逻辑处理所需输入输出值形式化）</li><li>应用面向服务原则（可复用，自治，无状态，可发现）</li><li>标准化并完善接口服务（审查并应用现存设计标准和原则；修订服务设计；验证 WS-I 基本概要的一致性要求）</li><li>扩展服务设计（添加新操作，添加新参数）</li><li>识别必要处理（进一步识别应用服务）</li><li>最终的抽象服务定义</li></ul></li><li>应用服务设计<ul><li>应用服务候选</li><li>审查现有服务（避免服务内冗余；考虑使用第三方服务）</li><li>确认上下文（重新评估服务候选中的候选操作分组）</li><li>提取初始服务接口</li><li>应用面向服务原则</li><li>标准化并提炼服务接口</li><li>为服务候选引入推理性特性</li><li>识别技术约束（物理接入点，安全性约束，响应时间，底层系统可用性，部署位置相关的环境因素，底层应用逻辑的技术限制，管理需求，潜在的 SLA 需求）</li><li>最终的抽象服务定义</li></ul></li><li>以任务为核心的业务服务设计<ul><li>业务服务候选</li><li>定义工作流逻辑</li><li>提取服务接口</li><li>应用面向服务原则</li><li>标准化并完善服务接口</li><li>识别需要的处理</li><li>最终的抽象服务定义</li></ul></li></ul></li><li><p>设计面向服务业务过程，组合服务构建出业务流程</p><ul><li>面向服务的业务流程设计<ul><li>技术分析师和系统架构师来图形化地创建代表它们的工作流逻辑的业务流程图，并自动转化并对应到 BPEL 脚本</li><li>更加自动化的工具使得业务分析师可以在不了解 BPEL 的前提下，完成流程的设计</li></ul></li></ul></li></ul><h2 id="8-面向服务设计的原则"><a href="#8-面向服务设计的原则" class="headerlink" title="8. 面向服务设计的原则"></a>8. 面向服务设计的原则</h2><p><strong>目的</strong></p><ul><li>提高内在互操作性</li><li>增强联合</li><li>增加厂商多样化选择</li><li>提高业务和技术的一致性</li><li>提高投资回报率</li><li>提高组织敏捷度</li><li>降低 IT 负担</li></ul><h3 id="标准化服务合约"><a href="#标准化服务合约" class="headerlink" title="标准化服务合约"></a>标准化服务合约</h3><p><strong>服务可组合性</strong></p><ul><li><p>遵循相同标准，使用相同风格</p><ul><li>服务功能描述的标准化</li><li>服务数据表示的标准化<ul><li>避免非标准化数据间的频繁数据转换</li><li>schema 被单独设计和实现，与使用它的服务操作分离</li><li>采用“<strong>schema 集中化</strong>”的设计模式，对每个信息集合定义“官方”schema</li><li>可以将一个企业划分为多个分离的领域，每个领域都可以被独立地进行标准化和治理</li><li>除集中式的Schema外，定义特定服务相关的额外 schema 时，可引用和封装现有 schema 脚本</li></ul></li><li>服务策略标准化<ul><li>WS-Policy 定义为服务合约添加了一个单独的潜在抽象层次</li><li>使得逻辑能以单独的策略断言的形式存在于物理上独立的策略定义文档中</li><li>多层次的标准化</li></ul></li></ul></li><li><p>标准化服务合约在服务设计中的应用</p><ul><li>数据表示标准化和转换的避免</li><li>标准化与粒度<ul><li>以任务为核心的业务服务：粗粒度</li><li>以实体为核心的业务服务：细粒度</li></ul></li><li>标准化服务合约与服务模型<ul><li>通用类型模板</li><li>为同一种服务模型应用同一组设计标准和命名惯例</li></ul></li><li><strong>标准化服务合约设计与其他原则</strong></li><li>服务合约设计相关风险<ul><li>版本化（服务合约的演化）</li><li>技术依赖</li><li>开发工具缺陷</li></ul></li></ul></li></ul><h3 id="服务松散耦合"><a href="#服务松散耦合" class="headerlink" title="服务松散耦合"></a>服务松散耦合</h3><p><strong>最小化依赖关系</strong></p><ul><li>服务合约耦合的类型<ul><li>“逻辑-合约”耦合（积极耦合）<ul><li>合约优先，服务逻辑对服务合约的紧密耦合</li><li>服务合约对服务逻辑无耦合，在相同的服务合约下，可以替换或修改服务逻辑</li></ul></li><li>“合约-逻辑”耦合（消极耦合）<ul><li>从现有的方案逻辑当中生成 Web Services，自动生成合约和数据结构</li><li>增加技术、功能和实现的耦合级别</li><li>缩短服务合约生命周期并限制服务的长期演化</li></ul></li><li>“合约-技术”耦合（消极耦合）<ul><li>后台的实现技术方案/调用的通讯协议被反映到服务合约中</li><li>暴露后台实现方式，技术不能进行灵活变更</li></ul></li><li>“合约-实现”耦合（消极耦合）<ul><li>底层实现依赖于特定编程环境中的特定实现机制（物理数据库和相关的物理数据模型、遗留系统API、用户和群组账户以及相关的物理目录结构、物理服务器环境和相关的域名、文件名和网络路径）</li><li>实现相关的特性和细节可能会在服务合约的内容中体现出来</li></ul></li><li>“合约-功能”耦合（消极耦合）<ul><li>由一个服务所封装的逻辑被专门设计为支持服边界之外的功能体（上层进程耦合、”服务-消费者”耦合、任务服务（特意的功能耦合））</li><li>缺乏可复用性，但若本身就不需要被复用则可以允许产生”合约-功能”耦合</li></ul></li><li>“消费者-实现”耦合（消极耦合）<ul><li>没有隐藏实现细节，消费者绕过服务合约，直接使用其他入口访问服务</li></ul></li><li>“消费者-合约”耦合（积极耦合）<ul><li>本质上形成了松散耦合跨服务关系的基础</li><li>会产生多种直接和间接耦合场景</li><li><strong>合约集中化</strong>和技术耦合<ul><li>采用合约集中化，将对服务的访问控制在合约内</li><li>没有使用类似 Web Service 的开放技术平台的情况下，合约集中化可能会导致贯穿整个企业的技术耦合的产生</li></ul></li><li>验证耦合：消费者程序遵循技术服务合约中的数据模型（XML Schema 表示的输入输出消息的复杂类型，XML Schema 建立数据类型、约束、基于信息的大小和复杂度的验证规则）</li></ul></li></ul></li><li>服务松散耦合在服务设计中的应用<ul><li>耦合与面向服务</li><li>服务松散耦合与粒度<ul><li>涉及“消费者-合约”耦合</li><li>过粗操作粒度，不必要的额外处理；过细操作粒度，过多服务往返开销</li><li>过粗数据粒度，接受无用的额外信息；过细数据粒度，没有足够信息，需要额外调用</li><li>约束粒度决定消费者验证逻辑的数量</li></ul></li><li>耦合与服务模型<ul><li>以实体为核心的服务<ul><li>解耦的服务合约</li><li>与业务实体本身高度耦合</li></ul></li><li>应用服务<ul><li>往往是高度耦合的（实现耦合）</li><li>通过标准化服务合约，避免“消费者-实现” 的间接耦合</li></ul></li><li>以任务为核心的服务<ul><li>有时是在功能上耦合的</li><li>有时构成“服务-消费者”耦合</li></ul></li><li>编排服务<ul><li>避免技术耦合</li><li>无法避免“合约-实现”耦合</li></ul></li></ul></li><li><strong>服务松散耦合与其他原则</strong></li><li>服务松散耦合的相关风险<ul><li>“逻辑-合约”耦合的限制<ul><li>同一底层逻辑对应多个合约，建立多个入口，每一入口向不同类型消费者暴露不同的服务能力</li></ul></li><li>Schema 耦合太“松散”<ul><li>强调服务的兼容性演化能力，过分简化服务合约，追求减少消费者依赖，仅确定了一些非常通用的数据类型（弱类型），验证并处理弱类型，增加服务所需的性能要求</li><li>服务合约发布的信息少，消费者程序需要知道更多关于服务实现逻辑的信息，产生消极耦合</li></ul></li></ul></li></ul></li></ul><h3 id="服务抽象"><a href="#服务抽象" class="headerlink" title="服务抽象"></a>服务抽象</h3><p><strong>最小化元信息的可用性</strong></p><ul><li><p>信息隐藏与元抽象类型</p><ul><li><p>服务发布的信息传达了它的目的和能力，给用户提供了关于如何调用和使用该服务的详细信息</p></li><li><p>服务没有发布的服务信息用来保护它和未来用户之间形成的耦合关系的完整性，保障在服务在合约的前提下进行演化的能力</p></li><li><p>服务抽象原则就是为了获得信息隐藏的正确平衡点</p></li></ul></li><li><p>服务抽象原则</p><ul><li>服务合约中发布的信息越多，“消费者-合约”耦合就会越深</li><li>向设计服务消费程序的人呈现的信息越多，他们所知的底层逻辑、平台和服务相关的细节就会越多，导致事实上的“消费者-实现”耦合</li></ul></li><li><p>对服务元信息进行抽象</p><ul><li>技术信息抽象<ul><li>发布：调用程序需要的技术、程序交互需要的技术</li><li>隐藏：写程序使用的编程语言、程序使用的系统资源</li></ul></li><li>功能信息抽象<ul><li>决定了程序的哪些能力通过技术合约是可见的</li></ul></li><li>程序逻辑抽象<ul><li>对外界隐藏程序的内部细节</li></ul></li><li>服务质量信息抽象——描述服务的行为、限制和交互需求<ul><li>服务质量数据被用来描述一个服务的行为性的、基于规则的、和可靠性等相关的元信息<ul><li>确保服务及时响应的并发访问阈值</li><li>可用性限制，例如定期安排的断电</li><li>决定服务对不同类型输入数据的处理和响应的业务规则</li></ul></li><li>使用策略或 SLA 等文档加以描述</li></ul></li></ul></li><li><p>元抽象类型的实现</p><ul><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230404231557998.webp" alt="image-20230404231557998" style="zoom:33%;" /></li><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230404231628936.webp" alt="image-20230404231628936" style="zoom:33%;" /></li></ul></li><li><p>服务抽象度量</p><ul><li>合约内容的抽象级别<ul><li>详细的合约</li><li>简明的合约</li><li>优化的合约</li><li>混合的详细合约（服务能力位于不同的抽象级别）</li></ul></li><li>访问控制级别（源代码和设计规格）<ul><li>开放访问</li><li>受控访问</li><li>不可访问</li></ul></li><li>抽象级别与服务质量元信息<ul><li>服务质量元信息也能够适用于抽象级别和访问控制级别</li></ul></li></ul></li><li><p>服务抽象在服务设计中的应用</p><ul><li>服务抽象 VS. 服务封装<ul><li>在良好抽象的服务中，可以改变所封装的内容，而不会影响已经在使用该服务的消费者程序</li></ul></li><li>封装如何影晌抽象<ul><li>封装遗留环境的服务<ul><li>抽象的程度可能需要依靠底层服务适配器和相应的遗留 API 来决定</li><li>访问控制可能会很难实现</li></ul></li><li>封装定制组件的服务<ul><li>拥有定制的能力使得内容和访问抽象级别能够较好的定义</li></ul></li><li>封装了服务的服务<ul><li>除服务本身外，所封装的子服务也对内容和访问抽象级别有所影响</li></ul></li></ul></li><li>服务抽象与非技术合约文档<ul><li>非技术的服务描述（如 SLA）为技术合约增加了额外的规则、约束、策略、保证和担保等，这些文档由服务拥有者建立，并应当被服务消费者程序设计人员所知晓</li><li>如非技术的服务描述过于详细（依赖于当前实现），也会影响到服务的演化</li></ul></li><li>服务抽象与粒度<ul><li>服务抽象鼓励发布尽可能少的细节，以便在服务随时间而演化的过程中给服务的拥有者最大的自由度，这将导致粗粒度的约束级别</li><li>在使用策略时，可能导致暴露服务底层的逻辑、行为和参数选择的细节</li><li>其他的面向服务原则（如服务松散耦合和服务自治），也提倡在服务合约中减少约束</li></ul></li><li>服务抽象与服务模型<ul><li>以实体为中心的服务与应用服务<ul><li>抽象程度往往和所封装的定制逻辑、遗留API等紧密相关</li><li>需要严格的访问控制，以确保服务合约的寿命和底层逻辑的可复用性</li></ul></li><li>任务服务与编排任务服务<ul><li>无法达成过高的抽象级别</li></ul></li></ul></li><li><strong>服务抽象与其他原则</strong></li><li>服务抽象的相关风险<ul><li>多消费者耦合的需求<ul><li>不同消费者可能需要不同的技术接口细节，所需的抽象程度也不尽相同</li><li>使用合约反规范化，提供不同级别的抽象粒度</li></ul></li><li>人为误判<ul><li>过于抽象的服务合约导致曲解或不能充分理解一个服务，从而丧失潜在的复用机会</li><li>过于具体的服务合约导致对服务的行为作出与服务实现相关的假设，从而导致实现耦合</li></ul></li><li>安全和隐私的考虑<ul><li>服务合约可能暴露私有或者敏感信息（不同的使用环境、并发和冗余的服务合约内容以解决这一问题）</li></ul></li></ul></li></ul></li></ul><h3 id="服务可复用性"><a href="#服务可复用性" class="headerlink" title="服务可复用性"></a>服务可复用性</h3><p><strong>实现通用的和可复用的逻辑与合约</strong></p><ul><li><p>计划中复用的度量</p><ul><li><p>战术上的可复用性</p></li><li><p>针对性的可复用性</p></li><li><p>完全的可复用性</p></li></ul></li><li><p><strong>逻辑集中化</strong></p><ul><li><p>库存蓝图的制定能最大化发现和定义无关服务的机会，实现服务的可复用性</p></li><li><p>在规范化的服务库存中，每个服务代表了一个独特的功能域，本质上意味着服务边界之间没有重叠</p></li><li><p>逻辑集中化的风险</p><ul><li>项目组没有意识到服务的存在（服务没有做到充分地可发现或者可解释）：使用服务可发现性原则和集中的服务注册</li><li>项目组拒绝使用这样一个服务，因为他们认为这样做会加重负担：纳入企业的设计标准等</li></ul></li><li><p>要求设计者建立消费者程序并需要特定功能时，这些消费者程序只调用指定的服务（不会描述怎样访问这一逻辑），对比合约集中化要求设计者建立消费者程序时，这些消费者程序仅通过已发布的合约访问一个服务（不需要指定为了何种目的应该访问什么服务），两者相结合构成支持最大化可复用和与消费者松耦合的高度标准化服务仓库</p></li><li><p>集中化与 Web 服务</p><ul><li>Web 服务的 WSDL、XML schema 和 WS-Policy 定义必须正确地表达访问一个正式逻辑体（根据逻辑集中化）的一个正式访问点（根据合约集中化）</li></ul></li><li><p>实现逻辑集中化的挑战</p><ul><li>实际企业中很难实现逻辑集中化，采用领域库存模式描述企业的子集，并在领域库存中实现逻辑集中化</li></ul></li></ul></li><li><p>服务可复用性在服务设计中的应用</p><ul><li>服务可复用性与服务建模<ul><li>面向服务分析阶段需要考虑服务的可复用性、服务自治和服务可发现性</li><li>在服务建模中，需要精化已有的服务能力候选，使其更加一般化和可复用；定义额外的服务能力候选，这些能力是在构成服务建模过程的基础的业务流程自动化所需之外的</li></ul></li><li>服务可复用性与粒度<ul><li>服务粒度</li><li>能力粒度</li><li>数据粒度</li><li>约束粒度</li></ul></li><li>服务可复用性与服务模型<ul><li>以实体为中心的业务服务和应用服务强调无关性，提供适合封装可复用逻辑的功能上下文</li><li>以任务为核心的业务服务通过将无关服务从处理业务流程的逻辑中解脱出来，也支持了可复用性</li></ul></li><li><strong>服务可复用性与其他原则</strong></li><li>服务可复用性的相关风险<ul><li>文化上的考虑</li><li>治理上的考虑</li><li>可靠性上的考虑</li><li>安全上的考虑</li><li>商业设计需求上的考虑</li><li>敏捷交付上的考虑</li></ul></li></ul></li></ul><h3 id="服务自治"><a href="#服务自治" class="headerlink" title="服务自治"></a>服务自治</h3><p><strong>实现独立的功能边界和运行时环境</strong></p><ul><li><p>服务自治</p><ul><li>将库存中的每一个服务配置为独立的构成单元<ul><li>拥有越高的控制权，就拥有越高的自治</li><li>拥有越高的自治，就拥有越强的可靠性和可预测性</li></ul></li><li>表现了可以独立执行自身核心服务逻辑的能力</li></ul></li><li><p>服务自治类型</p><ul><li><p>运行时自治：服务对其运行时执行环境的控制权的大小</p></li><li><p>设计时自治：服务拥有者对于服务设计的管理权的大小</p></li></ul></li><li><p>服务合约自治</p><ul><li>一个服务合约所表达的能力范围不应与另外一个服务的能力范围发生重叠</li><li>服务合约自治与实现无关，从而与运行时自治无关</li><li>当服务合约是标准化的，并与它的底层实现解耦时，倾向于服务合约自治</li><li>服务规范化</li><li>合约反规范化</li><li>共享自治：封装遗留系统和技术的服务具备较低的自治性</li></ul></li><li><p>服务逻辑自治</p><ul><li>部分隔离<ul><li>底层服务构件是专用的并可以被隔离</li><li>数据库、目录和其他资源仍然是可被服务与企业的其他部门共享的</li></ul></li></ul></li><li><p>完全自治</p><ul><li>服务对自身的运行时环境拥有绝对的所有权</li><li>对服务的设计和架构可以自顶向下进行控制</li><li>功能隔离：服务构件和物理数据模型是专用的，但是服务位于一个与其他服务共享的服务器上</li><li>绝对隔离：服务构件和相关的数据模型都位于专用服务器上</li><li>设计时隔离：从设计开始，就对服务设计、数据模型和宿主环境等，拥有完全的管理权</li></ul></li><li><p>服务自治在服务设计中的应用</p><ul><li>服务自治与服务建模<ul><li>服务分析和服务建模中需要考虑服务自治</li><li>面向服务分析中，包含对已有自动化系统进行收集的步骤</li><li>已有自动化系统的信息影响到服务系统所能达到的自治级别</li></ul></li><li>服务自治与粒度<ul><li>相同的合约，不同的实现可能带来不同的自治级别</li><li>服务中的不同能力重要程度不同，可能要求不同程度的自治性</li><li>对可靠性、性能和安全需求，倾向于将能力分散到单独的服务中去，可能导致服务粒度降低</li></ul></li><li><strong>服务自治与其他原则</strong></li><li>服务自治的相关风险<ul><li>错误地判断服务的范围：反模式</li><li>包装服务和遗留逻辑封装：无法改变的自动化系统无法回避自治问题</li><li>对服务需求的过高估计：过于追求高自治</li></ul></li></ul></li></ul><h3 id="服务无状态性"><a href="#服务无状态性" class="headerlink" title="服务无状态性"></a>服务无状态性</h3><p><strong>实现可适应的、和状态管理无关的逻辑</strong></p><ul><li><p>状态管理延迟与无状态性设计</p><ul><li><p>服务的可复用性和可组合性，强调服务处理逻辑的优化，通过尽量减少资源消耗，满足尽可能多的消费者程序的需要</p></li><li><p>服务组合的复杂性上升的同时，整个组合生命周期内需要被保留和管理的活动相关数据的数量也在增加</p></li><li><p>为了使服务的可扩展性最大化，也为了服务库存的最大化利用，服务和其周围的架构可被设计为支持状态管理职责的委托和延迟，从而采用无状态性改进服务设计</p></li></ul></li><li><p>服务无状态性度量</p><ul><li>非延迟的状态管理（无状态性从低到没有）</li><li>部分延迟存储（较低的有状态性）</li><li>部分架构状态管理延迟（中等无状态性）</li><li>完全架构状态管理延迟（高度无状态性） </li><li>内部延迟状态管理（高度无状态性）</li></ul></li><li><p>状态管理</p><ul><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230405152350950.webp" alt="image-20230405152350950" style="zoom: 33%;" /></li></ul></li><li><p>无状态性在服务设计中的应用</p><ul><li>消息作为一个状态延迟选项</li><li>服务无状态性与服务实例<ul><li>在有状态的情况下，同一服务的多个不同实例处于活动且有状态时，它们构成一个服务实例池</li><li>服务消费者应能够在实例池中找到特定的实例并与之通信</li><li>WS-Addressing 协议提供了相应机制</li></ul></li><li>服务无状态性与粒度<ul><li>当一些服务在运行时需要接收和处理大范围的状态数据时，它们相应的合约粒度一定会受到影响</li><li>尤其可能会需要降低数据和约束粒度，以使它们能接收更大量的数据和范围更广的数值</li><li>与其他设计原则不同，服务无状态性可以同时影响消息体和消息头的粒度（WS-*）</li></ul></li><li>服务无状态性与服务模型<ul><li>实体服务<ul><li>对实体服务中的所有能力，以及对于一个服务库存中的所有实体服务，进行标准化状态管理规范</li><li>对消息传递的业务和上下文信息（和规则）的数据表示进行标准化管理，以确保一致的互联性</li></ul></li><li>应用服务<ul><li>有时会被故意设计成违反本条原则，设计一系列服务，作为有状态的系统资源来替代服务管理状态数据</li><li>这种类型的应用服务所提供的“横切”功能就是状态管理自身</li><li>使得其他服务的无状态性更容易实现</li></ul></li><li>任务服务<ul><li>以任务为中心的服务有一个以业务流程为中心的功能范围，它们被特意设计成用于封装上下文规则</li><li>如何管理状态数据有多样化方法（较大规模的组合倾向于延迟上下文数据，较小规模的任务在活动期间保有状态数据）</li></ul></li><li>编排任务服务<ul><li>编排任务服务总是被期望保持有状态</li><li>如果一个过程持续保持不活动状态超过了一定的时间，状态数据将会被保存在一个数据库中，直至需要被重新激活</li></ul></li></ul></li><li><strong>服务无状态性与其他原则</strong></li><li>服务无状态性的相关风险<ul><li>对于架构的依赖</li><li>增加的运行时性能需求</li><li>低估交付代价</li></ul></li></ul></li></ul><h3 id="服务可发现性"><a href="#服务可发现性" class="headerlink" title="服务可发现性"></a>服务可发现性</h3><p><strong>实现可交流的元数据</strong></p><ul><li><p>设计时发现 vs. 运行时发现</p><ul><li>由人来完成发现的手动过程称为设计时发现</li><li>建立具有动态发现查询能力的程序和服务，被称为运行时发现</li></ul></li><li><p>可发现性元信息</p><ul><li>功能性元数据</li><li>服务质量元数据</li></ul></li><li><p>服务可发现性在服务设计中的应用</p><ul><li>服务可发现性与服务建模<ul><li>服务可发现原则要求以统一的方式，从服务生命周期的开始，记录所有元数据</li><li>在服务建模过程中，业务和技术专家一起协作，来建立服务候选</li></ul></li><li>服务可发现性与粒度<ul><li>粒度中立</li></ul></li><li>服务可发现性与策略断言<ul><li>在 WS-Policy 框架中，可以使用策略断言来展示者服务消费者设计人员的优先和所应遵从的选项</li><li>既能表达功能性元数据，又能表达服务质量元数据</li><li>仅面向技术专家</li></ul></li><li><strong>服务可发现性与其他原则</strong></li><li>服务可发现性的相关风险<ul><li>可发现性在实施后的应用</li><li>由不擅交流的人员来应用本原则</li></ul></li></ul></li></ul><h3 id="服务可组合性"><a href="#服务可组合性" class="headerlink" title="服务可组合性"></a>服务可组合性</h3><p><strong>最大化可组合性</strong></p><h2 id="9-补充与例题"><a href="#9-补充与例题" class="headerlink" title="9. 补充与例题"></a>9. 补充与例题</h2><blockquote><p>一些概念补充</p></blockquote><ul><li>Web 服务是实现SOA的核心技术，但 SOA 并不等同于 Web 服务。Web服务是⼀套技术体系，可以用来构建应用解决方案，解决特定的消息通信和应⽤集成问题。而 SOA 是⼀种软件架构，不局限于某种技术组合（如 Web 服务），它超越技术范畴，甚⾄可以用来组织公司。</li><li>企业服务总线（ESB）是SOA基础架构（basic frastruct）的关键组件，是⼀种消息代理架构，管理消息通信、服务交互等等。</li><li>WSDL：Web 服务描述语言，基于 XML，但它才是 Web 服务的核心。因为它描述 Web 服务提供的操作（服务能力）以及这些操作接收和返回的参数。WSDL 包含的信息：服务做什么，应该如何使用它们，它们在哪里。也就是说提供者和调用者都需要参考 WSDL，从这个意义上来说 WSDL 是核心。</li></ul><blockquote><p>试结合相关协议和框架，描述⼀个 web service 从创建开始到被最终服务消费者调用的全过程中对服务的建模、查询和调用的全过程</p></blockquote><ul><li><p>服务的建模：</p><ul><li>XML 定义了 Web 服务中的消息交换格式，使用 XML Schema 定义不同的数据结构，引入 Namespace 使得 XML、XML Schema 中的元素和属性全球唯⼀且全球共享</li><li>SOAP 提供了⼀种标准的通信方法，使得运行在不同平台、使用不同的技术和编程语言的应用程序可以互相进行通信，服务的发布、查找、调用，都通过 SOAP 传递 XML 消息</li><li>WSDL 对服务能力、服务中使用的数据结构以及传输绑定给出定义和描述；提供了⼀种基于 XML 的标准接口定义语言/服务能力定义语言，用以在服务的提供者/调用者/服务注册之间，交换必要的有关 Web Service 的信息</li><li>对于大多数服务，用以上三个协议和框架可以完成建模；对于⼀些更为复杂的服务，如复合服务或者是带有非功能性需求的服务，还需要用到其他协议和框架完成建模<ul><li>BPEL 定义多个服务间如何交互和合作，从而将⼀组现有的服务根据业务流程构建起来，实现业务服务</li><li>WS-Policy 可以实现非功能性需求，如信息加密，权限验证等。建模完成后，服务提供者通过 UDDI 或者 WSIL 将服务发布出去。其中，UDDI 利用分页机制，让服务得到最大可能的复用和共享范围；WSIL 使用树形连接结构，适用于企业既定的服务</li></ul></li></ul></li><li><p>服务的查询</p><ul><li>消费者程序发送 SOAP 消息给服务注册，描述自己需要的服务</li><li>服务注册查询注册表，通过 WSDL 服务合约找到⼀系列符合条件的服务</li><li>服务注册将查询到的 WSDL 通过 SOAP 发送给消费者程序，让消费者程序从中选择可用的服务；或者服务注册自动化筛选出当前最符合消费者程序要求的服务，通知消费者程序</li></ul></li><li><p>服务的调用</p><ul><li>消费者程序根据 WSDL 中提供的服务位置进行调用<ul><li>消费者和提供者基于 WSDL 中约定的接口进行消息的发送和接收</li><li>当前服务可能同时被多个消费者程序使用，创建了⼀系列服务实例， WS-Addressing 提供了相应的机制，确保服务消费者能在实例池中找到特定的实例并与之通信</li><li>由于创建的实例是有状态的，利用 WSRF 对状态数据进行存取，进行状态管理，提高资源利用率</li></ul></li></ul></li></ul><blockquote><p>以电信企业为应用背景，举例描述服务分析和服务设计的过程。并结合⾯向服务的设计原则（标准化服务合约、服务松散耦合、服务抽象、服务可复用性、服务自治、服务无状态性、服务可发现性、服务可组合性），讨论 “schema集中化” “合约集中化” “逻辑集中化” 在设计过程中的应用。</p></blockquote><ul><li><p>举例：电信企业有订购、退订套餐，账单结算等基本业务流程</p></li><li><p>服务分析流程</p><ul><li>面向服务分析的目标是讨论需要构建哪些服务，每个服务应该封装哪些逻辑。分析的核心是业务服务<ul><li>进行文档化的需求描述，定义流程自动化需求，作为服务候选建模的依据；由于电信企业发展比较完善，可以直接使用之前的需求文档分析</li><li>对现有的自动化系统进行分析、识别；分析企业正在使⽤的系统具有的功能</li><li>对服务候选建模，识别服务操作候选，并将其分组</li></ul></li><li>在面向服务分析流程中，需要考虑服务可复用性、服务自治和服务可发现性<ul><li>可复用性：在服务建模中，需要：精化已有的服务能⼒候选，使其更加⼀般化和可复用；定义额外的服务能力候选，这些能⼒是在构成服务建模过程的基础的业务流程自动化所需之外的</li><li>自治：对已有自动化系统收集得到的信息，会影响服务系统所能达到的自治级别；比如根据信息决定保留遗留系统，那么达到共享自治，独⽴开发的可能达到逻辑自治或完全自治</li><li>可发现性：从服务⽣命周期开始，尤其是在产⽣服务操作候选时，需要以统⼀的方式，记录所有元数据；在服务建模过程中，业务和技术专家需要⼀起合作，建立服务候选</li></ul></li></ul></li><li><p>服务设计流程</p><ul><li>服务设计过程，是从服务候选（逻辑）派生出具体的服务设计（物理），然后装配到实现业务流程的抽象组合中<ul><li>组合SOA：选择编排、业务、应⽤服务层中的哪些进行实现，定义核心的SOA标准，选择SOA扩展（WS-*协议）</li><li>根据业务层级，分别设计以实体为核心的业务服务，应⽤服务，以任务为核心的业务服务</li><li>设计面向服务业务过程，组合服务构建出业务流程</li></ul></li></ul></li><li><p>schema集中化</p><ul><li>传统的做法是在订购服务、退订服务中使用不同的套餐数据结构，而按照标准化服务合约，所有使用的数据结构都应该被单独定义、管理，与具体的操作流程无关。采用Schema集中化的设计模式，将电信企业划分为多个分离的领域（部门），每个领域都可以被独立地进行标准化和治理，每个领域定义和管理自己的schema，作为整个服务系统的基本数据结构；在不同的服务中，使⽤这些schema，避免了频繁且不必要的数据转换；在必要的情况下，可以利用这些schema定义新的数据结构</li></ul></li><li><p>合约集中化</p><ul><li>为了保证服务松散耦合，避免消极耦合，采用合约集中化，将对服务的访问严格控制，在合约内：<ul><li>所有的合约应该被集中管理，拥有⼀致的设计原则和设计目标；</li><li>在服务⽣态系统中，任何情况都不可以绕开合约去访问具体内容</li></ul></li><li>服务抽象 &amp; 服务可发现性设计服务暴露的信息</li><li>服务抽象：技术信息、功能、程序逻辑、服务质量抽象</li><li>服务抽象出来并对外界可用的信息就是服务合约，服务合约的设计标准会影响到其他</li></ul></li><li><p>逻辑集中化</p><ul><li>为了实现服务可复用性，让消费者程序只调用指定的服务，要建立服务库存，在规范的服务库存中，每个服务代表来⼀个独特的功能域，这就要求服务边界之间没有重叠</li><li>设置专家管理服务库存，应用开发人员不能直接往服务库存中增改需要的服务，只能请求当前服务库存管理⼈员进行审查，作出恰当的决策</li><li>同时，服务可发现性是实现服务可复用的前提，服务自治是可复用服务潜在高性能和并行使用的保证；无状态性能提⾼服务的可用性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> SOA </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 服务计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《Web前端开发》课程复习</title>
      <link href="/2023/02/22/NJU-Web/"/>
      <url>/2023/02/22/NJU-Web/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于该课程任课老师过于抽象，课程考试本身涉及内容又多又杂，尝试体验使用 chatGPT 依据给定的复习提纲生成复习资料，作为考前速通参考</p></blockquote><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/web.webp" alt="web" style="zoom:50%;" /><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/html-final.webp" alt="html-final" style="zoom:50%;" /><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/css-final.webp" alt="css-final" style="zoom:50%;" /><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/js-final%20-%20%E5%89%AF%E6%9C%AC.webp" alt="js-final - 副本" style="zoom:100%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/js-final%20-%20%E5%89%AF%E6%9C%AC%20(2).webp" alt="js-final - 副本 (2)" style="zoom:100%;" /><h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/nodejs-final.webp" alt="nodejs-final" style="zoom:50%;" /><h1 id="性能-amp-鉴权-amp-HTTP-amp-RIA"><a href="#性能-amp-鉴权-amp-HTTP-amp-RIA" class="headerlink" title="性能 &amp; 鉴权 &amp; HTTP &amp; RIA"></a>性能 &amp; 鉴权 &amp; HTTP &amp; RIA</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/many.webp" alt="many" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 前端 </tag>
            
            <tag> Web </tag>
            
            <tag> chatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《数据库开发》复习总结</title>
      <link href="/2023/02/17/NJU-Database-Development/"/>
      <url>/2023/02/17/NJU-Database-Development/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库视图"><a href="#数据库视图" class="headerlink" title="数据库视图"></a>数据库视图</h2><p>数据库中的视图是一个虚拟的表，它是由一个或多个表的数据经过特定的查询语句组成的。视图的作用如下：</p><ul><li>简化复杂查询：视图可以将多个表的数据组合起来，使得复杂的查询可以被简化。使用视图可以将多个SELECT语句组合在一起，从而减少代码量和提高代码可读性。</li><li>数据安全性：视图可以对数据库的敏感数据进行保护。通过限制用户对表的访问权限，只能通过视图查询敏感数据，可以避免敏感数据被恶意篡改和删除。</li><li>简化数据访问：视图可以隐藏数据表的细节，只暴露必要的数据给用户。这样用户只需关注他们需要的数据，而不用关心数据表的具体实现。</li><li>可以向应用程序提供标准视图：应用程序可以通过访问视图而不是表来获取数据，这可以使应用程序更加灵活。当数据表结构发生变化时，只需要更改视图而不是应用程序代码。</li><li>提高性能：视图可以提高查询性能，因为它可以缓存一些常用的查询结果。当多个用户需要相同的查询结果时，视图可以避免重复查询。</li><li>数据一致性：视图可以保证数据的一致性，因为它可以对多个表的数据进行联合查询。当修改一个视图时，它会自动更新涉及到的所有数据表，从而保证数据的一致性。</li></ul><p>总的来说，视图是一种非常有用的数据库对象，可以提高查询性能、保护敏感数据、简化数据访问等。但是需要注意的是，视图可能会占用额外的存储空间和计算资源。</p><h2 id="开发数据库应用"><a href="#开发数据库应用" class="headerlink" title="开发数据库应用"></a>开发数据库应用</h2><p>不要把数据库当“黑盒”，每个数据库都是非常不同的，必须深入了解你所使用的数据库的体系结构和特征</p><ul><li>不同数据库实现的锁和并发控制机制不同<ul><li>Oracle 实现的锁机制<ul><li>只有修改才加行级锁</li><li>Read 绝对不会对数据加锁</li><li>Writer 不会阻塞 Reader</li><li>读写器绝对不会阻塞写入器</li></ul></li></ul></li><li>不同的数据库对于 Null 值的实现不同<ul><li>认为 Null 是未知值，与其他任何值都不相等，使用 IS NULL / IS NOT NULL 来进行判断</li><li>认为 Null 是合法值，用来表示缺失或未知的数据，在使用比较运算符时，一个操作数为 Null 则结果为 false</li><li>认为 Null 是合法值，用来表示缺失或未知的数据，在使用比较运算符时，一个操作数为 Null 则结果为 Null</li><li>…….</li></ul>  处理空值：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="built_in">coalesce</span>(t.x, <span class="number">0</span>)) <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure></li></ul><p>性能、安全性都是适当的被设计出来的</p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><ul><li><p>更适合磁盘实现的树必须具备以下属性：</p><ul><li><p>高扇出，以改善临近键的数据局限性</p></li><li><p>低高度，以减少遍历期间的寻道次数</p></li></ul></li><li><p>B 树（B+树）</p><ul><li>B 树（B+树）结构</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411094735661.webp" alt="image-20230411094735661" style="zoom:33%;" /><ul><li><p>最小度数 <em>t</em>，除根结点外每个内部结点至少有 <em>t-1</em> 个关键字，至多可包含 <em>2t-1</em> 个关键字</p></li><li><p>B 树的分裂操作（插入新结点时发现叶结点个数已满）：</p><ul><li>将包含 <em>2t-1</em> 个元素的满结点，从中间分裂成两个包含 <em>t-1</em> 个关键字的子结点</li><li>将中间关键字提升到父结点，标识两棵新树的划分点</li><li>如果此操作导致父结点也成为满结点，则递归地进行分裂操作</li></ul>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411101755823.webp" alt="image-20230411101755823" style="zoom:33%;" /></li><li><p>B 树的查找算法</p><ul><li>查找，从根节点到叶节点的单向遍历</li><li>从根节点上执行⼆分搜索算法，将要搜索的 $K$ ，与存储在根节点中的 $K_{n}$ 进行比较，直到找到大于 $K$ 的第⼀个分隔键，这样定位了⼀个要搜索的子树，顺着相应指针继续相同的搜索过程，直到目标叶节点，找到数据主文件指针</li></ul></li><li><p>B 树（B+树）逻辑存储结构</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411102820978.webp" alt="image-20230411102820978" style="zoom:50%;" /></li></ul></li><li><p>索引对数据的访问</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411103148171.webp" alt="image-20230411103148171" style="zoom:33%;" /><ul><li>通过主键索引访问基本表：先访问索引，得到文件的偏移量，再以此来访问基本表</li><li>通过二级索引访问基本表：<ul><li>二级索引直接指向基本表（读数据时只需要访问一次索引，写数据时需要访问两次索引）</li><li>二级索引指向主键索引（读数据时只需要访问两次索引，写数据时需要访问一次索引）</li></ul></li><li>复合键索引，本质上是按照排名第⼀的字段进行索引（查询的字段全在复合索引中则可不使用基本表）</li></ul></li></ul><h2 id="数据表的物理实现"><a href="#数据表的物理实现" class="headerlink" title="数据表的物理实现"></a>数据表的物理实现</h2><p>在数据库物理实现中，一个数据页（page）通常被划分为若干个固定大小的数据块（block），每个数据块包含一个或多个数据项（record），而这些数据项的大小并不固定</p><p>为了能够高效地管理这些数据项，数据库系统采用了一种称为 slotted page 的技术</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411140044656.webp" alt="image-20230411140044656" style="zoom:50%;" /><p>其中，Header 中包含的数据一般有：</p><ul><li>Page 类型：该 page 的类型，如数据页、索引页、系统页等</li><li>Page 编号：该 page 在数据库文件中的唯一标识符</li><li>空闲空间：该 page 中还剩余的可用空间大小</li><li>版本号：用于记录该 page 的版本信息，主要用于并发控制</li><li>标记位：用于标记该 page 的状态，如是否被锁定、是否被修改等</li><li><strong>Checksum</strong>：用于校验该 page 的数据完整性，防止数据损坏或篡改</li><li>……</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411141454871.webp" alt="image-20230411141454871" style="zoom:50%;" /><p>为了能够回收已删除记录的空间，构建指针链表 Freeblock，并指向第⼀个空闲块的指针保存在页头部，保存可用字节数（确定是否能在碎片整理后被放入该页）</p><ul><li>使用空闲块的策略：<ul><li>首次适配优先（找第⼀个适配的空闲块，会带来额外开销）</li><li>最佳适配优先（找⼀个剩余段最小的空间）</li></ul></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411142944111.webp" alt="image-20230411142944111" style="zoom:33%;" /><p>行迁移：页溢出时，在原页面中留出一个指针大小的空间，然后将该记录的剩余部分存储在新的页面中</p><p>额外的小问题：</p><ul><li>经验规律 70% / 30% 原则，留下一定的空间，最大程度上避免行迁移的产生</li><li>校验和：checksum / XOR，循环冗余校验 CRC（检测连续比特位的损坏）</li></ul><h2 id="SQL-语法技巧"><a href="#SQL-语法技巧" class="headerlink" title="SQL 语法技巧"></a>SQL 语法技巧</h2><ul><li><p>聚合计算时处理 null</p><p>  使用 COALESCE 函数：coalesce(expr_1, expr_2, …, expr_n)，遇到非 null 值即停止判断并返回该值</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="built_in">coalesce</span>(t.x, <span class="number">0</span>)) <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure></li><li><p>删除字符串中部分内容</p><p>  使用 REPLACE 函数：replace(original-string，search-string，replace-string)</p><ul><li>original-string： 被搜索的字符串</li><li>search-string： 要搜索并被 replace-string 替换的字符串（若为空串，则返回原始字符串）</li><li>replace-string： 该字符串用于替换 search-string（若为空串，则删除出现的所有 search-string）</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> `article` <span class="keyword">set</span> title<span class="operator">=</span>replace(title, <span class="string">&#x27;w3cschool&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>计算中位数</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Oracle</span></span><br><span class="line"><span class="keyword">select</span> median(sal) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL/PostgreSQL</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(sal)</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> e.sal</span><br><span class="line">    <span class="keyword">from</span> emp e, emp d</span><br><span class="line">    <span class="keyword">where</span> e.deptno<span class="operator">=</span>d.deptno</span><br><span class="line">    <span class="keyword">and</span> e.deptno<span class="operator">=</span><span class="number">20</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> e.sal</span><br><span class="line">    <span class="keyword">having</span></span><br><span class="line">    <span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> e.sal<span class="operator">=</span>d.sal <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)</span><br><span class="line">    <span class="operator">&gt;=</span> <span class="built_in">abs</span>(<span class="built_in">sum</span>(sign(e.sal<span class="operator">-</span>d.sal)))</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据库模式设计之层次结构"><a href="#数据库模式设计之层次结构" class="headerlink" title="数据库模式设计之层次结构"></a>数据库模式设计之层次结构</h2><ul><li><p>树状结构</p><ul><li><p>只要对象的类型相同，而对象的层树可变，其关系就应该被建模为树结构</p></li><li><p>数据库模式设计中的三种树模型</p><ul><li><p>Adjacency Model：邻接模型</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411114131470.webp" alt="image-20230411114131470" style="zoom:33%;" /></li><li><p>Materialized Path Model：物化路径模型</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411114156857.webp" alt="image-20230411114156857" style="zoom:33%;" /></li><li><p>Nested Set Model：嵌套集合模型</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411114252955.webp" alt="image-20230411114252955" style="zoom:33%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230411114320531.webp" alt="image-20230411114320531" style="zoom:33%;" /></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoveTest（ing）</title>
      <link href="/2023/02/15/RoveTest/"/>
      <url>/2023/02/15/RoveTest/</url>
      
        <content type="html"><![CDATA[<h1 id="基于视觉理解的非侵入软件测试技术——RoveTest"><a href="#基于视觉理解的非侵入软件测试技术——RoveTest" class="headerlink" title="基于视觉理解的非侵入软件测试技术——RoveTest"></a>基于视觉理解的非侵入软件测试技术——RoveTest</h1>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> NJU-iSE </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> 自动化测试 </tag>
            
            <tag> 图像理解 </tag>
            
            <tag> 机械臂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《机器学习》课程笔记</title>
      <link href="/2023/02/14/NJU-Machine-Learning/"/>
      <url>/2023/02/14/NJU-Machine-Learning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记中的图片均截取自课程PPT</p></blockquote><h1 id="机器学习概论"><a href="#机器学习概论" class="headerlink" title="机器学习概论"></a>机器学习概论</h1><h2 id="机器学习系统"><a href="#机器学习系统" class="headerlink" title="机器学习系统"></a>机器学习系统</h2><h3 id="通俗定义"><a href="#通俗定义" class="headerlink" title="通俗定义"></a>通俗定义</h3><p>任何通过数据训练的学习算法都属于机器学习</p><ul><li>线性回归（Linear Regression）</li><li>K-均值聚类（K-means）</li><li>主成分分析（Principal Component Analysis-PCA）</li><li>决策树（Decision Trees）和随机森林（Random Forest）</li><li>支持向量机（Support Vector Machines）</li><li>人工神经网络（Artificial Neural Networks）</li></ul><h3 id="学习系统"><a href="#学习系统" class="headerlink" title="学习系统"></a>学习系统</h3><p>模型空间（模型层面）+ 数据（数据层面）→ 学习算法（学习层面）→ 学得模型（学习结果）</p><p><strong>数据层面</strong></p><p>数据类型或特点：</p><ul><li>静态 vs. 动态</li><li>小数据 vs. 大数据</li><li>同质 vs. 异质</li><li>单态 vs. 多态</li><li>小类数 vs. 大类数</li><li>缺失 &amp; 带噪数据</li><li>高维数据 &amp; 非数值数据</li><li>……</li></ul><p><strong>模型层面</strong></p><p>形式：线性 / 非线性</p><p>体系：浅层 / 深度 / 递归</p><p><strong>学习层面</strong></p><p>经典 vs. 现代 vs. 混合</p><p>优化目标函数，在很大的模型空间找到目标函数（SGD 等学习算法）</p><p>经典学习方法：机械学习 / 归纳学习 / 类比学习 / 解释学习 / 决策树&amp;森林 / 贝叶斯分类器 / 聚类</p><p>现代学习方法：监督学习 / 弱监督学习 / 无监督学习 / 统计学习 / 集成学习 / 强化学习 / 深度学习</p><h2 id="系统建模和模型选择"><a href="#系统建模和模型选择" class="headerlink" title="系统建模和模型选择"></a>系统建模和模型选择</h2><p><strong>常规术语及标记</strong></p><ul><li>输入：x, x<del>i</del></li><li>权重：W, w<del>ij</del></li><li>输出：y, y(x, W)</li><li>目标：t, t<del>j</del></li><li>误差：E</li></ul><p><strong>数据集与数据集划分</strong></p><p>训练集，测试集，验证集（留出法，交叉验证）</p><p><strong>建模有关要素</strong></p><ul><li><p>模型 / 映射函数 f ( · ) 刻画（线性分类器？SVM？神经网络？）</p></li><li><p>确定目标 / 损失函数（平方损失？交叉熵？凸与非凸？）并优化获得模型</p></li><li><p>评测泛化性能（在未知样本上的预测能力）：欠拟合/过拟合</p></li></ul><p><strong>评价指标</strong></p><p>混淆矩阵（多分类，TP,FN,FP,TN:二分类），精度，错误率，查准率，查全率，F1度量</p><p><strong>ROC 曲线</strong></p><p><strong>不平衡数据集</strong></p><p><strong>模型选择</strong></p><p>正则化方法：约束选择空间</p><p><strong>吉洪诺夫正则化</strong></p><p>借助某个辅助非负泛函 / 模型实现解的稳定化</p><p>在泛函中嵌入了了解或问题的先验信息（如神经网络中权重衰减，在深度网络中用 Dropout）</p><p><strong>先验的重要性</strong></p><p>泛化（Generalization）= 数据（Data）+ 知识（Knowledge）</p><h2 id="统计学基本概念"><a href="#统计学基本概念" class="headerlink" title="统计学基本概念"></a>统计学基本概念</h2><p><strong>数据集的统计量</strong></p><ul><li>均值，中位数，众数</li><li>期望：概率加权和</li><li>方差，均方根</li><li>协方差（covariance）</li><li>协方差矩阵（covariance matrix）</li></ul><p><strong>距离度量函数</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305181503739.webp" alt="image-20230305181503739" style="zoom:50%;" /><p><strong>高斯分布（正态分布）</strong></p><p><strong>概率</strong></p><p>从统计学角度，机器学习的目的是得到映射 x → y</p><ul><li>类的先验概率：p ( y = i )</li><li>样本的先验概率：p ( x )</li><li>类条件概率（似然）： p ( x | y = i )</li><li>后验概率：p ( y = i | x )</li></ul><p>从概率框架的角度对机器学习方法分类：</p><ul><li>生成式模型：估计类条件概率和类先验概率，用贝叶斯定理求后验概率</li><li>判别式模型：直接估计后验概率（使用判别函数，不假设概率模型，直接求一个把各类分开的边界）</li></ul><p><strong>朴素贝叶斯分类</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301165958734.webp" alt="image-20230301165958734" style="zoom:50%;" /><h2 id="机器学习技术新进展"><a href="#机器学习技术新进展" class="headerlink" title="机器学习技术新进展"></a>机器学习技术新进展</h2><p><strong>新型机器学习技术</strong></p><ul><li>终身 / 连续学习（Lifelong / Continual Learning）</li><li>迁移学习和域适应（Transfer Learning &amp; Domain Adaption）</li><li>深度强化学习（Deep Reinforcement Learning）</li><li>对抗学习（Adversarial Learning）</li><li>元学习（Meta-Learning）</li><li>小样本学习（Few-shot Learning）</li><li>自监督学习（Self-supervised Learning）</li><li>联邦学习（Federated Learning）</li><li>……</li></ul><p><strong>新型机器学习发展趋势</strong></p><ul><li>模型层面<ul><li>大模型，大模型+领域知识，大模型+多模态信息/结构信息</li><li>小模型，模型蒸馏 / 量化（适配资源受限场景）</li><li>……</li></ul></li><li>优化层面<ul><li>在线 / 增量学习（Online / Incremental Learning）</li><li>分布 / 并行学习（Distributed / Parallel Learning）+ 异步优化</li><li>加速现有算法（Speedup existing algorithms）</li></ul></li><li>数据层面<ul><li>大数据，带噪声数据学习，多模态数据学习</li><li>小数据，总结或提炼数据，数据蒸馏</li></ul></li></ul><h1 id="概率学习"><a href="#概率学习" class="headerlink" title="概率学习"></a>概率学习</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>符号和术语</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305160737157.webp" alt="image-20230305160737157" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305160759643.webp" alt="image-20230305160759643" style="zoom:50%;" /><p><strong>带约束的数学优化问题</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305160821582.webp" alt="image-20230305160821582" style="zoom:50%;" /><p><strong>不带约束的数学优化问题</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305160846976.webp" alt="image-20230305160846976" style="zoom:50%;" /><p><strong>凸函数与凹函数</strong></p><ul><li>凸函数</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161027667.webp" alt="image-20230305161027667" style="zoom:50%;" /><ul><li>凹函数</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161048350.webp" alt="image-20230305161048350" style="zoom:50%;" /><ul><li>判断函数的凹凸</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161110550.webp" alt="image-20230305161110550" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161131271.webp" alt="image-20230305161131271" style="zoom:50%;" /><p><strong>随机变量的期望</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161213061.webp" alt="image-20230305161213061" style="zoom:50%;" /><p><strong>Jensen’s inequality</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161411615.webp" alt="image-20230305161411615" style="zoom:50%;" /><p><strong>高斯分布/正态分布</strong></p><p>正态分布是在统计以及许多统计测试中最广泛应用的一类分布</p><p>正态分布是统计模式识别、计算机视觉和机器学习中使用最广泛的概率分布</p><ul><li>单变量高斯分布（Univariate Gaussian distribution）</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161617946.webp" alt="image-20230305161617946" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161720811.webp" alt="image-20230305161720811" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161755356.webp" alt="image-20230305161755356" style="zoom:50%;" /><ul><li>多变量高斯分布（Multivariate Gaussian distribution）</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161821196.webp" alt="image-20230305161821196" style="zoom: 50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161921763.webp" alt="image-20230305161921763" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305161958083.webp" alt="image-20230305161958083" style="zoom:50%;" /><h2 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h2><h3 id="高斯混合模型（Gaussian-Mixture-Model-GMM）"><a href="#高斯混合模型（Gaussian-Mixture-Model-GMM）" class="headerlink" title="高斯混合模型（Gaussian Mixture Model, GMM）"></a>高斯混合模型（Gaussian Mixture Model, GMM）</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305164455910.webp" alt="image-20230305164455910" style="zoom:50%;" /><ul><li>概率密度函数</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305164409746.webp" alt="image-20230305164409746" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305164520385.webp" alt="image-20230305164520385" style="zoom:50%;" /><ul><li>图模型</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305164548996.webp" alt="image-20230305164548996" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305164611515.webp" alt="image-20230305164611515" style="zoom:50%;" /><h2 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h2><h3 id="最大似然估计（Maximum-likelihood-estimation，MLE）"><a href="#最大似然估计（Maximum-likelihood-estimation，MLE）" class="headerlink" title="最大似然估计（Maximum likelihood estimation，MLE）"></a>最大似然估计（Maximum likelihood estimation，MLE）</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305171426184.webp" alt="image-20230305171426184" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305171506580.webp" alt="image-20230305171506580" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305171531820.webp" alt="image-20230305171531820" style="zoom:50%;" /><h2 id="期望最大化算法"><a href="#期望最大化算法" class="headerlink" title="期望最大化算法"></a>期望最大化算法</h2><h3 id="EM-算法"><a href="#EM-算法" class="headerlink" title="EM 算法"></a>EM 算法</h3><p><strong>核心思想</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305172614172.webp" alt="image-20230305172614172" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305172652574.webp" alt="image-20230305172652574" style="zoom:50%;" /><p><strong>优化分析</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305172807483.webp" alt="image-20230305172807483" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305172834223.webp" alt="image-20230305172834223" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305180850321.webp" alt="image-20230305180850321" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305180940898.webp" alt="image-20230305180940898" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305181009838.webp" alt="image-20230305181009838" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305181044018.webp" alt="image-20230305181044018" style="zoom:50%;" /><p><strong>算法流程</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305181110353.webp" alt="image-20230305181110353" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305181137967.webp" alt="image-20230305181137967" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305181158298.webp" alt="image-20230305181158298" style="zoom:50%;" /><h2 id="k-近邻分类器"><a href="#k-近邻分类器" class="headerlink" title="k-近邻分类器"></a>k-近邻分类器</h2><p><strong>算法流程</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305192643306.webp" alt="image-20230305192643306" style="zoom:50%;" /><p><strong>k取值的影响</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305192729403.webp" alt="image-20230305192729403" style="zoom:50%;" /><h2 id="最近邻分类器"><a href="#最近邻分类器" class="headerlink" title="最近邻分类器"></a>最近邻分类器</h2><p><strong>算法流程</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305194006168.webp" alt="image-20230305194006168" style="zoom:50%;" /><p><strong>泛化错误率</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305194039700.webp" alt="image-20230305194039700" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305194105010.webp" alt="image-20230305194105010" style="zoom:50%;" /><h2 id="k-近邻回归"><a href="#k-近邻回归" class="headerlink" title="k-近邻回归"></a>k-近邻回归</h2><p><strong>算法流程</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305194143255.webp" alt="image-20230305194143255" style="zoom:50%;" /><p><strong>近邻平滑</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305194221170.webp" alt="image-20230305194221170" style="zoom:50%;" /><p><strong>讨论</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305194334078.webp" alt="image-20230305194334078" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305194359508.webp" alt="image-20230305194359508" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305194420413.webp" alt="image-20230305194420413" style="zoom:50%;" /><p><strong>降低计算</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305194455953.webp" alt="image-20230305194455953" style="zoom:50%;" /><h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><h2 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h2><p><strong>相关概念</strong></p><p>聚类（簇，类）：数据对象的集合，同类相似，不同类不相似</p><p>聚类算法（clustering algorithm）：根据给定的相似性评价标准，将一个数据集合划分成几个聚类</p><p>聚类依据：将样本看作是特征空间中的点，点与点的距离作为相似性评价标准</p><p>目的：潜在的自然分组结构/感兴趣的关系</p><p>聚类的关键：特征的选取或设计 + 距离度量函数的选择</p><p><strong>距离度量</strong></p><p><strong>聚类准则</strong></p><p>类的定义：距离小于阈值 / 聚类准则函数方法</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301171457528.webp" alt="image-20230301171457528" style="zoom:50%;" /><p><strong>聚类方法</strong></p><ul><li><p>基于试探的聚类搜索算法</p><ul><li>按最近邻规则的简单试探法</li></ul></li></ul><ul><li><p>系统聚类法</p><ul><li>按距离逐步分类（所有样本初始时视作独立的类别，由多到少的收敛过程）</li></ul></li></ul><ul><li><p>动态聚类法</p><ul><li><p>选取若干样本点作为聚类中心，再按照最小距离准则使样本点向各中心聚集，得到初始聚类</p></li><li><p>判断初始分类是否合理，若不合理则修改聚类，反复迭代直至合理为止</p></li></ul></li></ul><p><strong>K-means 算法</strong></p><p>K-means 算法是动态聚类法的代表算法</p><p>K-means 算法流程：</p><ol><li>选择聚类数量 k</li><li>随机选择 k 个样本点作为初始聚类中心 μ<del>1</del> μ<del>2</del> … μ<del>k</del></li><li>对每个样本点，计算其到 k 个聚类中心的距离，并将其分类到距离它最近的聚类中心所属聚类</li><li>对每个聚类，计算属于该聚类的所有样本点的均值，作为新的聚类中心</li><li>如果没有发生样本所属聚类改变（或达到最大迭代次数）则终止，否则返回第 3 步继续执行</li></ol><p>针对初始聚类中心的选取，有优化方案 K-means++ 算法</p><p><strong>聚类评价</strong></p><p>标签未知：紧密度，间隔度，戴维森堡丁指数，邓恩指数</p><p>标签已知：聚类准确率，兰德指数，调整兰德指数，互信息，归一化互信息</p><h2 id="前沿进展"><a href="#前沿进展" class="headerlink" title="前沿进展"></a>前沿进展</h2><h3 id="监督深度学习的成功与现实困境"><a href="#监督深度学习的成功与现实困境" class="headerlink" title="监督深度学习的成功与现实困境"></a>监督深度学习的成功与现实困境</h3><p>（监督）深度学习是如何成功的：</p><ul><li>预先定义许多视觉的概念及类别进行学习</li><li>为每个概念类别收集大量具有差异性的样本</li><li>对收集到的数据进行清洗和精细标注</li><li>采用多块 GPU 显卡训练几个小时甚至几天</li></ul><p>现实场景中存在的困境和问题：</p><ul><li>数据体量大</li><li>数据标注时间长</li><li>数据标注代价高</li><li>不能利用未标注的数据</li><li>监督信号可能使深度模型变得有偏</li></ul><h3 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h3><p>什么是自监督学习？（自监督预训练 + 下游任务迁移）</p><ul><li>无监督学习的一种形式，<strong>数据没有（人类标注的）监督信息</strong></li><li>需要<strong>定义一个前置（借口）任务</strong>让网络学习我们关心的事情</li><li>对于大部分前置任务，我们需要<strong>保留一部分数据</strong>，让网络学会预测</li><li>通过前置任务学习到的特征会被用到不同的<strong>下游任务</strong>（通常包含标注）</li></ul><p>自监督学习分类：前置任务学习，对比学习，非对比学习</p><h4 id="前置任务学习"><a href="#前置任务学习" class="headerlink" title="前置任务学习"></a>前置任务学习</h4><p><strong>生成式方法——图像着色</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301215532176.webp" alt="image-20230301215532176" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301215601541.webp" alt="image-20230301215601541" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301215624475.webp" alt="image-20230301215624475" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301215646345.webp" alt="image-20230301215646345" style="zoom:50%;" /><p><strong>生成式方法——图像修复</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301215726738.webp" alt="image-20230301215726738" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301215744738.webp" alt="image-20230301215744738" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301230539112.webp" alt="image-20230301230539112" style="zoom:50%;" /><p><strong>判别式方法——图像拼图</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301230824904.webp" alt="image-20230301230824904" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301230846766.webp" alt="image-20230301230846766" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301230907470.webp" alt="image-20230301230907470" style="zoom:50%;" /><h4 id="对比学习"><a href="#对比学习" class="headerlink" title="对比学习"></a>对比学习</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231029180.webp" alt="image-20230301231029180" style="zoom:50%;" /><p><strong>MoCo</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231102221.webp" alt="image-20230301231102221" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231124723.webp" alt="image-20230301231124723" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231151658.webp" alt="image-20230301231151658" style="zoom:50%;" /><p><strong>SimCLR</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231419746.webp" alt="image-20230301231419746" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231441420.webp" alt="image-20230301231441420" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231502418.webp" alt="image-20230301231502418" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231536641.webp" alt="image-20230301231536641" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231857690.webp" alt="image-20230301231857690" style="zoom:50%;" /><h4 id="非对比学习"><a href="#非对比学习" class="headerlink" title="非对比学习"></a>非对比学习</h4><p><strong>聚类方法——DeepCluster</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231650616.webp" alt="image-20230301231650616" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231709428.webp" alt="image-20230301231709428" style="zoom:50%;" /><p><strong>聚类方法——SwAV</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231734407.webp" alt="image-20230301231734407" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231755524.webp" alt="image-20230301231755524" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301231827445.webp" alt="image-20230301231827445" style="zoom:50%;" /><h2 id="作业一：K-means"><a href="#作业一：K-means" class="headerlink" title="作业一：K-means"></a>作业一：K-means</h2><p>要求：实现 K-means 聚类并使用其进行无监督图像分割</p><p><strong>代码展示</strong>：<a href="https://github.com/Ling-Yuchen/ML-hw/blob/main/kmeans.py">https://github.com/Ling-Yuchen/ML-hw/blob/main/kmeans.py</a></p><h3 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h3><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>略</p><h4 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h4><p>在本次实验中使用了两种方法来实现 K-means 聚类算法，一是参考 <a href="https://blog.csdn.net/lanshi00/article/details/104109963">https://blog.csdn.net/lanshi00/article/details/104109963</a> 调用已有封装好的 <code>cv2.kmeans()</code>，二是参考 <a href="https://github.com/Daya-Jin/ML_for_learner/blob/master/cluster/KMeans.ipynb">https://github.com/Daya-Jin/ML_for_learner/blob/master/cluster/KMeans.ipynb</a> 使用 <code>numpy</code> 等库手动实现算法流程，两者均使用 <code>cv2.imshow()</code> 作为可视化实现方案</p><ul><li><p><strong>方法一</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">compactness, clusters, centers = cv2.kmeans(</span><br><span class="line">    data=data,</span><br><span class="line">    K=k,</span><br><span class="line">    bestLabels=<span class="literal">None</span>,</span><br><span class="line">    criteria=(</span><br><span class="line">        cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER,  <span class="comment"># type</span></span><br><span class="line">        <span class="number">10</span>,  <span class="comment"># max_iter</span></span><br><span class="line">        <span class="number">1.0</span>  <span class="comment"># epsilon</span></span><br><span class="line">    ),  <span class="comment"># define condition of ending</span></span><br><span class="line">    attempts=<span class="number">10</span>,</span><br><span class="line">    flags=cv2.KMEANS_PP_CENTERS  <span class="comment"># set initial centers</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>  关键参数：</p><ul><li>criteria：规定了迭代的终止条件</li><li>flags：规定了初始中心的生成方式</li><li>k：规定了目标类簇的个数</li></ul></li><li><p><strong>方法二</strong></p><p>  每次迭代的核心代码如下：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">epoch += <span class="number">1</span></span><br><span class="line"><span class="comment"># calculate distance from each sample to each center</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">dist[:, i] = np.linalg.norm(data - cent_cur[i], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># each sample belongs to cluster of the nearest center</span></span><br><span class="line">clusters = np.argmin(dist, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cent_pre = deepcopy(cent_cur)</span><br><span class="line"><span class="comment"># calculate mean coordinate on each cluster, update center</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">cent_cur[i] = np.mean(data[clusters == i], axis=<span class="number">0</span>)</span><br><span class="line">cent_move = np.linalg.norm(cent_cur - cent_pre)</span><br></pre></td></tr></table></figure><p>  核心代码说明：</p><ul><li><p><code>data</code> 表示经过处理的输入图像数据，其形状为  (65536, 1)（经过灰度处理）或 (65536, 3)（未经过灰度处理）（输入的图像被固定 resize 为 256*256，固共有 65536 个样本点）</p></li><li><p>每次迭代需要递增迭代次数，并计算各聚类中心的改变量，若迭代次数达到最大值或改变量低于设定阈值，则终止迭代</p></li><li><p>计算样本点到各聚类中心的距离，使用 <code>np.linalg.norm()</code>，默认为二范数，即计算欧拉距离，计算结果保存在一个形状为 (65536, k) 的距离矩阵中</p></li><li><p>依据距离矩阵对样本点进行分类，使用 <code>np.argmin()</code>，返回一个最小值索引向量，表示本次迭代产生的聚类结果</p></li></ul></li></ul><h4 id="可视化实验结果分析"><a href="#可视化实验结果分析" class="headerlink" title="可视化实验结果分析"></a>可视化实验结果分析</h4><ul><li>高斯模糊对实验结果影响的讨论<ul><li>在预处理步骤中增加了高斯模糊可以明显减少聚类结果中边界处的噪声点，使得分类更加准确，图像分割结果更加美观</li></ul></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301084839502.webp" alt="image-20230301084839502" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301084720367.webp" alt="image-20230301084720367" style="zoom:50%;" /><ul><li>使用灰度图对实验结果影响的讨论<ul><li>在主体色调相对统一的情况下，在原图上和在灰度图上进行处理最后得到的分割结果基本相同（第一组对比图），使用灰度图可以在保证分割效果的情况下使算法的计算量缩减为 1/3</li><li>在色调有明显区分的情况下，使用灰度图会因为损失了一部分信息而得到偏离预期的分割结果（第二组对比图）</li></ul></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301085825192.webp" alt="image-20230301085825192" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301085946910.webp" alt="image-20230301085946910" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301185012430.webp" alt="image-20230301185012430" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301185127501.webp" alt="image-20230301185127501" style="zoom:50%;" /><ul><li>更多分割结果展示</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301090716162.webp" alt="image-20230301090716162" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230301090905016.webp" alt="image-20230301090905016" style="zoom:50%;" /><h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><h2 id="感知机：线性超平面"><a href="#感知机：线性超平面" class="headerlink" title="感知机：线性超平面"></a>感知机：线性超平面</h2><p>二分类问题可以看作在线性空间上对类别进行划分的任务</p><p><em><strong>w</strong></em>^T^<em><strong>x</strong></em> + <em>b</em> = 0：划分超平面的线性方程，其中 <em><strong>w</strong></em> 为法向量，决定超平面的方向；<em>b</em> 为位移项，决定了超平面与原点之间的距离</p><p>强假设：处于“正中间”的超平面具有更好的鲁棒性和泛化能力</p><h2 id="线性支持向量机（LSVM）"><a href="#线性支持向量机（LSVM）" class="headerlink" title="线性支持向量机（LSVM）"></a>线性支持向量机（LSVM）</h2><h3 id="间隔与支持向量"><a href="#间隔与支持向量" class="headerlink" title="间隔与支持向量"></a>间隔与支持向量</h3><p>间隔（margin）：每个样本点到超平面的垂直距离</p><p>超平面的优化目标：最大化所有训练样本的最小间隔</p><p>支持向量（support vector）：具有最小间隔的样本点</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230303225744792.webp" alt="image-20230303225744792" style="zoom:50%;" /><h3 id="计算-Margin"><a href="#计算-Margin" class="headerlink" title="计算 Margin"></a>计算 Margin</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230303230248914.webp" alt="image-20230303230248914" style="zoom:50%;" /><h3 id="分类与评价"><a href="#分类与评价" class="headerlink" title="分类与评价"></a>分类与评价</h3><p>分类方式：<em>f(x)</em> &gt; 0 → 正类；<em>f(x)</em> &lt; 0 → 负类</p><p>判断预测的对错：对样本点 *x<del>i</del>*，用 <em>y<del>i</del></em> ∈ {-1, 1} 作为其正负类的标注，则有</p><ul><li><em>y<del>i</del> f(<strong>x</strong><del>i</del>)</em> &gt; 0 → 预测正确；<em>y<del>i</del> f(<strong>x</strong><del>i</del>)</em> &lt; 0 → 预测错误</li><li>假设能够将样本点完全分开，并且 <em>|y<del>i</del>|</em> = 1，则有 <em>y<del>i</del> f(<strong>x</strong><del>i</del>)</em> = <em>|f(<strong>x</strong><del>i</del>)</em>|</li></ul><h3 id="SVM-的形式化描述"><a href="#SVM-的形式化描述" class="headerlink" title="SVM 的形式化描述"></a>SVM 的形式化描述</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230303231456468.webp" alt="image-20230303231456468" style="zoom:50%;" /><p><strong>换个角度看问题以简化目标</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230303231756077.webp" alt="image-20230303231756077" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230303234051787.webp" alt="image-20230303234051787" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230303234116837.webp" alt="image-20230303234116837" style="zoom:50%;" /><h3 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230303234236689.webp" alt="image-20230303234236689" style="zoom:50%;" /><h3 id="KKT-条件"><a href="#KKT-条件" class="headerlink" title="KKT 条件"></a>KKT 条件</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230303234341963.webp" alt="image-20230303234341963" style="zoom:50%;" /><h3 id="SVM-的对偶形式"><a href="#SVM-的对偶形式" class="headerlink" title="SVM 的对偶形式"></a>SVM 的对偶形式</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230303234520031.webp" alt="image-20230303234520031" style="zoom:50%;" /><h3 id="Soft-margin"><a href="#Soft-margin" class="headerlink" title="Soft margin"></a>Soft margin</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304091100595.webp" alt="image-20230304091100595" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304091129110.webp" alt="image-20230304091129110" style="zoom:50%;" /><p><strong>对犯错误进行惩罚</strong></p><ul><li>在原始空间内：</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304091334360.webp" alt="image-20230304091334360" style="zoom:50%;" /><p>其中，<em>C</em> &gt; 0，是一个正则化参数；<em>ξ<del>i</del></em> 是代价（要最小化代价函数）；<em><strong>w^T^w</strong></em> 是正则项，对分类器进行限制，限制模型的复杂度（还是最大化间隔）</p><ul><li>在对偶空间内：</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304091925800.webp" alt="image-20230304091925800" style="zoom:50%;" /><p><em>对偶形式仅依赖于样本的内积</em></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>分类器是一个分离超平面（separating hyperplane）</li><li>最重要的训练样本是“支持向量”，它们定义了超平面，其他样本被忽略。二次优化算法可以识别哪些样本是具有非零拉格朗日乘子 <em>α<del>i</del></em> 的支持向量</li><li>对偶问题中，训练样本只以内积的形式出现</li></ul><h2 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304092349504.webp" alt="image-20230304092349504" style="zoom:50%;" /><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>将样本从原始空间映射到一个更高维的特征空间，使样本在这个特征空间内线性可分（特征空间映射）</p><p>可以证明，如果原始空间是有限维，那么一定存在一个高维特征空间使得样本线性可分</p><h3 id="通过内积联系线性与非线性"><a href="#通过内积联系线性与非线性" class="headerlink" title="通过内积联系线性与非线性"></a>通过内积联系线性与非线性</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304092706511.webp" alt="image-20230304092706511" style="zoom:50%;" /><p>如图，两个二维样本在非线性函数作用下，得到六维特征空间的内积形式</p><h3 id="Kernel-trick"><a href="#Kernel-trick" class="headerlink" title="Kernel trick"></a>Kernel trick</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304093033299.webp" alt="image-20230304093033299" style="zoom:50%;" /><p><strong>限制条件</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304093246829.webp" alt="image-20230304093246829" style="zoom:50%;" /><h3 id="核支持向量机"><a href="#核支持向量机" class="headerlink" title="核支持向量机"></a>核支持向量机</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304093537351.webp" alt="image-20230304093537351" style="zoom:50%;" /><p><strong>核函数的种类</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304093612535.webp" alt="image-20230304093612535" style="zoom:50%;" /><p><strong>非线性核的例子</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304093733774.webp" alt="image-20230304093733774" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304093759599.webp" alt="image-20230304093759599" style="zoom:50%;" /><p><strong>关于超参数</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304093944568.webp" alt="image-20230304093944568" style="zoom:50%;" /><h2 id="多类支持向量机"><a href="#多类支持向量机" class="headerlink" title="多类支持向量机"></a>多类支持向量机</h2><p>思路：转化为二分类问题</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304094122394.webp" alt="image-20230304094122394" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304094144147.webp" alt="image-20230304094144147" style="zoom:50%;" /><p><strong>解决方案</strong></p><ul><li>Crammer-Singer 方法：<a href="http://jmlr.org/papers/v2/crammer01a.html">http://jmlr.org/papers/v2/crammer01a.html</a></li><li>DAGSVM：<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/dagsvm.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/dagsvm.pdf</a></li><li>ECOC：<a href="https://arxiv.org/pdf/cs/9501101.pdf">https://arxiv.org/pdf/cs/9501101.pdf</a></li></ul><h2 id="支持向量机的实现"><a href="#支持向量机的实现" class="headerlink" title="支持向量机的实现"></a>支持向量机的实现</h2><p>SVM Website：<a href="http://www.kernel-machines.org/">http://www.kernel-machines.org/</a></p><p>代表性实现 LIBSVM：有效且出名，实现了 muti-class classification，nu-SVM，one-class SVM 等，且有很多 Java、Python 等接口</p><h2 id="支持向量机的启发"><a href="#支持向量机的启发" class="headerlink" title="支持向量机的启发"></a>支持向量机的启发</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304094726817.webp" alt="image-20230304094726817" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230304094746716.webp" alt="image-20230304094746716" style="zoom:50%;" /><h2 id="前沿进展——持续学习"><a href="#前沿进展——持续学习" class="headerlink" title="前沿进展——持续学习"></a>前沿进展——持续学习</h2><h3 id="任务定义"><a href="#任务定义" class="headerlink" title="任务定义"></a>任务定义</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305150147185.webp" alt="image-20230305150147185" style="zoom:50%;" /><h3 id="灾难性遗忘"><a href="#灾难性遗忘" class="headerlink" title="灾难性遗忘"></a>灾难性遗忘</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305151055008.webp" alt="image-20230305151055008" style="zoom:50%;" /><h3 id="场景设定"><a href="#场景设定" class="headerlink" title="场景设定"></a>场景设定</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305151157804.webp" alt="image-20230305151157804" style="zoom:50%;" /><ul><li><p><strong>任务增量学习</strong></p><ul><li><p>不同时刻到来的数据分属于不同的任务，在一个时间段内我们可以获得当前任务的全部数据，并且假设测试推理阶段，任务的编号是可知的</p></li><li><p>因为测试阶段任务编号可知，所以训练阶段不同任务的输出相互独立，即最终学到的模型是多头的（multi-head），为每个任务提供单独的输出层</p></li></ul></li><li><p><strong>类别增量学习</strong></p><ul><li>不同时刻到来的数据属于同一类型任务的不同类别，随着训练的进行逐步增加输出类别，即<strong>类别空间是逐渐扩充的</strong></li><li>不同于任务增量学习场景，类别增量学习场景在测试阶段不知道任务的编号（训练阶段知道任务编号），比任务增量场景更具挑战性</li></ul></li><li><p><strong>域增量学习</strong></p><ul><li>不同时刻到来的数据集属于不同任务，但任务之间的<strong>类别空间是相同的</strong>，只是数据的<strong>分布（域）发生了变化</strong>，前后两个任务的数据不再满足独立同分布假设</li></ul></li></ul><h3 id="持续学习设置"><a href="#持续学习设置" class="headerlink" title="持续学习设置"></a>持续学习设置</h3><h4 id="常用数据集"><a href="#常用数据集" class="headerlink" title="常用数据集"></a>常用数据集</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305153343052.webp" alt="image-20230305153343052" style="zoom:50%;" /><h4 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305153315978.webp" alt="image-20230305153315978" style="zoom:50%;" /><h3 id="持续学习方法分类"><a href="#持续学习方法分类" class="headerlink" title="持续学习方法分类"></a>持续学习方法分类</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305153209815.webp" alt="image-20230305153209815" style="zoom:50%;" /><h3 id="大作业（Optional）"><a href="#大作业（Optional）" class="headerlink" title="大作业（Optional）"></a>大作业（Optional）</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305153519164.webp" alt="image-20230305153519164" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305153546632.webp" alt="image-20230305153546632" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230305153607991.webp" alt="image-20230305153607991" style="zoom:50%;" /><h1 id="神经元和感知机"><a href="#神经元和感知机" class="headerlink" title="神经元和感知机"></a>神经元和感知机</h1><h2 id="脑和神经元"><a href="#脑和神经元" class="headerlink" title="脑和神经元"></a>脑和神经元</h2><p><strong>MP神经元基本结构</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230318203358136.webp" alt="image-20230318203358136" style="zoom:50%;" /><h2 id="感知机和感知机学习"><a href="#感知机和感知机学习" class="headerlink" title="感知机和感知机学习"></a>感知机和感知机学习</h2><h2 id="线性可分性"><a href="#线性可分性" class="headerlink" title="线性可分性"></a>线性可分性</h2><h1 id="神经元网络"><a href="#神经元网络" class="headerlink" title="神经元网络"></a>神经元网络</h1><h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><h2 id="自动编码器"><a href="#自动编码器" class="headerlink" title="自动编码器"></a>自动编码器</h2><h2 id="径向基网络"><a href="#径向基网络" class="headerlink" title="径向基网络"></a>径向基网络</h2><h1 id="树学习"><a href="#树学习" class="headerlink" title="树学习"></a>树学习</h1><h2 id="概念学习和变型空间"><a href="#概念学习和变型空间" class="headerlink" title="概念学习和变型空间"></a>概念学习和变型空间</h2><p><strong>概念学习</strong></p><p>给定样例集合，以及每个样例是否属于某个概念，<strong>自动</strong>地推断出该概念的一般定义</p><p><strong>概念学习任务</strong></p><p>实例集合：用若干属性表示</p><p>目标概念$$c$$：定义在实例集上的布尔函数 $$c:X\rightarrow {0,1}$$</p><p>训练样例：正例$$(c(x)=1)$$，反例$$(c(x)=0)$$</p><p>假设集$$H$$：每个假设$$h$$表示$$X$$上定义的布尔函数$$h:X\rightarrow {0,1}$$</p><p>概念学习任务：寻找一个假设$$h$$，使对于$$X$$中说有$$x$$，$$h(x)=c(x)$$</p><p><strong>实例空间和假设数</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230318210112281.webp" alt="image-20230318210112281" style="zoom:50%;" /><p><strong>Find-S:寻找极大特殊假设</strong></p><blockquote><p>对以属性合取式表示的假设空间，输出与正例一致的最特殊的假设</p></blockquote><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230318210312848.webp" alt="image-20230318210312848" style="zoom:50%;" /><p><strong>变形空间</strong></p><p>假设h与训练样例D集合一致：$$Consistent(h,D)\equiv(\forall&lt;x,c(x)&gt;\in D)\space h(x)=c(x)$$</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331152536464.webp" alt="image-20230331152536464" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331152459947.webp" alt="image-20230331152459947" style="zoom:50%;" /><p><strong>正例和反例的作用</strong></p><ul><li>正例用于S泛化，搜索S集合</li><li>反例用于G特化，缩小G集合</li></ul><p><strong>候选消除算法</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331151459518.webp" alt="image-20230331151459518" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331151529211.webp" alt="image-20230331151529211" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331151556095.webp" alt="image-20230331151556095" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331151621870.webp" alt="image-20230331151621870" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331151642353.webp" alt="image-20230331151642353" style="zoom:50%;" /><h2 id="归纳偏置"><a href="#归纳偏置" class="headerlink" title="归纳偏置"></a>归纳偏置</h2><blockquote><p>原假设空间是由合取式（有偏）表示，而真实空间是由析取式表示</p></blockquote><p><strong>归纳偏置</strong></p><p>归纳学习必须给定某种形式的预先假定（归纳偏置）</p><p>核心：学习器从训练样例中泛化并推断新实例分类过程中所采用的策略</p><p>精确定义：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331152226050.webp" alt="image-20230331152226050" style="zoom:50%;" /><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2><h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>决策树学习特点：</p><ul><li><p>实例由“属性-值”对表示，应用广泛</p></li><li><p>目标函数具有离散的输出值</p></li><li><p>健壮性好（允许少量错误和缺值实例）</p></li><li><p>能够学习析取表达式</p></li></ul><p>决策树学习算法：</p><ul><li>ID3，Assistant，C4.5</li><li>搜索一个完整表示的假设空间，表示为多个 if-then 规则</li></ul><p>决策树学习归纳偏置：</p><ul><li>优先选择较小的树</li></ul><p>决策树表示样例：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331104838643.webp" alt="image-20230331104838643" style="zoom:40%;" /><h3 id="问题设置"><a href="#问题设置" class="headerlink" title="问题设置"></a>问题设置</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331104941643.webp" alt="image-20230331104941643" style="zoom:50%;" /><h3 id="决策树学习的假设空间搜索"><a href="#决策树学习的假设空间搜索" class="headerlink" title="决策树学习的假设空间搜索"></a>决策树学习的假设空间搜索</h3><ul><li>从一个假设空间中搜索一个正确拟合训练样例的假设</li><li>搜索的假设空间为可能的决策树集合</li><li>使用从简单到复杂的爬山算法遍历假设空间：从空的树开始，逐步考虑更加复杂的假设（引导爬山搜索的评估函数是信息增益度量）</li></ul><h3 id="用于学习布尔函数的ID3算法"><a href="#用于学习布尔函数的ID3算法" class="headerlink" title="用于学习布尔函数的ID3算法"></a>用于学习布尔函数的ID3算法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331105509995.webp" alt="image-20230331105509995" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331105534888.webp" alt="image-20230331105534888" style="zoom:50%;" /><h3 id="最佳属性的选择"><a href="#最佳属性的选择" class="headerlink" title="最佳属性的选择"></a>最佳属性的选择</h3><ul><li>衡量给定的属性区分训练样例的能力：信息增益（information gain）</li><li>信息的度量：熵（entropy），刻画了样例集的纯度</li><li>目标属性为布尔值的样例集S的熵：$$Entropy(S)=-p_+ log_2 p_+ -p_- log_2 p_-$$ </li></ul><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331110352074.webp" alt="image-20230331110352074" style="zoom:50%;" /><h3 id="ID3算法特点"><a href="#ID3算法特点" class="headerlink" title="ID3算法特点"></a>ID3算法特点</h3><ul><li>假设空间：包含所有的决策树</li><li>遍历过程：仅维持单一的当前假设（不同于变形空间候选消除算法）</li><li>回溯：不进行回溯（局部最优）</li><li>基于统计：对错误样例不敏感；不适用于增量处理</li></ul><h3 id="决策树学习中的归纳偏置"><a href="#决策树学习中的归纳偏置" class="headerlink" title="决策树学习中的归纳偏置"></a>决策树学习中的归纳偏置</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331110825102.webp" alt="image-20230331110825102" style="zoom:50%;" /><h3 id="奥卡姆剃刀原理"><a href="#奥卡姆剃刀原理" class="headerlink" title="奥卡姆剃刀原理"></a>奥卡姆剃刀原理</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331110928813.webp" alt="image-20230331110928813" style="zoom:50%;" /><h3 id="代表性树算法对比"><a href="#代表性树算法对比" class="headerlink" title="代表性树算法对比"></a>代表性树算法对比</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331111027678.webp" alt="image-20230331111027678" style="zoom:50%;" /><h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331113021181.webp" alt="image-20230331113021181" style="zoom:50%;" /><h3 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331113048888.webp" alt="image-20230331113048888" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331113115865.webp" alt="image-20230331113115865" style="zoom:50%;" /><h3 id="基尼系数"><a href="#基尼系数" class="headerlink" title="基尼系数"></a>基尼系数</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331112633813.webp" alt="image-20230331112633813" style="zoom:50%;" /><h3 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h3><p><strong>连续的特征离散化</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331112713592.webp" alt="image-20230331112713592" style="zoom:50%;" /><h3 id="离散值处理"><a href="#离散值处理" class="headerlink" title="离散值处理"></a>离散值处理</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331112755659.webp" alt="image-20230331112755659" style="zoom:50%;" /><h3 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h3><h4 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331112858597.webp" alt="image-20230331112858597" style="zoom:50%;" /><h4 id="最小化子树的损失函数"><a href="#最小化子树的损失函数" class="headerlink" title="最小化子树的损失函数"></a>最小化子树的损失函数</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331112945689.webp" alt="image-20230331112945689" style="zoom:50%;" /><h3 id="树学习算法优点"><a href="#树学习算法优点" class="headerlink" title="树学习算法优点"></a>树学习算法优点</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331111339376.webp" alt="image-20230331111339376" style="zoom:50%;" /><h3 id="树学习算法缺点"><a href="#树学习算法缺点" class="headerlink" title="树学习算法缺点"></a>树学习算法缺点</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331111320360.webp" alt="image-20230331111320360" style="zoom:50%;" /><h3 id="决策树的延申"><a href="#决策树的延申" class="headerlink" title="决策树的延申"></a>决策树的延申</h3><h4 id="深度学习时代的决策树"><a href="#深度学习时代的决策树" class="headerlink" title="深度学习时代的决策树"></a>深度学习时代的决策树</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331112339128.webp" alt="image-20230331112339128" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331112433745.webp" alt="image-20230331112433745" style="zoom:50%;" /><h2 id="作业三：决策树"><a href="#作业三：决策树" class="headerlink" title="作业三：决策树"></a>作业三：决策树</h2><p>要求：给定药品数据集构造决策树，并用 Micro-F1 和 Macro-F1 分数进行验证集评估，预测测试集中的药品等级。</p><p>数据集说明：</p><ul><li>csv 数据集中包含有关药品的各种属性，文件中可能包含“脏”数据，药品等级分为5级（1~5）</li><li>训练集：6999条数据；验证集：1199条数据；测试集：1798条数据</li></ul><p><strong>代码展示</strong>：<a href="https://github.com/Ling-Yuchen/ML-hw/blob/main/decision_tree.py">https://github.com/Ling-Yuchen/ML-hw/blob/main/decision_tree.py</a></p><h3 id="实验报告-1"><a href="#实验报告-1" class="headerlink" title="实验报告"></a>实验报告</h3><h4 id="数据的分析与处理"><a href="#数据的分析与处理" class="headerlink" title="数据的分析与处理"></a>数据的分析与处理</h4><p>给定数据集的每一个数据项的结构如下：</p><p><em>recordId | drugName | condition | reviewComment | date | usefulCount | sideEffects | rating</em></p><p>其中，<em>rating</em> 是需要进行学习的分类标记，根据常识进行判断，<em>recordId | drugName | date</em> 属于无效字段，<em>reviewComment</em> 包含大量自然语言，难以进行概括性的标准化的归纳处理，故初步将 <em>condition | usefulCount | sideEffects</em> 作为待定的分类主要属性依据</p><p>经过尝试，选取 <em>condition | sideEffects</em> 两个属性作为分类依据得到的验证数据效果最好，故在数据处理时，对每一条记录，只保留 <em>condition | sideEffects | rating</em> 三个属性的信息</p><p>具体处理流程见代码中的 <code>read_data</code> 方法</p><h4 id="决策树的设计原理"><a href="#决策树的设计原理" class="headerlink" title="决策树的设计原理"></a>决策树的设计原理</h4><ul><li>基于信息增益选择最优特征</li></ul><p>ID3 算法的核心思想是通过计算每个特征的信息增益，选择最优的特征来构建决策树。信息增益是用来衡量一个特征对分类结果的影响程度的指标，其值越大表示该特征对分类的贡献越大。在每个节点上，ID3 算法会计算每个特征的信息增益，并选择信息增益最大的特征作为节点的划分标准。</p><ul><li>递归地构建决策树</li></ul><p>在选择最优特征后，ID3算法会根据该特征的取值将当前节点分成多个子节点，并递归地对每个子节点进行相同的操作，直到所有叶子节点的类别相同或者无法再分。</p><ul><li>处理缺失值和连续值</li></ul><p>在处理缺失值时，ID3算法将缺失值看作一种特殊的取值，同时计算信息增益时不考虑缺失值所对应的分支。在处理连续值时，ID3算法需要对连续值进行离散化，将其分成若干个离散的取值，然后再计算信息增益。</p><p>（核心代码略）</p><h4 id="验证集评估结果"><a href="#验证集评估结果" class="headerlink" title="验证集评估结果"></a>验证集评估结果</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230321152606188.webp" alt="image-20230321152606188" style="zoom:70%;" /><h1 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h1><h2 id="集成学习原理"><a href="#集成学习原理" class="headerlink" title="集成学习原理"></a>集成学习原理</h2><p><strong>原理</strong></p><ul><li>将多个个体学习器通过结合模块相结合，得到一个综合的输出</li><li>是一个预测模型的元方法</li></ul><p><strong>特点</strong></p><ul><li>多个分类器集成在一起，以提高分类准确率</li><li>由训练数据构建基分类器，然后根据预测结果进行投票</li><li>集成学习本身不是一种分类器，而是分类器结合方法</li><li>通常集成分类器性能会好于单个分类器</li></ul><p><strong>举例分析</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331190833225.webp" alt="image-20230331190833225" style="zoom:50%;" /><p><strong>Bias-Variance trade-off</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331191106544.webp" alt="image-20230331191106544" style="zoom:50%;" /><p><strong>核心问题</strong></p><ul><li>序列集成法<ul><li>利用基学习器之间的依赖关系，依次生成</li><li>减小偏差 bias</li></ul></li><li>并行集成法<ul><li>利用基学习器之间的独立关系，并行生成</li><li>减小方差 variance</li></ul></li></ul><p><em>Q1：如何训练每个学习器</em></p><p><em>Q2：如何结合每个学习器</em></p><p><strong>结合策略</strong></p><ul><li>平均法（回归问题）：简单平均 / 加权平均</li><li>投票法（分类问题）：绝对多数 / 相对多数 / 加权投票</li><li>学习法（Stacking）</li></ul><p><strong>多样性策略</strong>（学习基学习器）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331191932431.webp" alt="image-20230331191932431" style="zoom:50%;" /><h2 id="Bagging和随机森林"><a href="#Bagging和随机森林" class="headerlink" title="Bagging和随机森林"></a>Bagging和随机森林</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>有放回采样方法（统计上的目的是得到统计量分布以及置信区间）</p><h3 id="Bagging集成学习框架"><a href="#Bagging集成学习框架" class="headerlink" title="Bagging集成学习框架"></a>Bagging集成学习框架</h3><img src="http://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331192215585.webp" alt="image-20230331192215585" style="zoom:50%;" /><h3 id="Bagging集成学习优点"><a href="#Bagging集成学习优点" class="headerlink" title="Bagging集成学习优点"></a>Bagging集成学习优点</h3><img src="http://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331192548627.webp" alt="image-20230331192548627" style="zoom:50%;" /><h3 id="随机森林算法"><a href="#随机森林算法" class="headerlink" title="随机森林算法"></a>随机森林算法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331192659991.webp" alt="image-20230331192659991" style="zoom:50%;" /><img src="http://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331192726798.webp" alt="image-20230331192726798" style="zoom:50%;" /><h2 id="Boosting和GBDT、XGboost"><a href="#Boosting和GBDT、XGboost" class="headerlink" title="Boosting和GBDT、XGboost"></a>Boosting和GBDT、XGboost</h2><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><p>可以通过提升方法（Boosting）将弱学习器转为强学习器</p><h3 id="Boosting集成学习框架"><a href="#Boosting集成学习框架" class="headerlink" title="Boosting集成学习框架"></a>Boosting集成学习框架</h3><img src="http://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331192908421.webp" alt="image-20230331192908421" style="zoom:50%;" /><h3 id="前向分步加法模型"><a href="#前向分步加法模型" class="headerlink" title="前向分步加法模型"></a>前向分步加法模型</h3><ul><li>加法模型及其目标函数</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331213338867.webp" alt="image-20230331213338867" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331213356923.webp" alt="image-20230331213356923" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331213449009.webp" alt="image-20230331213449009" style="zoom:50%;" /><ul><li>前向分布算法</li></ul><p>学习目标函数为加法模型，如果能够从前向后，每一步只学习一个基函数及其系数，逐步逼近要优化的总目标函数，就可以简化优化的复杂度</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331213646916.webp" alt="image-20230331213646916" style="zoom:50%;" /><p><strong>残差</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331213914616.webp" alt="image-20230331213914616" style="zoom:50%;" /><h3 id="提升树"><a href="#提升树" class="headerlink" title="提升树"></a>提升树</h3><p>以决策树为基函数的提升方法成为提升树（Boosting Tree）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331213817564.webp" alt="image-20230331213817564" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331213947622.webp" alt="image-20230331213947622" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331214019396.webp" alt="image-20230331214019396" style="zoom:50%;" /><h3 id="梯度提升树-GBDT"><a href="#梯度提升树-GBDT" class="headerlink" title="梯度提升树 GBDT"></a>梯度提升树 GBDT</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331214109628.webp" alt="image-20230331214109628" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331214144745.webp" alt="image-20230331214144745" style="zoom:50%;" /><p><strong>GBDT例子</strong></p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331214333965.webp" alt="image-20230331214333965" style="zoom:30%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331214359166.webp" alt="image-20230331214359166" style="zoom:30%;" /></center><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331214422717.webp" alt="image-20230331214422717" style="zoom:33%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331214446054.webp" alt="image-20230331214446054" style="zoom:33%;" /></center>### XGBoost<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331214712395.webp" alt="image-20230331214712395" style="zoom:50%;" /><p><strong>树的复杂度</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331215357782.webp" alt="image-20230331215357782" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331215422130.webp" alt="image-20230331215422130" style="zoom:50%;" /><p><strong>目标函数</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331215446907.webp" alt="image-20230331215446907" style="zoom:50%;" /><p><strong>树的打分和分裂</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331215511166.webp" alt="image-20230331215511166" style="zoom:50%;" /><h2 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h2><p><strong>概率近似正确学习理论（PCA）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331222054923.webp" alt="image-20230331222054923" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331222122135.webp" alt="image-20230331222122135" style="zoom:50%;" /><p><strong>Adaptive Boost</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331222213356.webp" alt="image-20230331222213356" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331222246368.webp" alt="image-20230331222246368" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331222309457.webp" alt="image-20230331222309457" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331222333840.webp" alt="image-20230331222333840" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331222357634.webp" alt="image-20230331222357634" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331222421007.webp" alt="image-20230331222421007" style="zoom:50%;" /><h2 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h2><h3 id="Stacking算法"><a href="#Stacking算法" class="headerlink" title="Stacking算法"></a>Stacking算法</h3><p><strong>算法原理</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331221106823.webp" alt="image-20230331221106823" style="zoom:50%;" /><p><strong>算法流程</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331221144470.webp" alt="image-20230331221144470" style="zoom:50%;" /><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331221249286.webp" alt="image-20230331221249286" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331221311224.webp" alt="image-20230331221311224" style="zoom:50%;" /><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230331221406391.webp" alt="image-20230331221406391" style="zoom:50%;" /><h1 id="优化和搜索"><a href="#优化和搜索" class="headerlink" title="优化和搜索"></a>优化和搜索</h1><p>略</p><h1 id="维度约减"><a href="#维度约减" class="headerlink" title="维度约减"></a>维度约减</h1><p>略</p><h1 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h1><p>略</p><h1 id="演化学习"><a href="#演化学习" class="headerlink" title="演化学习"></a>演化学习</h1><p>略</p><h1 id="复习要点"><a href="#复习要点" class="headerlink" title="复习要点"></a>复习要点</h1><p><strong>误差反向传播</strong></p><p>以输入数据为一个二维坐标、输出数据为一个标签值为例，</p><p>记输入为 $(x_1,x_2)$，真实输出为 $y$，正确输出为 $y’$，使用的激活函数为 $\phi(x)$，第 $L$ 层第 $k$ 个神经元的权重为 $w^L_{k1}$,…, $w^L_{kn}$，对应接收的输入为 $a^{L-1}_1$,…, $a^{L-1}_n$，激活前输出为 $z^L_k$，激活后输出为 $a^L_k$</p><p>记第 $L$ 层第 $k$ 个神经元的 $delta$ 误差为 $\Delta_k^L$，则有：</p><ul><li>若第 $L$ 层为输出层，$D_k^L=\phi’(z_k^L)\times(y’-y)$</li><li>若第 $L$ 层为输出层，$D_k^L=\phi’(z_k^L)\times\sum_i(D_i^{L+1}w_{ik}^{L+1})$</li></ul><p>从而，$\Delta w_{ki}^L=\alpha\times D_k^L\times a^{L-1}_i$</p><p>更新权值：$w_{ki}^L=w_{ki}^L-\Delta w_{ki}^L$</p><p><strong>ID3 决策树算法</strong></p><p>以实例标签为布尔值为例，</p><p>信息熵计算：$Ent(S)=-\sum_i\space p_ilog_2p_i$，其中 $S$ 为样本集合，$p_i$ 为标签 $i$ 出现的概率</p><p>信息增益计算：$Gain(S,A)=Ent(S)-\sum_v\frac{|S_v|}{|S|}Ent(S_v)$，其中 $A$ 为作为分割标准的属性，$v$ 为该属性的取值</p><p>递归构建决策树：</p><ul><li>若当前样本集中所有实例的标签相同，则 root 赋值为改标签，返回</li><li>否则，若没有可继续分割样本集的属性，则投票选出样本集中最多的标签，root 赋值为该标签，返回</li><li>否则，选取信息增益最大的属性，作为 root 的决策属性，以该属性的值为依据，分割样本集为若干子样本集</li><li>若子样本集中有空集，则增加一个叶节点，以样本集中出现最多的标签作为其标签</li><li>否则在该分支下依据子样本集和子属性集增加对应的子树</li></ul><p><strong>MDP 模型</strong></p><p>$V^{\pi}(s)$：从 $s$ 状态出发，采用 $π$ 策略，所获得的期望返回值</p><p>$Q^{\pi}(s,a)$：从 $s$ 状态出发， 采用 $a$动作，继而采用 $π$ 策略，所获得的期望返回值</p><p>$V^{\pi}(s)=Q^{\pi}(s,\pi(s,a))$</p><ul><li><p>策略评估：计算 $V^{\pi}(s)=E(R(s,\pi(s)))+\gamma\space\sum_{s’}\space\delta(s,\pi(s),s’)V^{\pi}(s’)$，</p></li><li><p>最优控制：计算 $Q^{\pi}(s,a)=E(R(s,a))+\gamma\space\sum_{s’}\space\delta(s,a,s’)V^{\pi}(s’)$</p><ul><li>修改策略：$\pi(s)=argmax_a(Q^{\pi}(s,a))$（贪心策略） 或（$\epsilon$-贪心策略）</li></ul></li></ul><p><strong>KNN 算法</strong></p><p>k近邻分类：</p><ul><li>计算样本 $x$ 和所有训练样本 $x_i$ 之间的距离并排序</li><li>选取 k 个最近的训练样本，采用投票法，将近邻样本中数量最多的类标签分配给 $x$</li></ul><p>k近邻回归：</p><ul><li>计算样本 $x$ 和所有训练样本 $x_i$ 之间的距离并排序</li><li>选取 k 个最近的训练样本，以距离值倒数作为权重，将近邻的标签值加权平均，作为 $x$ 的预测标签值</li></ul><p>训练阶段时间复杂度为 0，测试阶段时间复杂度：$O(nd+nlogk)$</p><p><strong>LDA 算法基本流程</strong></p><ul><li>计算每个类的均值向量 $\mu_c$ 和全局样本的均值向量 $\mu$</li><li>计算类内散度矩阵 $S_w=\sum_{class\space c}p_c\sum_{j\in c}(x_j-\mu_c)(x_j-\mu_c)^T$</li><li>计算类间散度矩阵 $S_b=\sum_{class\space c}(\mu_c-\mu)(\mu_c-\mu)^T$</li><li>计算矩阵 $S_w^{-1}S_b$ 并计算其特征值和特征向量</li><li>根据需要取若干最大特征值对应的特征向量组成投影矩阵</li></ul><p><strong>PCA 算法基本流程</strong></p><ul><li>计算样本的均值向量 $\mu$，并将样本去中心化：$x_i=x_i-\mu$</li><li>计算样本的协方差矩阵 $C=\sum_ix_ix_i^T=XX^T$</li><li>计算协方差矩阵 $C$ 的特征值和特征向量</li><li>根据需要取若干最大特征值对应的特征向量组成投影矩阵</li></ul><p><strong>牛顿法迭代优化算法流程</strong></p><p>根据当前迭代点 $x_k$ 计算雅可比矩阵和海森矩阵：$J_k=J(f(x))|<em>{x=x_k}$，$H_k=H(f(x))|</em>{x=x_k}$ </p><p>计算 $p_k=-H_k^{-1}J_k^T$，得到新的迭代点 $x_{k+1}=x_k+p_k$，直至 $||J_k||\le\epsilon$ 为止</p><p><strong>最小二乘法迭代优化算法流程</strong></p><p>目标函数的形式为：$f(x)=\frac{1}{2}\sum_{j=1}^{m}r^2_j(x)=\frac{1}{2}||r(x)||_2^2$</p><p>根据当前迭代点 $x_k$，有：$x_{k+1}=-(J^T(x)J(x))^{-1}J^T(x)r(x)|_{x=x_k}$，其中 $J(x)$ 为函数 $r(x)$ 的雅可比矩阵</p>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《商务智能》复习笔记</title>
      <link href="/2022/12/31/NJU-Business-Intelligence-Review/"/>
      <url>/2022/12/31/NJU-Business-Intelligence-Review/</url>
      
        <content type="html"><![CDATA[<h1 id="商务智能复习"><a href="#商务智能复习" class="headerlink" title="商务智能复习"></a>商务智能复习</h1><p><strong>什么是商务智能</strong></p><ul><li>商务智能完成数据到信息的转变，将不同系统的数据汇聚成一个单一且可获取的数据源（数据仓库），向客户提供工具包对数据仓库中的数据进行分析并可视化展示</li><li>商务智能通过访问、钻研、分析和挖掘数据获取启发和了解，（改善数据访问），从而提供更完善、更全面考虑的决策支持（提供决策支持）</li></ul><p><strong>事务处理环境不适宜分析型应用的原因</strong></p><ul><li>事务处理和分析处理的性能特性不同<ul><li>事务处理每次操作时间短，数据量小，频率高，并发度大</li><li>分析处理每次运行时间长，数据量大，频率低，没有并发要求</li></ul></li><li>数据集成问题<ul><li>分析处理的数据源广泛，事务处理只关注业务相关的细节数据</li><li>数据集成中会遇到“蜘蛛网”问题，数据不一致性问题，缺少外部数据等</li><li>分散而复杂的数据会造成重复计算，降低分析处理效率，也加重程序员负担</li></ul></li><li>数据的动态集成问题<ul><li>用于决策的数据必须动态集成，事务处理环境不支持</li></ul></li><li>历史数据问题<ul><li>分析处理更看重历史数据，事务处理只需要当前数据</li><li>事务处理环境无法保留所有历史数据记录</li></ul></li><li>数据的综合问题<ul><li>事务处理系统含有大量细节数据，不具备对数据进行综合的能力</li></ul></li><li>数据的访问问题<ul><li>事务处理需要提供多种数据访问操作，需要实时更新</li><li>分析处理以读操作为主，不需要实时更新，需要定期刷新</li></ul></li></ul><p><strong>什么是数据仓库</strong></p><ul><li>数据仓库就是一个面向主题的、集成的、非易失的、时变的数据集合，用于支持经营管理过程中的决策制定<ul><li>面向主题：数据仓库内的信息是按主题进行组织的，为按主题进行决策的过程提供信息</li><li>集成的：数据仓库的数据必须从多个数据源中获取</li><li>非易失的：数据仓库的数据与操作性数据环境隔离</li><li>时变的：数据仓库中的数据通常都带有时间属性，必须以一定时间段为单位进行统一更新</li></ul></li></ul><p><strong>数据刷新的方法</strong></p><ul><li>时间戳：数据库中的记录有时间属性时可使用</li><li>DELTA 文件：使用基于 OLTP 数据库的操作型应用程序在工作过程中形成的 DELTA 文件，效率高</li><li>建立映象文件：比较数据库快照，占用大量系统资源</li><li>日志文件：使用 OLTP 数据库的日志信息，效率更高</li></ul><p><strong>ETL 技术是什么，在数据仓库架构中完成了什么任务</strong></p><ul><li>数据的抽取/转换/装载技术</li><li>将各种数据源中的数据经过处理后集成到数据仓库中</li></ul><p><strong>什么是数据仓库的粒度，为什么使用多重粒度</strong></p><ul><li>对数据仓库中数据的综合程度的一个度量</li><li>使用多重粒度，应对不同级别的粒度要求<ul><li>大粒度数据：快速存储设备，提高性能</li><li>小粒度数据：低速存储设备，满足细节查询</li></ul></li></ul><p><strong>数据仓库有哪些数据组织形式</strong></p><ul><li>简单堆积文件</li><li>轮转综合文件</li><li>简化直接文件</li><li>连续文件</li></ul><p><strong>为什么要建立数据集市，如何建立数据集市</strong></p><ul><li><p>全局性数据仓库往往太大，在实际应用中将它们按部门或个人分别建立反映各个子主题与区域的局部性数据组织，即数据集市</p></li><li><p>数据集市的数据来源于数据仓库，专门用以满足特定商务单元、商务程序、或商务应用的需求</p></li><li><p>自顶向下的结构</p><ul><li>建立数据集市能够减轻 DW 访问负载</li><li>各部门可以任意处理数据</li><li>数据转换和整合在 DW 阶段统一完成</li><li>具备数据缓冲功能</li><li>成本高、见效慢、数据集市间不共享资源</li></ul></li><li><p>自底向上的结构</p><ul><li>见效快、启动资金少</li><li>各个部门都要进行数据清理整合</li><li>可能造成“蜘蛛网”、数据不一致等问题</li><li>并且总体上没有节约资金</li></ul></li><li><p>总线结构的数据集市</p><ul><li>共享维表和事实表，解决了建立数据集市的许多问题</li><li>这种结构基于多维模型，应用限制于OLAP</li><li>多个数据源直接影响多个集市，造成数据仓库结构不十分稳定</li></ul></li><li><p>企业级数据集市结构</p><ul><li>略</li></ul></li></ul><p><strong>如何提高 ROLAP 中的处理效率</strong></p><ul><li>采用物化视图方式</li><li>采用特殊的索引与集簇方式，以加速星型模式内表的连接速度</li><li>尽量采用并行操作方式</li><li>采用 OLAP 中的查询优化技术，如共享排序技术等</li><li>采用增量技术，在 OLAP 数据更新时保留不变的数据，仅更改变动的数据以加快数据更新速度</li></ul><p><strong>数据仓库物理模型设计的优化技术</strong></p><ul><li>合并表</li><li>建立数据序列</li><li>引入冗余</li><li>表的物理分割</li><li>生成导出数据</li><li>建立广义索引</li></ul><p><strong>数据仓库设计的原则</strong></p><ul><li>面向主题原则<ul><li>从用户决策的主观需求（主题）开始</li><li>以主题为起始点，进行相关数据的设计，最终建立起一个面向主题的分析型环境</li></ul></li><li>数据驱动原则<ul><li>从已有的数据库系统出发</li><li>按照分析领域对数据及数据间的联系重新考察</li><li>利用数据模型有效识别原有数据库中的数据和数据仓库中主题的数据的“共同性”</li></ul></li><li>原型法设计原则<ul><li>从构建系统的基本框架着手，不断丰富与完善整个系统</li><li>数据仓库系统的开发是一个经过不断循环、反馈而使系统不断增长与完善的过程</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 商务智能 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《编译原理》课程笔记</title>
      <link href="/2022/12/04/NJU-Compiler-Principle/"/>
      <url>/2022/12/04/NJU-Compiler-Principle/</url>
      
        <content type="html"><![CDATA[<p>课程内容链接：<a href="https://space.bilibili.com/479141149/channel/collectiondetail?sid=837891">https://space.bilibili.com/479141149/channel/collectiondetail?sid=837891</a></p><p>课程实验代码：<a href="https://github.com/Ling-Yuchen/compiler-hw">https://github.com/Ling-Yuchen/compiler-hw</a></p><h1 id="00-编译原理概述"><a href="#00-编译原理概述" class="headerlink" title="00 - 编译原理概述"></a>00 - 编译原理概述</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282053376.png" alt="image-20221128205347262" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282055145.png" alt="image-20221128205501109" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282055462.png" alt="image-20221128205542408" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282057868.png" alt="image-20221128205745813" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282058394.png" alt="image-20221128205833346" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282059066.png" alt="image-20221128205905002" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282059640.png" alt="image-20221128205957585" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282100571.png" alt="image-20221128210026532" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282101881.png" alt="image-20221128210102832" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282101118.png" alt="image-20221128210144056" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282102388.png" alt="image-20221128210257332" style="zoom:50%;" /><h1 id="01-词法分析器生成器"><a href="#01-词法分析器生成器" class="headerlink" title="01 - 词法分析器生成器"></a>01 - 词法分析器生成器</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282108315.png" alt="image-20221128210809272" style="zoom:50%;" /><p>使用 ANTLR 工具编写词法分析器生成器：</p><ul><li>输入：词法单元的归约 <code>SysYLexer.g4</code></li><li>输出：词法分析器 <code>SysYLexer.tokens</code>，<code>SysYLexer.interp</code>，<code>SysYLexer.java</code></li></ul><p>样例：（来自 lab1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar SysYLexer;</span><br><span class="line"></span><br><span class="line">CONST : &#x27;const&#x27;;</span><br><span class="line">INT : &#x27;int&#x27;;</span><br><span class="line">VOID : &#x27;void&#x27;;</span><br><span class="line">IF : &#x27;if&#x27;;</span><br><span class="line">ELSE : &#x27;else&#x27;;</span><br><span class="line">WHILE : &#x27;while&#x27;;</span><br><span class="line">BREAK : &#x27;break&#x27;;</span><br><span class="line">CONTINUE : &#x27;continue&#x27;;</span><br><span class="line">RETURN : &#x27;return&#x27;;</span><br><span class="line">MUL : &#x27;*&#x27;;</span><br><span class="line">DIV : &#x27;/&#x27;;</span><br><span class="line">MOD : &#x27;%&#x27;;</span><br><span class="line">PLUS : &#x27;+&#x27;;</span><br><span class="line">MINUS : &#x27;-&#x27;;</span><br><span class="line">ASSIGN : &#x27;=&#x27;;</span><br><span class="line">EQ : &#x27;==&#x27;;</span><br><span class="line">NEQ : &#x27;!=&#x27;;</span><br><span class="line">LT : &#x27;&lt;&#x27;;</span><br><span class="line">GT : &#x27;&gt;&#x27;;</span><br><span class="line">LE : &#x27;&lt;=&#x27;;</span><br><span class="line">GE : &#x27;&gt;=&#x27;;</span><br><span class="line">NOT : &#x27;!&#x27;;</span><br><span class="line">AND : &#x27;&amp;&amp;&#x27;;</span><br><span class="line">OR : &#x27;||&#x27;;</span><br><span class="line">L_PAREN : &#x27;(&#x27;;</span><br><span class="line">R_PAREN : &#x27;)&#x27;;</span><br><span class="line">L_BRACE : &#x27;&#123;&#x27;;</span><br><span class="line">R_BRACE : &#x27;&#125;&#x27;;</span><br><span class="line">L_BRACKT : &#x27;[&#x27;;</span><br><span class="line">R_BRACKT : &#x27;]&#x27;;</span><br><span class="line">COMMA : &#x27;,&#x27;;</span><br><span class="line">SEMICOLON : &#x27;;&#x27;;</span><br><span class="line">IDENT : ([_a-zA-Z])([_a-zA-Z0-9])*;</span><br><span class="line">INTEGR_CONST : [1-9][0-9]*</span><br><span class="line">               | &#x27;0&#x27;</span><br><span class="line">               | &#x27;0&#x27;([0-7])+</span><br><span class="line">               | &#x27;0&#x27;(&#x27;x&#x27;|&#x27;X&#x27;)[0-9a-fA-F]+;</span><br><span class="line">WS : [ \r\n\t]+ -&gt; skip;</span><br><span class="line">LINE_COMMENT :  &#x27;//&#x27; .*? &#x27;\n&#x27; -&gt; skip;</span><br><span class="line">MULTILINE_COMMENT : &#x27;/*&#x27; .*? &#x27;*/&#x27; -&gt; skip;</span><br></pre></td></tr></table></figure><p>一些定义：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282125772.png" alt="image-20221128212525749" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282126328.png" alt="image-20221128212605291" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282126735.png" alt="image-20221128212645712" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282127006.png" alt="image-20221128212712972" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282127118.png" alt="image-20221128212748099" style="zoom:50%;" /><p>能够在语言（集合）上进行的操作：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282129204.png" alt="image-20221128212950178" style="zoom:50%;" /><p>正则表达式：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282137348.png" alt="image-20221128213723288" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282139380.png" alt="image-20221128213934333" style="zoom:50%;" /><h1 id="02-手写词法分析器"><a href="#02-手写词法分析器" class="headerlink" title="02 - 手写词法分析器"></a>02 - 手写词法分析器</h1><p>略</p><h1 id="03-自动机理论与词法分析器生成器"><a href="#03-自动机理论与词法分析器生成器" class="headerlink" title="03 - 自动机理论与词法分析器生成器"></a>03 - 自动机理论与词法分析器生成器</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282143290.png" alt="image-20221128214349235" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282144646.png" alt="image-20221128214448586" style="zoom:50%;" /><h2 id="目标：RE-to-Lexer"><a href="#目标：RE-to-Lexer" class="headerlink" title="目标：RE to Lexer"></a>目标：RE to Lexer</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282146730.png" alt="image-20221128214604688" style="zoom:50%;" /><p>RE：正则表达式</p><p><strong>NFA：不确定的有穷自动机（简洁易于理解，便于描述语言 L(A)）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282200473.png" alt="image-20221128220050425" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282201287.png" alt="image-20221128220127256" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291448454.png" alt="image-20221129144808425" style="zoom:50%;" /><p>其不确定性在于：</p><ul><li>在同一状态下，看到相同的字符，可以转移到不同的状态</li><li>没有看到任何字符（看到 ε），也有可以发生状态的转移</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291442048.png" alt="image-20221129144244929" style="zoom:50%;" /><p><strong>DFA：确定的有穷自动机（易于判断 x ∈ L(A)，适合产生词法分析器）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291450677.png" alt="image-20221129145044628" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291451092.png" alt="image-20221129145111066" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291457324.png" alt="image-20221129145709299" style="zoom:50%;" /><p><strong>约定</strong>：所有没有对应出边的字符默认指向一个<strong>“死状态”</strong>（不可能再被接收）</p><p>其确定性在于：</p><ul><li>只对字符表中的字符做状态转移</li><li>每个状态下对每个字符都有唯一的状态转移</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291501221.png" alt="image-20221129150132187" style="zoom:67%;" /><h3 id="Thompson-构造法（RE-to-NFA）"><a href="#Thompson-构造法（RE-to-NFA）" class="headerlink" title="Thompson 构造法（RE to NFA）"></a>Thompson 构造法（RE to NFA）</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291502065.png" alt="image-20221129150222036" style="zoom:50%;" /><p>依据<strong>正则表达式的定义</strong>，分步处理：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291505728.png" alt="image-20221129150515701" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291505372.png" alt="image-20221129150548348" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291507400.png" alt="image-20221129150700360" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291508066.png" alt="image-20221129150811023" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291508063.png" alt="image-20221129150848024" style="zoom:60%;" /><p>分析：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291510172.png" alt="image-20221129151046116" style="zoom:50%;" /><p>例子：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291511497.png" alt="image-20221129151138451" style="zoom:70%;" /><h3 id="子集构造法（NFA-to-DFA）"><a href="#子集构造法（NFA-to-DFA）" class="headerlink" title="子集构造法（NFA to DFA）"></a>子集构造法（NFA to DFA）</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291538851.png" alt="image-20221129153848792" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291544262.png" alt="image-20221129154444220" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291551492.png" alt="image-20221129155102446" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291552560.png" alt="image-20221129155217511" style="zoom:50%;" /><h3 id="DFA-最小化（DFA-to-最简等价DFA）"><a href="#DFA-最小化（DFA-to-最简等价DFA）" class="headerlink" title="DFA 最小化（DFA to 最简等价DFA）"></a>DFA 最小化（DFA to 最简等价DFA）</h3><p>DFA 最小化的基本思想：等价的状态可以合并</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291557771.png" alt="image-20221129155713732" style="zoom:50%;" /><p>出发点：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291600819.png" alt="image-20221129160003787" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291600681.png" alt="image-20221129160054643" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291601749.png" alt="image-20221129160129715" style="zoom:50%;" /><p>DFA 最小化算法总结：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291602641.png" alt="image-20221129160220576" style="zoom:50%;" /><p>算法要在严格定义的 DFA 上执行，<strong>注意</strong>要先检查是否需要补全“死状态”</p><h3 id="Kleene-构造法（DFA-to-RE）"><a href="#Kleene-构造法（DFA-to-RE）" class="headerlink" title="Kleene 构造法（DFA to RE）"></a>Kleene 构造法（DFA to RE）</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281129810.png" alt="image-20221228112928764" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281130112.png" alt="image-20221228113052063" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281138528.png" alt="image-20221228113839478" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281140716.png" alt="image-20221228114004685" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281142943.png" alt="image-20221228114257896" style="zoom:50%;" /><h2 id="词法分析器生成"><a href="#词法分析器生成" class="headerlink" title="词法分析器生成"></a>词法分析器生成</h2><p><strong>遵循规则：最前优先匹配，最长优先匹配</strong></p><ul><li><p>根据正则表达式构造相应的 NFA</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220092340899.webp" alt="image-20230220092340899" style="zoom:50%;" /></li><li><p>合并 NFA，构造完整词法规则的 NFA</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220092435146.webp" style="zoom:50%;" /></li><li><p>使用<strong>子集构造法</strong>将 NFA 转化为等价 DFA（并消除“死状态”）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220092904184.webp" alt="image-20230220092904184" style="zoom:50%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220093007486.webp" alt="image-20230220093007486" style="zoom:50%;" /></li><li><p>特定于词法分析器的 DFA 最小化（可选）</p><p>  初始划分不能把所有终止状态笼统地分成一类，需要考虑不同的词法单元，按照识别不同词法单元规约分成不同的类，并补全“死状态”（然后再正常根据 DFA 最小化算法进行处理）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220094124812.webp" alt="image-20230220094124812" style="zoom:50%;" /></li><li><p>模拟运行该 DFA，直到无法继续运行为止（输入结束或状态无法转移）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220093337028.webp" alt="image-20230220093337028" style="zoom:50%;" /></li></ul><h1 id="04-语法分析器"><a href="#04-语法分析器" class="headerlink" title="04 - 语法分析器"></a>04 - 语法分析器</h1><h2 id="ANTLR-v4-生成语法分析器"><a href="#ANTLR-v4-生成语法分析器" class="headerlink" title="ANTLR v4 生成语法分析器"></a>ANTLR v4 生成语法分析器</h2><p>（已通过<code>SysYLexer.g4</code>生成对应的词法分析器）</p><ul><li>输入：语法归约 <code>SysYParser.g4</code></li><li>输出：语法分析器及访问生成的语法树的辅助类 <code>SysYParser.tokens</code>，<code>SysYParser.interp</code>，<code>SysYParser.java</code>，<code>SysYParserBaseListener.java</code>，<code>SysYParserBaseVisitor.java</code>，<code>SysYParserListener.java</code>，<code>SysYParserVisitor.java</code><ul><li>ANTLR 提供了 Visitor 和 Listener 两种访问语法树节点的方式，即访问者模式和观察者模式</li></ul></li></ul><p>样例：（来自 lab2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">parser grammar SysYParser;</span><br><span class="line"></span><br><span class="line">options &#123;</span><br><span class="line">    tokenVocab = SysYLexer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">program : compUnit EOF ;</span><br><span class="line"></span><br><span class="line">compUnit : (decl | funcDef)+ ;</span><br><span class="line"></span><br><span class="line">decl : constDecl | varDecl ;</span><br><span class="line"></span><br><span class="line">constDecl : CONST bType constDef (COMMA constDef)* SEMICOLON ;</span><br><span class="line"></span><br><span class="line">bType : INT ;</span><br><span class="line"></span><br><span class="line">constDef : IDENT (L_BRACKT constExp R_BRACKT)* ASSIGN constInitVal ;</span><br><span class="line"></span><br><span class="line">constInitVal : constExp | L_BRACE (constInitVal (COMMA constInitVal)*)? R_BRACE ;</span><br><span class="line"></span><br><span class="line">varDecl : bType varDef (COMMA varDef)* SEMICOLON ;</span><br><span class="line"></span><br><span class="line">varDef : IDENT (L_BRACKT constExp R_BRACKT)* (ASSIGN initVal)? ;</span><br><span class="line"></span><br><span class="line">initVal : exp | L_BRACE (initVal (COMMA initVal)*)? R_BRACE ;</span><br><span class="line"></span><br><span class="line">funcDef : funcType IDENT L_PAREN funcFParams? R_PAREN block ;</span><br><span class="line"></span><br><span class="line">funcType : VOID | INT ;</span><br><span class="line"></span><br><span class="line">funcFParams : funcFParam (COMMA funcFParam)* ;</span><br><span class="line"></span><br><span class="line">funcFParam : bType IDENT (L_BRACKT R_BRACKT (L_BRACKT exp R_BRACKT)*)? ;</span><br><span class="line"></span><br><span class="line">block : L_BRACE blockItem* R_BRACE ;</span><br><span class="line"></span><br><span class="line">blockItem : decl | stmt ;</span><br><span class="line"></span><br><span class="line">stmt : lVal ASSIGN exp SEMICOLON</span><br><span class="line">     | exp? SEMICOLON</span><br><span class="line">     | block</span><br><span class="line">     | IF L_PAREN cond R_PAREN stmt (ELSE stmt)?</span><br><span class="line">     | WHILE L_PAREN cond R_PAREN stmt</span><br><span class="line">     | BREAK SEMICOLON</span><br><span class="line">     | CONTINUE SEMICOLON</span><br><span class="line">     | RETURN exp? SEMICOLON</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">exp : L_PAREN exp R_PAREN</span><br><span class="line">   | lVal</span><br><span class="line">   | number</span><br><span class="line">   | IDENT L_PAREN funcRParams? R_PAREN</span><br><span class="line">   | unaryOp exp</span><br><span class="line">   | exp (MUL | DIV | MOD) exp</span><br><span class="line">   | exp (PLUS | MINUS) exp</span><br><span class="line">   ;</span><br><span class="line"></span><br><span class="line">cond : exp</span><br><span class="line">   | cond (LT | GT | LE | GE) cond</span><br><span class="line">   | cond (EQ | NEQ) cond</span><br><span class="line">   | cond AND cond</span><br><span class="line">   | cond OR cond</span><br><span class="line">   ;</span><br><span class="line"></span><br><span class="line">lVal : IDENT (L_BRACKT exp R_BRACKT)* ;</span><br><span class="line"></span><br><span class="line">number : INTEGR_CONST ;</span><br><span class="line"></span><br><span class="line">unaryOp : PLUS | MINUS | NOT ;</span><br><span class="line"></span><br><span class="line">funcRParams : param (COMMA param)* ;</span><br><span class="line"></span><br><span class="line">constExp : exp ;</span><br><span class="line"></span><br><span class="line">param: exp ;</span><br></pre></td></tr></table></figure><h2 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h2><p>例如：stmt：”if” expr “then” stmt “else” stmt ; 是一个二义性文法（if-else 的匹配问题）</p><p>可以通过改写来消除二义性（将 else 与最近的未匹配的 if 相匹配）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stmt : matched_stmt | open_stmt ;</span><br><span class="line">matched_stmt : &quot;if&quot; expr &quot;then&quot; matched_stmt &quot;else&quot; matched_stmt</span><br><span class="line">             | expr ;</span><br><span class="line">open_stmt : &quot;if&quot; expr &quot;then&quot; stmt</span><br><span class="line">  | &quot;if&quot; expr &quot;then&quot; matched_stmt &quot;else&quot; open_stmt ;</span><br></pre></td></tr></table></figure><p>例如：expr：expr “*” expr | expr “+” expr | DIGIT ; 是一个二义性文法（运算符的结合性和优先级）</p><p>常识告诉我们乘法的优先级比加法高，并且两者都是左结合的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 左递归文法 */</span><br><span class="line">expr : expr &quot;+&quot; term | term ;</span><br><span class="line">term : term &quot;*&quot; factor | factor ;</span><br><span class="line">factor : DIGIT ;</span><br></pre></td></tr></table></figure><p>ANTLR 可以通过算法直接处理二义性文法和具有左公因子的文法，无需人为改写（优先级高的写在前）</p><p>ANTLR 中二元运算符默认为左结合，一元运算符默认为右结合，对于右结合的二元运算符，使用关键字 assoc 加以限定，expr：&lt;assoc = right&gt; expr “^” expr</p><h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281037083.png" alt="image-20221228103735005" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281041154.png" alt="image-20221228104150107" style="zoom:50%;" /><p><strong>一些复杂的例子</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281115304.png" alt="image-20221228111512276" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281051824.png" alt="image-20221228105110789" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281052729.png" alt="image-20221228105232697" style="zoom:50%;" /><p><strong>上下文无关文法的表达能力强于正则表达式</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281053858.png" alt="image-20221228105339687" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281056905.png" alt="image-20221228105605841" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281058935.png" alt="image-20221228105824901" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202212281103647.png" alt="image-20221228110306581" style="zoom:50%;" /><p><strong>证明一个上下文无关文法没有二义性</strong></p><p>对于 A → X | Y | Z，要证明：</p><ul><li>L(X) ∩ L(Y) = Ø</li><li>L(Y) ∩ L(Z) = Ø</li><li>L(Z) ∩ L(X) = Ø</li></ul><p>其中，L(X) 表示 X 所定义的语言</p><p>故，更一般的，对于 A → X1 | X2 | X3 | … | Xn，需要证明，∀ i, j ∈ [1, n] (i != j)，有 L(Xi) ∩ L(Xj) = Ø</p><h1 id="05-语法分析算法"><a href="#05-语法分析算法" class="headerlink" title="05 - 语法分析算法"></a>05 - 语法分析算法</h1><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220094542795.webp" alt="image-20230220094542795" style="zoom:50%;" /><h2 id="LL-1-语法分析算法"><a href="#LL-1-语法分析算法" class="headerlink" title="LL(1) 语法分析算法"></a>LL(1) 语法分析算法</h2><p>自顶向下的，递归下降的，基于分析预测表的，适用于 LL(1) 文法的 LL(1) 语法分析器</p><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>LL(1) 从左往右读入词法单元（left-to-right），并且在推导的每一步，总是选择<strong>最左边的非终结符</strong>进行展开（left-most description）</p><h3 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220095224395.webp" alt="image-20230220095224395" style="zoom:50%;" /><h3 id="分析预测表"><a href="#分析预测表" class="headerlink" title="分析预测表"></a>分析预测表</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220100730617.webp" alt="image-20230220100730617" style="zoom:50%;" /><h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1) 文法"></a>LL(1) 文法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220100923810.webp" alt="image-20230220100923810" style="zoom:50%;" /><h3 id="实现样例"><a href="#实现样例" class="headerlink" title="实现样例"></a>实现样例</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220101059108.webp" alt="image-20230220101059108" style="zoom:50%;" /><h3 id="计算给定文法-G-的预测分析表"><a href="#计算给定文法-G-的预测分析表" class="headerlink" title="计算给定文法 G 的预测分析表"></a>计算给定文法 G 的预测分析表</h3><p><strong>First 集合</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220102228084.webp" alt="image-20230220102228084" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220102303259.webp" alt="image-20230220102303259" style="zoom:50%;" /><p><strong>Follow 集合</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220102435072.webp" alt="image-20230220102435072" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220102625682.webp" alt="image-20230220102625682" style="zoom:50%;" /><p><strong>计算 First 集合</strong></p><p>对于每个符号串 α 的产生式：α = X1 X2 X3 … Xm</p><ul><li>先计算每个 X 的 First(X) 集合</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220104053883.webp" alt="image-20230220104053883" style="zoom:50%;" /><ul><li>再计算每个符号串 α 的 First(α) 集合</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220104558617.webp" alt="image-20230220104558617" style="zoom:50%;" /><p><strong>计算 Follow 集合</strong></p><ul><li>为每个非终结符 X 计算 Follow(X) 集合</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220105107878.webp" alt="image-20230220105107878" style="zoom:50%;" /><p><strong>生成预测分析表</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220105629679.webp" alt="image-20230220105629679" style="zoom:50%;" /><h3 id="非递归的预测分析算法"><a href="#非递归的预测分析算法" class="headerlink" title="非递归的预测分析算法"></a>非递归的预测分析算法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220110342405.webp" alt="image-20230220110342405" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220110424089.webp" alt="image-20230220110424089" style="zoom:50%;" /><h3 id="改造非-LL-1-文法"><a href="#改造非-LL-1-文法" class="headerlink" title="改造非 LL(1) 文法"></a>改造非 LL(1) 文法</h3><ul><li>消除左递归（使用右递归）</li><li>提取左公因子</li></ul><h2 id="Adaptive-LL-语法分析算法（AllStar-算法）"><a href="#Adaptive-LL-语法分析算法（AllStar-算法）" class="headerlink" title="Adaptive LL(*) 语法分析算法（AllStar 算法）"></a>Adaptive LL(*) 语法分析算法（AllStar 算法）</h2><p>关于 ANTLR v4：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220111538654.webp" alt="image-20230220111538654" style="zoom:50%;" /><h3 id="处理左递归-优先级"><a href="#处理左递归-优先级" class="headerlink" title="处理左递归+优先级"></a>处理左递归+优先级</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220121644591.webp" alt="image-20230220121644591" style="zoom:50%;" /><p><strong>优先级上升算法</strong></p><p>变为非左递归，然后用迭代的方式进行处理</p><p>展开递归表达式时，需要一个优先级参数</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220121957805.webp" alt="image-20230220121957805" style="zoom:50%;" /><p>更多例子：</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220122923959.webp" alt="image-20230220122923959" style="zoom:50%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220123004166.webp" alt="image-20230220123004166" style="zoom:50%;" /></center><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220123158588.webp" alt="image-20230220123158588" style="zoom:50%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220122854917.webp" alt="image-20230220122854917" style="zoom:50%;" /></center><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220131823952.webp" alt="image-20230220131823952" style="zoom:50%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220131926622.webp" alt="image-20230220131926622" style="zoom:50%;" /></center><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220132352223.webp" alt="image-20230220132352223" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220132407304.webp" alt="image-20230220132407304" style="zoom:50%;" /><h3 id="进行错误报告与恢复"><a href="#进行错误报告与恢复" class="headerlink" title="进行错误报告与恢复"></a>进行错误报告与恢复</h3><p>恐慌/应急模式（Panic Mode）：假装成功，调整状态，继续进行</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220132724391.webp" alt="image-20230220132724391" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220132926556.webp" alt="image-20230220132926556" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220133643768.webp" alt="image-20230220133643768" style="zoom:50%;" /><h3 id="AllStar-算法"><a href="#AllStar-算法" class="headerlink" title="AllStar 算法"></a>AllStar 算法</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220133946836.webp" alt="image-20230220133946836" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220134014892.webp" alt="image-20230220134014892" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220134205766.webp" alt="image-20230220134205766" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220134749427.webp" alt="image-20230220134749427" style="zoom:50%;" /><h1 id="06-符号表"><a href="#06-符号表" class="headerlink" title="06 - 符号表"></a>06 - 符号表</h1><p>每个符号表代表了一个作用域，不同的作用域需要通过树结构来维护：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140121490.webp" alt="image-20230220140121490" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140342843.webp" alt="image-20230220140342843" style="zoom:50%;" /><p>每个作用域需要提供的接口：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140512430.webp" alt="image-20230220140512430" style="zoom:50%;" /><p><strong>符号表相关的类层次结构设计</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140908716.webp" alt="image-20230220140908716" style="zoom:50%;" /><h1 id="07-语义分析"><a href="#07-语义分析" class="headerlink" title="07 - 语义分析"></a>07 - 语义分析</h1><h2 id="类型系统与类型检查"><a href="#类型系统与类型检查" class="headerlink" title="类型系统与类型检查"></a>类型系统与类型检查</h2><ul><li><p>类型检查</p></li><li><p>类型转换</p></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220144425670.webp" alt="image-20230220144425670" style="zoom:50%;" /><ul><li>类型综合</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220144547713.webp" alt="image-20230220144547713" style="zoom:50%;" /><ul><li>类型推导</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220144638313.webp" alt="image-20230220144638313" style="zoom:50%;" /><p><strong>生成数组类型的类型表达式</strong></p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220153819939.webp" alt="image-20230220153819939" style="zoom:50%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220153754567.webp" alt="image-20230220153754567" style="zoom:50%;" /></center><h2 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h2><p>属性文法：为上下文无关文法赋予语义</p><p><strong>关键问题：如何基于上下文无关文法做上下文相关分析？</strong>（语法分析树上的有序信息流动，DFS 遍历）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220161257010.webp" alt="image-20230220161257010" style="zoom:50%;" /><p>在 ANTLR v4 中，使用参数的形式来表示继承属性，使用返回值来表示综合属性</p><p>（代码演示部分略）</p><h3 id="语法制导定义"><a href="#语法制导定义" class="headerlink" title="语法制导定义"></a>语法制导定义</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220192334350.webp" alt="image-20230220192334350" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220192552257.webp" alt="image-20230220192552257" style="zoom:50%;" /><h4 id="S-属性定义"><a href="#S-属性定义" class="headerlink" title="S 属性定义"></a>S 属性定义</h4><p><strong>综合属性</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220192854928.webp" alt="image-20230220192854928" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220192953775.webp" alt="image-20230220192953775" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220193042113.webp" alt="image-20230220193042113" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220193122241.webp" alt="image-20230220193122241" style="zoom:50%;" /><h4 id="L-属性定义"><a href="#L-属性定义" class="headerlink" title="L 属性定义"></a>L 属性定义</h4><p><strong>继承属性</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220193309453.webp" alt="image-20230220193309453" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220193659176.webp" alt="image-20230220193659176" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220200519082.webp" alt="image-20230220200519082" style="zoom:50%;" /><ul><li><strong>例子：属性文法计算后缀表达式</strong></li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201141864.webp" alt="image-20230220201141864" style="zoom:40%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201312671.webp" alt="image-20230220201312671" style="zoom:40%;" /></center><ul><li><strong>例子：属性文法计算有符号二进制数</strong></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201545335.webp" alt="image-20230220201545335" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201740985.webp" alt="image-20230220201740985" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220201849477.webp" alt="image-20230220201849477" style="zoom:50%;" /><h3 id="语法制导的翻译方案"><a href="#语法制导的翻译方案" class="headerlink" title="语法制导的翻译方案"></a>语法制导的翻译方案</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220202655013.webp" alt="image-20230220202655013" style="zoom:50%;" /><p>将带有<strong>语义规则</strong>的 SDD 转换为带有<strong>语义动作</strong>的 SDT：</p><ul><li>S 属性的翻译方案</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220202928233.webp" alt="image-20230220202928233" style="zoom:50%;" /><ul><li>L 属性定义与 LL 语法分析</li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220203423540.webp" alt="image-20230220203423540" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220203525251.webp" alt="image-20230220203525251" style="zoom:50%;" /></center><ul><li>比较：在左递归与右递归上的属性定义</li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220210233365.webp" alt="image-20230220210233365" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220210256289.webp" alt="image-20230220210256289" style="zoom:45%;" /></center><ul><li>L 属性翻译方案</li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220210540575.webp" alt="image-20230220210540575" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220210633745.webp" alt="image-20230220210633745" style="zoom:45%;" /></center><ul><li>L 属性翻译方案样例</li></ul><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220211418305.webp" alt="image-20230220211418305" style="zoom:40%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220211445122.webp" alt="image-20230220211445122" style="zoom:40%;" /></center><h1 id="08-LLVM-IR"><a href="#08-LLVM-IR" class="headerlink" title="08 - LLVM IR"></a>08 - LLVM IR</h1><h2 id="LLVM（Low-Level-Virtual-Machine）"><a href="#LLVM（Low-Level-Virtual-Machine）" class="headerlink" title="LLVM（Low-Level Virtual Machine）"></a>LLVM（Low-Level Virtual Machine）</h2><p><strong>The LLVM Compiler Infrastructure</strong></p><blockquote><p>The LLVM Project is a collection of <strong>modular</strong> and <strong>reusable</strong> compiler and tool-chain technologies. Despite its name, LLVM has little to do with traditional <strong>virtual machines</strong>. The name “LLVM” itself is not an acronym; it is the full name of the project.</p></blockquote><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220212550131.webp" alt="image-20230220212550131" style="zoom:60%;" /><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220213427834.webp" alt="image-20230220213427834" style="zoom:50%;" /><h3 id="自动生成-LLVM-IR"><a href="#自动生成-LLVM-IR" class="headerlink" title="自动生成 LLVM IR"></a>自动生成 LLVM IR</h3><p>使用命令 <code>clang -S -emit-llvm xxx.c -o xxx.ll</code> 生成 LLVM IR code 样例：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220220126419.webp" alt="image-20230220220126419" style="zoom:60%;" /><p>演示代码 1：<a href="https://github.com/courses-at-nju-by-hfwei/compilers-antlr/tree/main/src/main/java/llvm/factorial">https://github.com/courses-at-nju-by-hfwei/compilers-antlr/tree/main/src/main/java/llvm/factorial</a> &amp;&amp; <a href="https://github.com/courses-at-nju-by-hfwei/learning-llvm/tree/main/10-llvm">https://github.com/courses-at-nju-by-hfwei/learning-llvm/tree/main/10-llvm</a></p><p>更多关于 LLVM 的使用：<a href="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/LLVM.pdf">https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/LLVM.pdf</a></p><p>使控制流满足 SSA：<strong>Φ 函数</strong>根据控制流决定选择 y1 还是 y2</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220221003332.webp" alt="image-20230220221003332" style="zoom:50%;" /><p><strong>不同优化等级下对控制流的实现方式</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220222526053.webp" alt="image-20230220222526053" style="zoom:70%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220222623949.webp" alt="image-20230220222623949" style="zoom:70%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220223642412.webp" alt="image-20230220223642412" style="zoom:70%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220224220970.webp" alt="image-20230220224220970" style="zoom:70%;" /><h3 id="编程方式生成-LLVM-IR"><a href="#编程方式生成-LLVM-IR" class="headerlink" title="编程方式生成 LLVM IR"></a>编程方式生成 LLVM IR</h3><blockquote><p>详见实验代码</p></blockquote><h1 id="09-中间代码生成"><a href="#09-中间代码生成" class="headerlink" title="09 - 中间代码生成"></a>09 - 中间代码生成</h1><h2 id="表达式翻译与控制流翻译"><a href="#表达式翻译与控制流翻译" class="headerlink" title="表达式翻译与控制流翻译"></a>表达式翻译与控制流翻译</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220235003531.webp" alt="image-20230220235003531" style="zoom:50%;" /><p>注意：下图中的文法对布尔表达式和非布尔表达式做出了区分</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221001735737.webp" alt="image-20230221001735737" style="zoom:90%; margin-bottom:40px" /><h3 id="非布尔表达式的中间代码翻译"><a href="#非布尔表达式的中间代码翻译" class="headerlink" title="非布尔表达式的中间代码翻译"></a>非布尔表达式的中间代码翻译</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221090506622.webp" alt="image-20230221090506622" style="zoom:50%;" /><h3 id="数组引用表达式的中间代码翻译"><a href="#数组引用表达式的中间代码翻译" class="headerlink" title="数组引用表达式的中间代码翻译"></a>数组引用表达式的中间代码翻译</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221081957482.webp" alt="image-20230221081957482" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221082244527.webp" alt="image-20230221082244527" style="zoom:60%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221082449049.webp" alt="image-20230221082449049" style="zoom:50%; margin-top:50px" /><p><strong>LLVM IR 的生成结果：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221083640233.webp" alt="image-20230221083640233" style="zoom:50%; margin-bottom:20px" /><h3 id="控制流语句与布尔表达式的中间代码翻译"><a href="#控制流语句与布尔表达式的中间代码翻译" class="headerlink" title="控制流语句与布尔表达式的中间代码翻译"></a>控制流语句与布尔表达式的中间代码翻译</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221084113845.webp" alt="image-20230221084113845" style="zoom:60%;" /><p><strong>if 条件语句：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221084512124.webp" alt="image-20230221084512124" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221084547737.webp" alt="image-20230221084547737" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221084615354.webp" alt="image-20230221084615354" style="zoom:60%;" /><p>最终生成的 IR code：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goto L1</span><br><span class="line">L1:</span><br><span class="line">goto L0</span><br><span class="line">L3:</span><br><span class="line">assign</span><br><span class="line">L0:</span><br></pre></td></tr></table></figure><p><strong>if else 条件语句：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221085547052.webp" alt="image-20230221085547052" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221085737101.webp" alt="image-20230221085737101" style="zoom:60%;" /><p>最终生成的 IR code：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">goto L1</span><br><span class="line">L1:</span><br><span class="line">goto L3</span><br><span class="line">L3:</span><br><span class="line">assign</span><br><span class="line">goto L0</span><br><span class="line">L4:</span><br><span class="line">assign</span><br><span class="line">goto L0</span><br><span class="line">L2:</span><br><span class="line">assign</span><br><span class="line">L0:</span><br></pre></td></tr></table></figure><p><strong>while 循环语句：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221092013672.webp" alt="image-20230221092013672" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221092534286.webp" alt="image-20230221092534286" style="zoom:60%;" /><p>最终生成的 IR code：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">begin:</span><br><span class="line">goto L1</span><br><span class="line">L1:</span><br><span class="line">goto L4</span><br><span class="line">L3:</span><br><span class="line">assign</span><br><span class="line">goto begin</span><br><span class="line">L4:</span><br><span class="line">assign</span><br><span class="line">goto begin</span><br><span class="line">L0:</span><br></pre></td></tr></table></figure><p><strong>并列顺序语句：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093336145.webp" alt="image-20230221093336145" style="zoom:50%;" /><p><strong>布尔表达式：</strong></p><ul><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093742808.webp" alt="image-20230221093742808" style="zoom:50%;" /></li><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093703309.webp" alt="image-20230221093703309" style="zoom:50%;" /></li><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093628479.webp" alt="image-20230221093628479" style="zoom:50%;" /></li><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221093924755.webp" alt="image-20230221093924755" style="zoom:50%;" /></li><li><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221094042026.webp" alt="image-20230221094042026" style="zoom:50%;" /></li></ul><p>一个复杂的例子：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221094123089.webp" alt="image-20230221094123089" style="zoom:70%;" /><p>最终生成的 IR code：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if x &lt; 100 goto L2</span><br><span class="line">goto L3</span><br><span class="line">L3:</span><br><span class="line">if x &gt; 200 goto L4</span><br><span class="line">goto L1</span><br><span class="line">L4:</span><br><span class="line">if x != y goto L2</span><br><span class="line">goto L1</span><br><span class="line">L2:</span><br><span class="line">x = 0</span><br><span class="line">L1:</span><br></pre></td></tr></table></figure><p><strong>生成 LLVM IR code 并可视化展示控制流图</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221100702370.webp" alt="image-20230221100702370" style="zoom:50%;" /><p><strong>使用 ANTLR v4 生成控制流</strong></p><p>参考样例代码：</p><p><a href="https://github.com/courses-at-nju-by-hfwei/compilers-antlr/blob/main/src/main/antlr/codegen/Control.g4">https://github.com/courses-at-nju-by-hfwei/compilers-antlr/blob/main/src/main/antlr/codegen/Control.g4</a></p><p><a href="https://github.com/courses-at-nju-by-hfwei/compilers-antlr/blob/main/src/main/java/codegen/CodeGenListener.java">https://github.com/courses-at-nju-by-hfwei/compilers-antlr/blob/main/src/main/java/codegen/CodeGenListener.java</a></p><p><strong>关于布尔表达式的补充</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221101915982.webp" alt="image-20230221101915982" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221101938668.webp" alt="image-20230221101938668" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 编译原理 </tag>
            
            <tag> LLVM </tag>
            
            <tag> ANTLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《大数据分析》课程作业</title>
      <link href="/2022/09/22/Bigdata-Analysis-Homework/"/>
      <url>/2022/09/22/Bigdata-Analysis-Homework/</url>
      
        <content type="html"><![CDATA[<h4 id="Scala-安装（Windows）"><a href="#Scala-安装（Windows）" class="headerlink" title="Scala 安装（Windows）"></a>Scala 安装（Windows）</h4><p>需要已经安装有 Java 环境</p><p>安装包下载：<a href="https://www.scala-lang.org/download/%EF%BC%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8">https://www.scala-lang.org/download/（建议使用</a> .msi 方式安装）</p><p>配置环境变量：</p><ul><li>添加系统变量 <strong>SCALA_HOME = [scala安装路径]</strong></li><li>在系统变量 <strong>Path</strong> 下添加 <strong>%SCALA_HOME%\bin;</strong></li><li>在系统变量 <strong>Classpath</strong> 下添加 <strong>.;%SCALA_HOME%\bin;</strong></li></ul><h4 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h4><p>使用 Scala 语言的 RDD 相关操作(map、reduce 等)，编写代码实现对 test.txt 文件单词次数统计（单词不区分大小写）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="type">Source</span>.fromFile(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">          .getLines()</span><br><span class="line">          .reduce(_ + <span class="string">&quot; &quot;</span> + _)</span><br><span class="line">          .toLowerCase</span><br><span class="line">          .split(<span class="string">&quot;[^a-zA-Z0-9&#x27;]+&quot;</span>)</span><br><span class="line">          .map(word =&gt; (word, <span class="string">&quot;&quot;</span>))</span><br><span class="line">          .groupBy(_._1)</span><br><span class="line">          .map(&#123;<span class="keyword">case</span> (k, v) =&gt; (k, v.length)&#125;)</span><br><span class="line">          .toList</span><br><span class="line">          .sortBy(_._1)</span><br><span class="line">        println(result.mkString(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 大数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>商业模式新生代阅读笔记</title>
      <link href="/2022/09/11/Business-Model/"/>
      <url>/2022/09/11/Business-Model/</url>
      
        <content type="html"><![CDATA[<blockquote><p>商业模式：一个商业模式描述的是一个组织创造、传递以及获得价值的基本原理</p></blockquote><h1 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h1><h2 id="九大模块"><a href="#九大模块" class="headerlink" title="九大模块"></a>九大模块</h2><p><strong>客户细分</strong></p><p>一家企业想要获得的和期望服务的不同的目标人群和机构</p><p>细分客户群体的条件：</p><ul><li>需求催生新供给</li><li>需要建立新的分销渠道</li><li>需要建立新的客户关系类型</li><li>产生的利润率不同</li><li>愿意为某方面特殊改进而买单</li></ul><p>客户群体划分方式：</p><ul><li>大众市场（常见于消费电子产业、大型零售商等）</li><li>小众市场（常见于供应商—采购商）</li><li>求同存异的客户群体（各类产品线）</li><li>多元化的客户群体</li><li>多边平台/多边市场</li></ul><p><strong>价值主张</strong></p><p>为某一客户群体提供能为其创造价值的产品和服务（一家公司为客户提供的利益集合）</p><p>有益于价值创造的因素（更简单，更“复杂”，更透明）：</p><ul><li>创新（客户未曾察觉的全新需求，之前没有类似产品）</li><li>性能</li><li>定制（大规模定制，用户参与创造）</li><li>保姆式服务（外包）</li><li>设计（时尚，电子产品）</li><li>品牌/低位（奢侈品，潮牌，游戏等级）</li><li>价格（以更低的价格提供类似的产品：廉价航空，小米，免费经济）</li><li>缩减成本（服务外包：编程，房产销售）</li><li>风险控制（保险，额外保障服务）</li><li>可获得性（分享经济，共同基金）</li><li>便利性/实用性（云计算服务）</li></ul><p>一个产品的价值主张通常是相互重叠且交错的（价值网络）</p><p><strong>渠道通路</strong></p><p>企业如何同其客户群体沟通并建立联系，以向对方传达自身的价值主张</p><p>企业与客户的交互体系：交流、分销、销售渠道、售后，是用户的交互触点</p><p>作用：了解产品和服务，评估价值主张；购买产品与服务，传递价值主张；提供售后支持</p><p>渠道的五个阶段与运营方式：</p><ul><li>知名度—评价—购买—传递—售后</li><li>将价值主张推向市场，与客户建立联系：自有渠道，合作方渠道，混合渠道</li></ul><p>渠道通路的重要性：</p><ul><li>对同类产品竞争起核心作用，但过度重视容易引起反噬（品质与信任失配）</li><li>承载价值主张和客户细分的组合关系，用不断推出的新产品进行营销，强化/更新价值主张，加强/拓展客户细分对系列产品服务的认知</li></ul><p><strong>客户关系</strong></p><p>企业针对某一客户群体所建立的客户关系的类型</p><p>驱动力：开发新客户；留住原客户；增加销售量或单价</p><p>客户关系类型：</p><ul><li>私人服务：发生在购买的现场（价值导向）</li><li>专属私人服务：需要长时间积累，如私人银行服务等（价值导向）</li><li>自助服务：企业向客户提供渠道（成本导向）</li><li>自动化服务：根据客户资料定制服务，如商品推荐等（成本导向）</li><li>社区：使用用户社区融入客户，有利于企业预判未来市场发展，促进社区中成员间联系（兼顾）</li><li>与用户协作，共同创造：与客户合作共同创造价值，如亚马逊邀请客户撰写书评（价值导向）</li></ul><p><strong>收入来源</strong></p><p>企业从每个客户群体中获得的现金收益</p><p>收入来源的方式：</p><ul><li>资产销售：出售实物产品所有权</li><li>使用费：提供某种具体服务，使用越多支付越多</li><li>会员费：销售某项服务的持续使用权限</li><li>租赁：将特定资产某一时期专门供给某人使用</li><li>许可使用费：授予某种受保护知识产权的使用权，并收取使用费</li><li>经纪人佣金：提供中介服务（手续费）</li><li>广告费：为某种产品、服务或品牌做广告</li></ul><p><strong>核心资源</strong></p><p>保证一个商业模式顺利运行所需的最重要资产</p><p>作用：创造并提供价值主张，获得市场，保持与某个客户群体的客户关系并获得收益</p><p>“核心”意味着稀缺/不可替代，需要花费巨大成本来维系</p><ul><li>自主拥有：额外的管理和折旧风险，效率高降低成本</li><li>寻求合作：让出利润空间，颠覆式生存危机</li></ul><p>核心资源类型：</p><ul><li><p>实物资源：一切实物资产，如生产设备、房屋、车辆、机器、管理系统、分销渠道等（资本密集型）</p></li><li><p>知识性资源：如品牌、专营权、专利权、版权、合作关系、客户数据库等，不宜获得但价值巨大</p></li><li><p>人力资源：普遍需要，在知识密集型产业和创新产业尤为关键，如制药公司等</p><ul><li>高价劳动力的来源：对个人创造力的依赖/赛道的稳定程度</li></ul></li><li><p>金融资源：现金、信用额度、用于吸引关键雇员的股票期权池</p></li></ul><p><strong>关键业务</strong></p><p>保障商业模式正常运行所需要做的最重要的事情（运用核心资源，价值主张的落地）</p><p>关键业务是企业创造并提供价值主张，获得市场，维系客户关系并获得收益所必须的</p><p>构建护城河：商业模式创新 – 构建不可替代的关键业务 – 支撑服务升级 – 基础设施投资 –底层技术突破 – 拥有/强化核心资源</p><p>关键业务的分类：</p><ul><li>生产：涉及较大数量或上乘质量，设计、制造以及分销产品，如制造类企业</li><li>解决方案：涉及为个体客户的问题提供解决方案，如咨询公司、医院等</li><li>平台/网络：涉及平台管理、新服务启动、平台升级，如 Visa 公司搭建的信用卡交易平台</li></ul><p><strong>重要合作</strong></p><p>一个商业模式顺利运行所需的供应商和合作伙伴网络</p><p>合作类型：</p><ul><li>非竞争者之间的商业联盟（微信生态 vs. 苹果生态）</li><li>竞争者之间的战略合作（微信支付和支付宝，可口可乐和百事可乐）</li><li>新业务的合资公司</li><li>稳定供应关系的供应商和采购商（产业园，闭环的互联网影视平台）</li></ul><p>合作动机：</p><ul><li>优化及规模效应：优化资源及活动配置，降低成本，如外包、基础设施共享等</li><li>降低风险和不确定性：互为竞争对手的企业在某一领域建立战略联盟而在其他领域保持竞争关系</li><li>特殊资源及活动的获得：企业通过依赖其他占有某项资源或专注于某项活动的公司来实现能力的拓展</li></ul><p><strong>成本结构</strong></p><p>运营一个商业模式所发生的全部成本</p><p>导向：</p><ul><li><p>成本导向：创造并维持精简的成本结构，如低价的价值主张、自动化生产最大化、广泛的业务外包</p></li><li><p>价值导向：更少地关注成本，更多地关注价值创造，以更高端的价值主张、高度的个性化服务为特点</p></li></ul><p>特点：</p><ul><li>固定成本</li><li>可变成本</li><li>规模经济（大宗采购、大规模生产摊薄固定成本）</li><li>范围经济（渠道的复用，摊薄部分可变成本）</li></ul><h2 id="商业模式画布"><a href="#商业模式画布" class="headerlink" title="商业模式画布"></a>商业模式画布</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072007214.png" alt="image-20220907200701090" style="zoom:50%;" /><p><strong>模块之间的联系</strong></p><p>纵向联系：</p><ul><li>客户关系-&gt;渠道通路-&gt;收入来源</li><li>关键业务-&gt;关键资源-&gt;成本支出</li></ul><p>跨越的联系：</p><ul><li>客户关系选择与成本支出导向（定制化、个人化 – 价值导向 VS 自动化、大众化 – 成本导向）</li><li>除了价值主张与关键业务，关注建设渠道通路所需的核心资源与重要合作</li><li>细分的客户群体是否认同上游的重要合作方与引入的外部关键资源</li></ul><p>联系的联系</p><ul><li>平台：多个“价值主张-客户细分”对的组合才能构成完整的收入来源<ul><li>吸引用户的主张与用户愿意付费的主张</li><li>促进多种不同用户群体的交易：补贴谁？收费谁？</li><li>如何运维平台并促进不同用户群体加入</li></ul></li></ul><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="分拆商业模式"><a href="#分拆商业模式" class="headerlink" title="分拆商业模式"></a>分拆商业模式</h2><p>一般来说，只有大型的成熟的公司，进入稳定的运营状态之后，才会使用分拆的商业模式</p><p>企业内部三类规则：经济、竞争、文化</p><ul><li>将企业从事的活动分为：客户关系管理、新产品开发、基础设施管理</li><li>活动对应三种价值信条：亲近客户、产品领先、运营卓越</li></ul><p>理想情况下，它们存在于相互独立的实体中以避免冲突或不必要的消长</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072256345.png" alt="image-20220907225625044" style="zoom:40%;" /><p><strong>私人银行产业</strong>集合了上述三种商业活动：<strong>财富管理</strong>，<strong>经纪服务</strong>，<strong>金融产品设计</strong></p><p>三种不同类型基础业务之间的消长：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072310035.png" alt="image-20220907231007672" style="zoom:50%;" /><p><strong>移动通信行业</strong>的拆分：</p><ul><li><p>基础设施管理交由设备生产商，它们可以同时为多个运营商提供服务，做到更低的运营成本</p></li><li><p>新产品开发交由多个内容提供商（更小的创新型企业），发挥小而有活力的组织的优势</p></li><li><p>品牌和客户关系作为新的核心资产，由减负后的运营商专心聚焦</p></li></ul><h2 id="长尾商业模式"><a href="#长尾商业模式" class="headerlink" title="长尾商业模式"></a>长尾商业模式</h2><p>受到生产工具、销售渠道的普及以及连接供需双方搜寻成本的降低的促进</p><p>少量、多种，即致力于提供多种小众产品（专注于多种类产品销售）</p><p>需要满足：低库存成本、强大的平台、及时售出</p><p><strong>图书出版行业</strong>的转型：</p><p>以“畅销书为中心”转变为“为任何有需要的人出版”</p><p>吸引大量作家，使得作品的失败对出版商而言接近零成本</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209101052230.png" alt="image-20220910105254140" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209101053454.png" alt="image-20220910105332377" style="zoom:45%;" /></center>**乐高**的新长尾模式：<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102301261.png" alt="image-20220910230107977" style="zoom:50%;" /><p><strong>长尾模式总结</strong>：</p><ul><li>小众产品提供者是<strong>重要伙伴</strong></li><li>以提供宽范围的非热销品与热销品共存为<strong>价值主张</strong></li><li>聚焦于小众<strong>客户</strong></li><li>以<strong>平台</strong>为核心资源</li><li>以平台开发维护、小众产品的获得与生产等为<strong>关键业务</strong></li><li><strong>成本</strong>主要发生于平台开发和维护</li><li>依赖互联网来维护<strong>客户关系</strong>或作为<strong>交易渠道</strong></li><li><strong>收入来源</strong>广泛，可能包括广告、产品销售、订阅费等</li><li>对专业和业余产品提供者都适用，创造了一个同时服务于用户和生产者的<strong>多边平台</strong></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102309693.png" alt="image-20220910230923520" style="zoom:50%;" /><ul><li>长尾的发展趋势：坚持 – 转化：长尾部分扁平化；形成若干“小众中心”，并分别向“大众中心”转化</li></ul><h2 id="多边平台商业模式"><a href="#多边平台商业模式" class="headerlink" title="多边平台商业模式"></a>多边平台商业模式</h2><ul><li><p>将两个或更多独立但相互依存的客户群体连接在一起</p></li><li><p>平台对于平台中某一群体的价值在于平台中其他客户群体的存在</p></li><li><p>平台通过促进不同群体间的互动而创造价值（充当媒介）</p></li><li><p>平台的价值提升在于其所吸引的用户数量的增加（网络效应）</p></li></ul><p><strong>谷歌</strong>的商业模式：</p><p>向三个相互依存的客户群体提出三个不同的价值主张：</p><ul><li>针对搜索内容靶向投放广告（广告商）</li><li>免费的强大的搜索引擎服务，多种在线工具服务（上网浏览者）</li><li>呈现谷歌广告商的广告，利用自己的网站内容获利（第三方内容创造者）</li></ul><p>从广告商群体中赚钱，对上网浏览着和内容提供者给予补贴</p><p><strong>电子游戏机产业</strong>：Wii <em>vs.</em> PSP/Xbox</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102343513.png" alt="image-20220910234316443" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102342897.png" alt="image-20220910234251855" style="zoom:45%;" /></center><p><strong>苹果公司</strong>的平台发展：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102341296.png" alt="image-20220910234129230" style="zoom:50%;" /><p><strong>多边平台商业模式总结</strong>：</p><ul><li><strong>核心资源</strong>是平台，关键活动是平台管理、服务实现以及平台升级</li><li><strong>价值主张</strong>主要体现在吸引客户群体，将客户群体进行配对，通过平台提供的交易渠道降低交易成本</li><li>有两个或更多的相互依赖的<strong>客户细分</strong>，每个都有各自的价值主张和收益流</li><li>每个客户群体产生一个<strong>收益流</strong>，一个或多个群体享受免费服务或来自另一客户群体收益流的补贴</li><li>选择对的客户群体作为补贴对象是关键，决定了该模式是否成功</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209102352220.png" alt="image-20220910235239062" style="zoom:50%;" /><h2 id="免费的商业模式"><a href="#免费的商业模式" class="headerlink" title="免费的商业模式"></a>免费的商业模式</h2><ul><li><p>至少有一个关键客户群体可以持续免费地享受服务</p></li><li><p>不付费的客户所得到的财务支持来自商业模式中另一个客户群体</p></li></ul><p>三种使得免费可行的方式：</p><ul><li><p>基于多边平台的免费商品（广告模式）</p><ul><li>好的产品和服务以及高流量会吸引广告商，进而补贴产品和服务</li><li>成本：平台的开发和维护，以及可能的获客与维系成本</li></ul></li><li><p>免费的基本服务，可选的增值服务（免费增值模式）</p><ul><li>收入形式：大量用户从免费服务获益，少量用户为增值服务付费</li><li>两个关键指标：关注免费用户服务成本（低边界成本）与增值用户转化率</li><li>平台发展新趋势：需要高水平、差异化的产品与服务（为免费增值提供空间）</li></ul></li><li><p>以免费吸引客户，引诱其进入重复购买状态（钓鱼模式）</p><ul><li>产品与后续产品之间要有紧密连接，为后续高收益产品或服务的重复购买创造可能</li><li>关注后续产品交付，需要强大品牌支撑</li><li>重要成本结构：初始产品补贴与后续产品的成本</li><li>慢慢融入平台与免费增值</li></ul></li></ul><p><strong>基于广告的</strong>：<em>Metro</em> 公司免费报纸</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112225265.png" alt="image-20220911222512167" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112226573.png" alt="image-20220911222635481" style="zoom:50%;" /><p><strong>免费增值模式</strong>：图片分享网站 <em>Flicker</em> &amp; <em>Redhat</em> 开放源码</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112233796.png" alt="image-20220911223302666" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112234465.png" alt="image-20220911223453366" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112238197.png" alt="image-20220911223813106" style="zoom:50%;" /><p><strong>钓鱼模式</strong>：免费移动电话</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112241625.png" alt="image-20220911224158562" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209112240562.png" alt="image-20220911224022382" style="zoom:50%;" /><h2 id="开放式的商业模式"><a href="#开放式的商业模式" class="headerlink" title="开放式的商业模式"></a>开放式的商业模式</h2><p>系统性与外部伙伴合作</p><p>企业的研发流程对外敞开</p><ul><li>“由外到内”：将外部的理念、技术或知识产权引入内部</li><li>“由内到外”：将内部的知识产权或技术，特别是闲置资产向外出售</li></ul><p>开放的商业模式的优势：</p><ul><li>适用于拥有强势品牌、强大分销渠道与良好客户关系的大公司</li><li>进一步挖掘客户关系的价值</li><li>外部组织能提供有价值的见解、知识、专利、甚至现成的产品</li><li>要能有效获取外部特定资源，要有对外协作的专门业务</li><li>外来意味着成本，但可以缩短上市时间，提升内部开发效率</li><li>帮助企业实现跨越式发展（中国高铁）</li><li>以研发为核心的组织往往产生许多内部无法实用化的知识、技术、和智力资产</li><li>将闲置资产变现，增加收入</li><li>因战略或运营原因对内无价值的研发成果可能对其它行业意义重大</li><li>帮助企业聚焦核心战略，鼓励内部创新</li></ul><h2 id="后发软件产品的机会"><a href="#后发软件产品的机会" class="headerlink" title="后发软件产品的机会"></a>后发软件产品的机会</h2><ul><li>更加细分、贴合的用户体验 – 形成独特的亚文化、亚群体</li><li>结合核心资源、关键业务的深入打造（重资产、“持有型投资”） - 不可替代性强的日常生活服务</li><li>向新技术、新领域、新应用的创新尝试（“新”是指与典型互联网企业、行业相比，往往是有利可图的“老”行业） - 工业/产业互联网</li></ul><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="客户洞察"><a href="#客户洞察" class="headerlink" title="客户洞察"></a>客户洞察</h2><p>根据客户洞察打造商业模式</p><p>成功的创新需要深入理解客户的环境、日常工作、担忧和渴望</p><p>辅助工具：移情图</p><ul><li>看：描述该客户在她所处的环境中所看到的东西</li><li>听：描述环境如何影响到这个客户</li><li>想&amp;感受：尝试勾勒你的客户思维的过程</li><li>说&amp;做：想象客户可能的言辞，或公共场合的行为</li><li>痛点：已遭受的挫折、正遇到的阻碍、怕承担的风险</li><li>收益：预期成就、成功衡量标准、实现目标所采用的策略</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230210144340911.webp" alt="image-20230210144340911" style="zoom:45%;" /><p>客户洞察补充：变需要为需求（人为核心）</p><p>客户洞察的核心：换位思考（帮助人们发掘未能意识到的潜在需求）</p><h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><p>一个能够产生大量商业模式创意，并成功识别出其中最佳创意的流程被称作构思</p><p>构思的两个步骤：生成大量创意-&gt;对创意进行整合并挑选</p><p>商业模式创新的焦点：</p><ul><li>资源驱动：创新来源于组织现有的基础设施或合作伙伴资源</li><li>供给驱动：创造全新的价值主张，并影响到其它模块</li><li>客户驱动：基于客户需求、可获得性或便利性的提升，并影响其他模块</li><li>财务驱动：由新收益来源、定价机制或者被缩减的成本驱动的创新</li><li>多点驱动：多焦点驱动的创新，并对其它模块产生深远影响</li></ul><h2 id="视觉化思考"><a href="#视觉化思考" class="headerlink" title="视觉化思考"></a>视觉化思考</h2><p>抽象的东西具体化、复杂的概念简单化</p><p>视觉化的作用：理解商业模式的本质，提升对话效率，探索创意，提升沟通</p><h2 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h2><p>与视觉化思考一样，模型构建可以使抽象的概念具体化，帮助探索新的创意</p><p>模型构建有助于实际商业模式的探索</p><h2 id="讲故事"><a href="#讲故事" class="headerlink" title="讲故事"></a>讲故事</h2><p>故事是一个理想的热身工具，为深度讨论商业模式与其内在逻辑做好准备</p><p>将故事与画布结合，利用叙事性克服听众对不熟悉模式的抵触，放下对陌生事物的怀疑</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>将模型构建中明确的方向具体化，从而给出有见地的设计</p><p>两种场景：</p><ul><li>不同的客户结构：结合客户洞察描绘出独特、具体的图景<ul><li>由场景决定选择哪款产品而放弃其它产品（价值主张的排他性）</li></ul></li><li>未来可能的竞争环境：想象未来可能的具体细节，品味特定条件下商业模式如何演进</li></ul><h1 id="战略"><a href="#战略" class="headerlink" title="战略"></a>战略</h1><h2 id="商业模式环境评估"><a href="#商业模式环境评估" class="headerlink" title="商业模式环境评估"></a>商业模式环境评估</h2><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230208141317874.webp" alt="image-20230208141317874" style="zoom:50%;" /><ul><li>市场影响力<ul><li>市场问题 – 从客户和供给的角度识别出驱动和改变你的市场的关键问题</li><li>市场分类 – 识别主要的市场群体，描述他们的兴趣点，尝试发现新的群体</li><li>需求和诉求 – 列举市场需求并分析这些需求被满足的程度</li><li>切换成本 – 客户转投竞争对手，需要改变哪些方面</li><li>收入影响力 – 识别与收入吸引力和定价能力相关的因素</li></ul></li><li>关键趋势<ul><li>技术趋势 – 威胁和推动发展当前商业模式的技术趋势</li><li>行业管理趋势 – 影响（你的）商业模式的管理规定和管理趋势</li><li>社会和文化趋势 – 可能影响（你的）商业模式的社会趋势</li><li>社会经济趋势 – 总结和你的商业模式有关的主要社会经济趋势</li></ul></li><li>行业影响力<ul><li>主流竞争对手 – 识别它们以及它们的相对优势</li><li>挑战者 - 新出现的玩家以及它们商业模式的不同</li><li>替代产品和服务 - （包括其它市场和行业在内的）替代产品与服务</li><li>供应商与价值链上的其他厂商 – 当前价值链上的关键玩家与新兴玩家</li><li>利益相关者 – 哪些人会影响你的组织和商业模式</li></ul></li><li>宏观经济影响<ul><li>全球市场情况 – 从宏观经济角度总结当前整体情况</li><li>资本市场 – 与你的资本需求相关的当前资本市场情况</li><li>大宗商品和其他资源 – 关注你的商业模式所需的资源价格与趋势</li><li>经济基础设施 – 你的业务市场的经济基础设施</li></ul></li></ul><h2 id="评估商业模式"><a href="#评估商业模式" class="headerlink" title="评估商业模式"></a>评估商业模式</h2><p>商业模式环境-由外到内的影响，评估商业模式-由内到外的分析</p><h3 id="SWOT评估"><a href="#SWOT评估" class="headerlink" title="SWOT评估"></a>SWOT评估</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230208142342478.webp" alt="image-20230208142342478" style="zoom:50%;" /><p>传统SWOT分析与商业模式画布结合：按照价值主张、成本/收入、基础设施（KR+KA+KP）、客户界面（CS+CH+CR）四类展开评估</p><p><strong>评估优势与劣势</strong></p><ul><li>价值主张：<ul><li>匹配用户需求，形成网络效应（相互关联促进），产品与服务强耦合，用户满意</li></ul></li><li>成本/收入：<ul><li>利润高，收入可预期、可持续、多样化，支出前有进账，定价机制抓住客户购买意愿</li><li>成本可预测，成本结构合理（与商业模式相匹配），运营的成本效率高，获益于规模经济</li></ul></li><li>基础设施：<ul><li>核心资源难以被复制、资源需求可预测、合适时间部署合适资源</li><li>有效执行关键业务、关键业务难以被复制、执行质量高、业务活动内外平衡</li><li>必要合作伙伴、合作关系融洽</li></ul></li><li>客户界面：<ul><li>客户流失率、客户分类、新客户获取</li><li>渠道有效率、有效果、连接客户能力、客户可以轻易接触、被高度整合、产生规模经济、匹配客户群体</li><li>客户关系强、切换成本高绑定关系、品牌强</li></ul></li></ul><p><strong>评估威胁</strong></p><ul><li>对价值主张的威胁（可替代性）</li><li>对成本/收入的威胁（利润的威胁、是否单一、缩水、无法预测、无法支撑）</li><li>对基础设施的威胁（供应不足、干扰、合作关系波动）</li><li>客户界面上的威胁（市场竞争、渠道威胁、客户关系恶化）</li></ul><p><strong>评估机会</strong></p><ul><li>价值主张中的机会（整合、服务化与拓展）</li><li>成本/收入中的机会（可重复、交叉销售、开源节流）</li><li>基础设施中的机会（强化核心、减轻负担、转让闲置）</li><li>客户界面的机会（增长的市场、客户细分、渠道优化与去中间商，客户关系加强与取舍）</li></ul><h2 id="蓝海战略"><a href="#蓝海战略" class="headerlink" title="蓝海战略"></a>蓝海战略</h2><p>蓝海战略：通过根本性的差异化来创造全新的行业，而不是模仿现有商业模式在当前行业中竞争</p><p>蓝海战略的“四项行动架构”（增加价值，减少成本）</p><ul><li>行业中哪些理所当然的要素应被删除（删除）</li><li>哪些要素应被大幅消减至行业标准以下（削减）</li><li>哪些要素应该被大幅调整到行业标准之上（提升）</li><li>哪些行业中从未提供的要素是应该被创造出来的（创造）</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230208181916463.webp" alt="image-20230208181916463" style="zoom:50%;" /><p>蓝海战略强调在增加价值的同时减少成本，通过删除和消减低价值产品或服务来降低成本，通过提升和创造对成本影响弱的高价值功能或服务来实现</p><p>蓝海战略的风险：空心化、外部潮流与形势变更</p><h2 id="多种商业模式管理"><a href="#多种商业模式管理" class="headerlink" title="多种商业模式管理"></a>多种商业模式管理</h2><p>组织的艰巨任务：如何在实施和管理新商业模式的同时维持现有的商业模式</p><ul><li>将新商业模式剥离成一个独立的实体，或者成立独立的业务单元，或维持现状</li><li>拆分商业模式：基础服务、客户关系、新业务</li></ul><p>衡量是否拆分的双变量</p><ul><li>两种模式冲突的严重程度</li><li>战略上的相似性</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h2><p><strong>需求获取</strong></p><ul><li>目标分析（目标模型）<ul><li>确定一个或多个总的目标</li><li>将目标不断细化（目标精化）<ul><li>AND 精化</li><li>OR 精化</li></ul></li><li>标明矛盾冲突（目标阻碍）</li><li>目标的基本模式<ul><li>实现（achieve）</li><li>终止（cease）</li><li>保持（maintain）</li><li>避免（avoid）</li><li>优化（max / min）</li></ul></li></ul></li><li>涉众分析<ul><li>主体依赖模型（ADM 模型）：在涉众识别中分析关键涉众<ul><li>目标依赖</li><li>软目标依赖</li><li>任务依赖</li><li>资源依赖</li></ul></li><li>Power-Interest 模型，Power-Attitude 模型：涉众风险评估<ul><li>参与者，环境设定者，被影响者，观众</li><li>强反对者，强支持着，弱反对者，弱支持者</li></ul></li><li>Stakeholder-Issue 模型：涉众共赢分析<ul><li>列出所有涉众类别（stakeholder）</li><li>将不同涉众的兴趣和期望总结归纳为共同的问题（issue）</li><li>标明涉众对对应问题的期望和态度</li><li>冲突的部分进行折中调整、权衡协商</li></ul></li></ul></li><li>需求获取方法<ul><li>面谈<ul><li>查阅背景资料</li><li>确定主题与目标</li><li>联系被会见者</li><li>确定问题类型及具体问题（先开放后封闭，避免诱导性和双筒式的问题）</li><li>主持面谈</li><li>处理面谈结果</li></ul></li><li>原型</li><li>观察</li></ul></li></ul><p><strong>需求分析</strong></p><ul><li>概念类图（领域模型）</li><li>系统顺序图</li><li>系统状态图</li></ul><p><strong>需求验证</strong></p><ul><li>评审</li><li>原型与模拟</li><li>开发测试用例</li><li>用户手册编制</li><li>利用跟踪关系</li><li>自动化分析</li></ul><p><strong>需求管理</strong></p><ul><li><p>维护需求基线</p><ul><li>配置管理</li><li>状态维护</li></ul></li><li><p>实现需求跟踪</p><ul><li>避免在开发过程或者演化过程中与需求基线不一致或者偏离的风险</li><li>前向跟踪：被定义到软件需求规格说明文档之前的需求演化过程</li><li>后向跟踪：被定义到软件需求规格说明文档之后的需求演化过程</li></ul></li><li><p>控制需求变更</p><ul><li>对变化的评估</li><li>协调</li><li>批准或拒绝</li><li>实现</li><li>验证</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 商业模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《云计算》课程笔记</title>
      <link href="/2022/09/07/NJU-Cloud-Computing/"/>
      <url>/2022/09/07/NJU-Cloud-Computing/</url>
      
        <content type="html"><![CDATA[<h3 id="云计算的概念"><a href="#云计算的概念" class="headerlink" title="云计算的概念"></a>云计算的概念</h3><h4 id="云计算的定义"><a href="#云计算的定义" class="headerlink" title="云计算的定义"></a>云计算的定义</h4><p>关键字：数据存储和网络计算服务，按需交付，分布式，商业计算模型，计算服务交付与底层技术分离</p><h4 id="云计算的参与者"><a href="#云计算的参与者" class="headerlink" title="云计算的参与者"></a>云计算的参与者</h4><ul><li>有基础设施，有意向提供服务或出租</li><li>需要增加基础设施，但不知道需要多长时间</li><li>需要增加基础设施，但资金投入能力有限</li><li>想要专心于设计和开发，不想操心维护和扩展</li><li>想要在任何地方都能访问个人的资源（e.g. 编辑个人文档）</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071511203.png" alt="image-20220907151132110" style="zoom:50%;" /><p>（如上图，上层为云栈，下层为云体）</p><h4 id="计算模式的演进"><a href="#计算模式的演进" class="headerlink" title="计算模式的演进"></a>计算模式的演进</h4><p>主机系统与集中计算 → 效用计算 → 客户机/服务器模式 → 集群计算 → 服务计算 → 个人计 算机与桌面计算 → 分布式计算 → 网格计算 → 软件即服务 → 云计算 </p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071530707.png" alt="image-20220907153039668" style="zoom:50%;" /><p>人类对计算的追求：自动化、高性能、易使用</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071535832.png" alt="image-20220907153511752" style="zoom:50%;" /><p><strong>传统分布式系统</strong></p><p>计算机集群：将多个可信、静态的独立节点连接起来协作完成计算（计算抽象）</p><p>P2P网络：每个节点既是客户端也是服务器，提供部分系统资源（存储抽象）</p><p>计算网格：将多个<strong>异构</strong>计算机动态、紧耦合地整合在一起完成计算任务（接近“云”）</p><p><strong>云计算的基本想法</strong></p><p>对网格的优化（分布式计算的解决方案）：</p><ul><li>大量计算节点，同构可控</li><li>专用内部网络</li><li>通过互联网对外服务（公有云）</li><li>全面虚拟化：计算、存储、网络、桌面</li><li>集中管理：安全、高效</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071736462.png" alt="image-20220907173616370" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209071737319.png" alt="image-20220907173711248" style="zoom:50%;" /><p>云计算持续优化的动力：节能降耗、降低维护成本、提升资产安全、提升信息系统的容灾备份能力</p><h4 id="云计算的特征与分类"><a href="#云计算的特征与分类" class="headerlink" title="云计算的特征与分类"></a>云计算的特征与分类</h4><h5 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209151529008.png" alt="image-20220915152859786" style="zoom:33%;" /><h5 id="云计算的特点"><a href="#云计算的特点" class="headerlink" title="云计算的特点"></a>云计算的特点</h5><ul><li>超大规模——需求</li><li>虚拟化——技术</li><li>按需服务——商业模式</li><li>通用；高可伸缩；极其廉价——得益于技术和模式</li><li>高可靠——要求</li></ul><h5 id="云部署模型"><a href="#云部署模型" class="headerlink" title="云部署模型"></a>云部署模型</h5><p>公有云；社区云；私有云；混合云</p><h5 id="云服务模型"><a href="#云服务模型" class="headerlink" title="云服务模型"></a>云服务模型</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209151532919.png" alt="image-20220915153256807" style="zoom:50%;" /><p><strong>IaaS：</strong></p><p>通过虚拟机方式对外提供计算和存储能力</p><p>机器享有公网IP，多个虚拟机之间通过网络进行通信（也会有内部子网）</p><p>类似租用独立的计算机</p><p>用户自行解决多台机器之间的协同问题</p><p>优势：</p><ul><li>允许动态申请和释放资源</li><li>按使用量计费</li><li>更高的资源使用效率</li></ul><p><strong>PaaS：</strong></p><p>提供用户应用程序的开发和运行环境，包括应用编程接口和运行平台等，支持应用从创建到运行整个生命周期需要的各种软硬件资源和工具：</p><ul><li>经过封装的IT能力或逻辑资源：数据库、文件系统和应用运行环境</li><li>主要面向软件开发者（包括应用服务上）</li></ul><p>PaaS自身负责资源的动态扩展和容错管理</p><p>用户无需考虑节点间的配合问题</p><p>用户自主权降低，需按照给定的编程环境和编程模型构建应用</p><p>类似MPI（Message Passing Interface）编程（只适用于解决模型特定的计算问题）</p><p><strong>SaaS：</strong></p><p>通过标准的Web浏览器获软件客户端访问云上的应用</p><p><strong>IaaS <em>vs.</em> PaaS <em>vs.</em> SaaS：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209152214305.png" alt="image-20220915221420238" style="zoom:50%;" /><h4 id="云计算的三元认知论"><a href="#云计算的三元认知论" class="headerlink" title="云计算的三元认知论"></a>云计算的三元认知论</h4><p><strong>一种商业模式</strong></p><p>从提供的服务类型来看是一种全新的商业模式（没有包含新技术）</p><p>区别于传统的“互联网服务”模式：在软件服务基础上提供平台和基础设施服务</p><p>以云平台体现具体实现机制，包括计算范式和实现方式</p><p><strong>一种计算范式</strong></p><ul><li><p>理论层面的实现方式，偏向针对商业模式的体系结构设计</p></li><li><p>云体逻辑结构：具体落地的云平台逻辑结构——物理结构就是云数据中心</p><ul><li>计算 + 存储 + 通信</li></ul></li><li><p>云栈逻辑结构：面向服务的云平台逻辑结构——物理结构就是管理系统的结构</p><ul><li>基础设施即服务，平台即服务，软件即服务</li></ul></li></ul><p><strong>一种实现方式</strong></p><ul><li>数据中心 + 云平台管理系统</li><li>软件定义数据中心：软件定义计算，软件定义存储，软件定义网络，软件定义安全</li></ul><h3 id="云计算架构"><a href="#云计算架构" class="headerlink" title="云计算架构"></a>云计算架构</h3><h4 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h4><p>云体</p><ul><li>云计算的物质基础，云计算使用的资源集合，构成云计算的软硬件环境，如网络、服务器、存储器、交换机等，广义的云体包括数据中心机器辅助设施如电力、空调、机架、冷却等系统。</li></ul><p>云栈</p><ul><li>又称云平台，在云上建造的运行环境，能够支持应用程序的发布、运行、监控、调度、伸缩，并为应用程序提供辅助服务机制，如访问控制、权限管理等。</li></ul><p>云计算</p><ul><li>利用云体和云平台所进行的计算或处理——云计算可以在云体上直接进行，也可以在云平台上进行。无论在哪个层面开展，只要符合“按量计费、资源可伸缩”就是云计算。</li><li>云存储、云服务、在云上运行自己的软件或算法，都是云计算。</li><li>云计算是人们利用云体和云平台所从事的活动。</li></ul><h5 id="逻辑云栈"><a href="#逻辑云栈" class="headerlink" title="逻辑云栈"></a>逻辑云栈</h5><p>云栈——提供的服务种类多，规模大，需要层次架构以便于管理（从纵向的方式来构建云计算的整体架构）</p><p>云栈的三层模式：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210252326017.png" alt="image-20221025232658834" style="zoom:50%;" /><h5 id="技术体系结构"><a href="#技术体系结构" class="headerlink" title="技术体系结构"></a>技术体系结构</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210042009691.png" alt="image-20221004200936543" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210042010200.png" alt="image-20221004201019106" style="zoom:50%;" /><h5 id="IaaS-实现方式"><a href="#IaaS-实现方式" class="headerlink" title="IaaS 实现方式"></a>IaaS 实现方式</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210252328183.png" alt="image-20221025232822038" style="zoom:50%;" /><h5 id="物理云栈-OpenStack"><a href="#物理云栈-OpenStack" class="headerlink" title="物理云栈 OpenStack"></a>物理云栈 OpenStack</h5><p>OpenStack 是一个管理云计算中计算、存储和网络，甚至是应用的通用平台，其提供 Web界面、命令行工具和应用程序接口（API）等使用接口</p><p>本质上OpenStack通过抽象和一个通用的API接口控制不同厂商提供的硬件和软件资源， 是对计算系统的更高层次的抽象</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210252331164.png" alt="image-20221025233127087" style="zoom:50%;" /><h5 id="逻辑云体"><a href="#逻辑云体" class="headerlink" title="逻辑云体"></a>逻辑云体</h5><p> 云栈是从纵向角度看云计算的整体架构；云体是从横向角度看其架构模式</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210252336306.png" alt="image-20221025233642224" style="zoom:50%;" /><h5 id="物理云体云数据中心"><a href="#物理云体云数据中心" class="headerlink" title="物理云体云数据中心"></a>物理云体云数据中心</h5><p>传统数据中心暴露的问题：</p><ul><li>过多的机器</li><li>机器利用率过低</li><li>应用迁移太困难</li><li>存储需求增长太快</li></ul><p>软件定义的数据中心，重新重视虚拟化，以提高资源利用率：</p><ul><li>不仅应用到计算节点</li><li>复制到存储、网络、安全等方方面面</li><li>软件定义计算：计算节点的虚拟化：虚拟机成为计算调度和管理的单位，不中断服务的前提下动态迁移。</li><li>软件定义存储：分离管理接口与数据读写；统一的管理接口与上层管理软件交互；数据读写可以兼容各种不同的链接方式。</li><li>软件定义网络：数据平面（数据转发）和控制平面（转发表的设置等）分离；集中控制，分布式转发。</li></ul><h3 id="云数据中心"><a href="#云数据中心" class="headerlink" title="云数据中心"></a>云数据中心</h3><h4 id="云数据中心的特征"><a href="#云数据中心的特征" class="headerlink" title="云数据中心的特征"></a>云数据中心的特征</h4><p>绿色节能；高可用性；自动化管理</p><h4 id="云数据中心网络部署"><a href="#云数据中心网络部署" class="headerlink" title="云数据中心网络部署"></a>云数据中心网络部署</h4><p>传统树结构：建造方便简单，但不利于拓展升级，不够健壮</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131933371.png" alt="image-20221013193357250" style="zoom:50%;" /><p>云数据中心需要：低成本、高可扩展性、低配置开销、健壮性、节能</p><h5 id="改进树结构——FatTree"><a href="#改进树结构——FatTree" class="headerlink" title="改进树结构——FatTree"></a>改进树结构——FatTree</h5><ul><li><p>K叉树，K个Pod(集装器)，每个Pod有K个交换机，其中K/2个接入交换机，K/2个汇聚交换机</p></li><li><p>Pod中每个交换机有K个接口，K/2个接主机，K/2个接汇聚；K/2个接接入，K/2个接核心</p></li><li><p>有(K/2)^2个核心交换机，每个交换机K个端口接K个汇聚交换机</p></li><li><p>一个Pod内的所有交换机相互连接：完全二分图</p></li><li><p>一个Pod内的每个汇聚交换机与一部分核心交换机连接，但是一个Pod和每一个核心交换机都有连接</p></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131937108.png" alt="image-20221013193704955" style="zoom:50%;" /><p>两级路由表，使Pod间的流量均匀分布于核心交换机</p><p>任意两个不同Pod主机间存在K条路径</p><p>与传统层次结构相比，FatTree有如下特点：</p><ul><li>消除了树形结构上层链路对吞吐量的限制</li><li>为内部节点间通信提供多条并行链路</li><li>与现有数据中心网络使用的以太网结构和IP配置的服务器兼容</li><li>布线复杂；扩展时需要重构；受到端口数限制</li></ul><p>FatTree的扩展性受限于核心交换机的端口数量</p><h5 id="改进树结构——VL2"><a href="#改进树结构——VL2" class="headerlink" title="改进树结构——VL2"></a>改进树结构——VL2</h5><p>VL2特点：</p><ul><li>扁平寻址，允许服务实例被放置到网络覆盖的任何地方</li><li>负载均衡将流量统一分配到网络路径</li><li>终端系统的地址解析拓展到巨大的服务器池</li></ul><p>核心思想：</p><ul><li>使用FatTree同样的拓扑结构建立扁平的第二层网络</li></ul><p>具体机制</p><ul><li>IP地址仅仅作为名字使用，没有拓扑含义；将服务器的名字与其位置分开</li><li>使用可扩展、可靠的目录系统来维持名字和位置间的映射</li><li>当服务器发送分组时，服务器上的VL2代理开启目录系统以得到实际的目的位置，然后将分组发送到目的地</li></ul><h5 id="递归层次"><a href="#递归层次" class="headerlink" title="递归层次"></a>递归层次</h5><ul><li>DCell</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131949173.png" alt="image-20221013194957026" style="zoom:50%;" /><ul><li>FiConn</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131953140.png" alt="image-20221013195352016" style="zoom:50%;" /><ul><li>BCube</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210131956063.png" alt="image-20221013195601954" style="zoom:50%;" /><h5 id="光交换网络"><a href="#光交换网络" class="headerlink" title="光交换网络"></a>光交换网络</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132000709.png" alt="image-20221013200045561" style="zoom:50%;" /><h5 id="无线数据中心网络"><a href="#无线数据中心网络" class="headerlink" title="无线数据中心网络"></a>无线数据中心网络</h5><p>静态链路和有线接口在大量高突发流量和高负载服务器情况下降低数据中心网络性能，无线网络的广播机制能够克服这个问题</p><p>无需重新布线即可灵活调整拓扑结构，但提供足够带宽的前提下传输距离有限</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132002114.png" alt="image-20221013200249990" style="zoom:50%;" /><h5 id="软件定义网络"><a href="#软件定义网络" class="headerlink" title="软件定义网络"></a>软件定义网络</h5><p>OpenFlow</p><h4 id="绿色节能技术"><a href="#绿色节能技术" class="headerlink" title="绿色节能技术"></a>绿色节能技术</h4><p>配电系统节能技术；空调系统节能技术；集装箱数据中心节能技术；节能策略和算法研究；新能源应用</p><h4 id="自动化管理"><a href="#自动化管理" class="headerlink" title="自动化管理"></a>自动化管理</h4><h4 id="容灾备份"><a href="#容灾备份" class="headerlink" title="容灾备份"></a>容灾备份</h4><h5 id="标准等级"><a href="#标准等级" class="headerlink" title="标准等级"></a>标准等级</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132008261.png" alt="image-20221013200842102" style="zoom:50%;" /><h5 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132009878.png" alt="image-20221013200929790" style="zoom:50%;" /><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>虚拟化技术是云计算的核心技术</p><p>虚拟化技术的本质：添加虚拟化层将物理设备逻辑化，实现软硬件解耦</p><p>虚拟化技术核心思想：利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源，在虚拟资源上可安装部署多个虚拟机，实现多用户共享物理资源</p><h4 id="服务器虚拟化层级"><a href="#服务器虚拟化层级" class="headerlink" title="服务器虚拟化层级"></a>服务器虚拟化层级</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301646751.png" alt="image-20220930164619323" style="zoom:35%;" /><h5 id="硬件级虚拟化"><a href="#硬件级虚拟化" class="headerlink" title="硬件级虚拟化"></a>硬件级虚拟化</h5><p>添加一个称为虚拟化层的软件，管理客户操作系统，使其能够独立于主机操作系统同时运行在同一硬件上</p><ul><li><p>三个要求：</p><ul><li><p>同质：提供与原始硬件机器基本一致的环境</p></li><li><p>高效：运行在虚拟硬件环境中的程序性能损失较低</p></li><li><p>资源受控：系统资源处于 VMM (<em>Virtual Machine Monitor</em>) 的完全控制之中</p></li></ul></li><li><p>优势：</p><ul><li>封装性：以虚拟机为粒度，运行环境的保存和部署方便</li><li>多实例：提高计算机性能利用率，降低资源消耗</li><li>隔离：虚拟机中的应用程序可以在自己的操作系统中独立运行（安全性、测试场景）</li><li>硬件无关：无缝跨硬件迁移（云计算环境中虚拟机迁移很重要）</li><li>特权功能：在虚拟化层添加特权功能，不能被客户机绕过 ；事件记录和回放</li></ul></li></ul><p>客户机操作系统的敏感指令都是特权指令才能够实现高效的虚拟化——陷入VMM</p><ul><li><p><strong>CPU 虚拟化</strong></p><p>  任意时刻一个物理 CPU 只能运行一个虚拟 CPU</p><p>  每个客户操作系统可以使用一个或多个虚拟 CPU</p><p>  各个操作系统之间虚拟 CPU 运行相互隔离，互不影响</p><p>  解释执行：来自操作系统的指令由 VMM 解释成执行函数到硬件上执行（模拟执行，Java 虚拟机同样）</p><p>  扫描与修补：部分指令（敏感指令）模拟执行，部分指令（非敏感指令）监控执行</p><ul><li><p>基于软件的完全虚拟化（由 VMM 全权掌控，速度慢）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302139221.png" alt="image-20220930213941167" style="zoom:50%;" /></li><li><p>基于硬件的辅助虚拟化（对硬件的操作权限进行划分：根模式→VMM，非根模式→客户机，即硬件能意识到虚拟环境的存在）</p>  <center>      <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302148784.png" alt="image-20220930214829754" style="zoom:40%;" />      <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302149053.png" alt="image-20220930214859997" style="zoom:40%;" />  </center></li><li><p>改操作系统的类虚拟化（修改暴露给虚拟机的硬件抽象和上层操作系统，客户机操作系统和 VMM 配合实现虚拟化，即修改后的操作系统能意识到虚拟环境的存在）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302157414.png" alt="image-20220930215713319" style="zoom:50%;" />  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209302157645.png" alt="image-20220930215748568" style="zoom:50%;" /></li></ul></li><li><p><strong>内存虚拟化</strong></p><p>  虚拟地址 GVA → 客户机物理地址 GPA → 宿主机物理地址 HPA</p><p>  VMM 需要维护客户机物理地址和宿主机器的机器地址之间的映射；截获虚拟机对客户机物理地址的访问，并根据所记录的映射关系，转换成机器地址</p><ul><li><p>基于软件的完全虚拟化</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301712764.png" alt="image-20220930171243657" style="zoom:50%;" /></li><li><p>基于硬件的辅助虚拟化（通过扩展页表，在硬件上支持 GVA-GPA-HPA 的两次地址转换）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301714151.png" alt="image-20220930171445041" style="zoom:50%;" /></li><li><p>改操作系统的类虚拟化（客户机操作系统直接使用 VMM 的机器地址到物理地址的翻译表更新页表映射）</p></li></ul></li><li><p><strong>I/O 虚拟化</strong></p><ul><li><p>基于软件的完全虚拟化</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301704623.png" alt="image-20220930170430482" style="zoom:50%;" /></li><li><p>基于硬件的辅助虚拟化（客户机直接访问I/O地址空间，设备直接访问客户机内存）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301707204.png" alt="image-20220930170742090" style="zoom:60%;" /></li><li><p>改操作系统的类虚拟化（修改客户操作系统，使其通过 VMM 提供的接口直接与物理设备交互）</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301709917.png" alt="image-20220930170929793" style="zoom:60%;" /></li></ul></li></ul><h5 id="操作系统级虚拟化"><a href="#操作系统级虚拟化" class="headerlink" title="操作系统级虚拟化"></a>操作系统级虚拟化</h5><p>没有 Hypervisor / VMM，在主机操作系统中插入一个虚拟化层</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301731842.png" alt="image-20220930173153736" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209301732013.png" alt="image-20220930173233909" style="zoom:45%;" /></center>#### 不同层级虚拟化技术对比<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210051520653.png" alt="image-20221005152014471" style="zoom:50%;" /><h4 id="云数据中心的虚拟化"><a href="#云数据中心的虚拟化" class="headerlink" title="云数据中心的虚拟化"></a>云数据中心的虚拟化</h4><h5 id="服务器虚拟化"><a href="#服务器虚拟化" class="headerlink" title="服务器虚拟化"></a>服务器虚拟化</h5><ul><li>虚拟机和容器共存，容器的地位不断提升，目前与虚拟机相当</li><li>高效率的unikernel技术<ul><li>unikernel是使用库操作系统（LibOS）构建的专用的、单一地址空间机器镜像</li><li>LibOS库操作系统：在应用程序层中实施访问控制和隔离，用户应用无需在用户模式和内核模式间切换，直接访问硬件；然而多 个应用程序同时运行时隔离性不好</li><li>可使用操作系统虚拟化（虚拟机监控器VMM）克服硬件资源隔离缺陷：LibOS通过VMM驱动物理硬件，像虚拟机一样运行</li></ul></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132013617.png" alt="image-20221013201349545" style="zoom:50%;" /><h5 id="存储虚拟化"><a href="#存储虚拟化" class="headerlink" title="存储虚拟化"></a>存储虚拟化</h5><p>存储虚拟化将系统中分散且异构的存储资源整合起来，形成一个统一的连续编址的逻辑存储空间</p><p>存储虚拟化能够：提高存储资源利用率，降低单位存储空间成本，降低存储管理的负担和复杂性</p><p>一般模型：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132027550.png" alt="image-20221013202725455" style="zoom:50%;" /><p>具体实现：</p><ul><li>基于主机的存储虚拟化</li><li>基于存储设备的存储虚拟化</li><li>基于网络的存储虚拟化</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132028821.png" alt="image-20221013202853677" style="zoom:50%;" /><h5 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h5><p>云数据中心的业务集中度、服务的客户数量远远超过传统数据中心，对网络的高带宽、低拥塞的要求更高</p><p>云数据中心对网络的需求：</p><ul><li>提高数据传输效率：应对数据同步、备份、虚拟机迁移等的大流量</li><li>提高管理效率：采用统一的交换网络减少布线、维护和扩容的成本</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132029018.png" alt="image-20221013202957800" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132030266.png" alt="image-20221013203024225" style="zoom:50%;" /><h4 id="云环境中的虚拟机迁移"><a href="#云环境中的虚拟机迁移" class="headerlink" title="云环境中的虚拟机迁移"></a>云环境中的虚拟机迁移</h4><h5 id="虚拟机迁移的需求"><a href="#虚拟机迁移的需求" class="headerlink" title="虚拟机迁移的需求"></a>虚拟机迁移的需求</h5><ul><li>云计算中心物理服务器负载处于动态变化中，当无法提供额外物理资源而为了负载平衡，可将占用热门物理资源的虚拟机迁移到其他物理服务器</li><li>物理服务器定期升级的需要，升级前将虚拟机迁移到其他物理服务器，等升级完成再迁移回来</li></ul><p>云计算中关注的重点：实时迁移</p><h5 id="虚拟机迁移的具体内容"><a href="#虚拟机迁移的具体内容" class="headerlink" title="虚拟机迁移的具体内容"></a>虚拟机迁移的具体内容</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132036696.png" alt="image-20221013203657514" style="zoom:50%;" /><p>均需要基于有效的虚拟化技术</p><h3 id="OpenStack-开源云计算平台"><a href="#OpenStack-开源云计算平台" class="headerlink" title="OpenStack 开源云计算平台"></a>OpenStack 开源云计算平台</h3><p>OpenStack 是开源云计算平台（云操作系统），可控制整个数据中心的大型计算，存储和网络资源池</p><p>管理员能够通过Web界面、命令行或 API 接口控制、配置资源；用户可以通过 Web 界面使用资源</p><p>OpenStack 的定位：云计算系统的控制面和执行面</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261032724.png" alt="image-20221026103206644" style="zoom:50%;" /><p>除了云操作系统OpenStack，构建云计算还需要很多其他东西：底层驱动 + 上层应用程序</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261033962.png" alt="image-20221026103314898" style="zoom:50%;" /><h5 id="云操作系统"><a href="#云操作系统" class="headerlink" title="云操作系统"></a>云操作系统</h5><p>构架于服务器、存储、网络等<strong>基础硬件资源</strong>和单机操作系统、中间件、数据库等<strong>基础软件</strong>之上，管理海量的基础硬件、软件资源的云平台<strong>综合管理系统</strong>：</p><ul><li>管理和驱动海量服务器、存储等基础硬件，将数据中心的硬件资源逻辑上整合成一台服务器</li><li>为云应用软件提供统一的、标准的接口</li><li>管理海量的计算任务以及资源调配和迁移</li></ul><p>特点：</p><ul><li>网络化：将用户计算需求作为任务通过网络发送给各个处于不同地理位置的服务器处理，通过网络返回结果 </li><li>安全：采用多种多样的安全保障措施保证数据安全。内存安全、数据传输安全（加密）、持久存储安全（冗 余、备份）</li><li>计算的可扩充性：动态申请网络硬件资源为用户服务——本地硬件资源无需扩展</li></ul><h4 id="OpenStack-简介"><a href="#OpenStack-简介" class="headerlink" title="OpenStack 简介"></a>OpenStack 简介</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul><li>既是一个开源软件，也是一个项目，还是一个社区，提供了一个部署云的操作平台或工具集。用 OpenStack 易于构建虚拟计算或存储服务的云，既可以为公有云、私有云，也可以为大云、小云提供可扩展、灵活的云计算</li><li>OpenStack 是一个管理<strong>计算、存储和网络资源</strong>的数据中心云计算开放平台，通过一个仪表板，为管理 员提供了所有的管理控制，同时通过 Web 界面为其用户提供资源</li><li>Rackspace 公司的 “云文件” 平台 Swift + 美国宇航局 NASA “星云” 平台 Nova</li></ul><h5 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h5><ul><li>开放：任何个人、企业、组织、政府机构，只要遵循相关开源协议，都可以使用、拿到源代码</li><li>灵活：带来可以定制的好处，每一个类型组建都有多个替代品，不会因为某一个组件的原因受到限制</li><li>可扩展：各个组件是相互独立的项目，各个组件可以从内部解决可扩展的问题，而不影响其他组件</li></ul><h5 id="参考架构"><a href="#参考架构" class="headerlink" title="参考架构"></a>参考架构</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261038593.png" alt="image-20221026103833509" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261039370.png" alt="image-20221026103920264" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261042381.png" alt="image-20221026104209256" style="zoom:50%;" /><h5 id="计算和存储、网络、镜像服务关系"><a href="#计算和存储、网络、镜像服务关系" class="headerlink" title="计算和存储、网络、镜像服务关系"></a>计算和存储、网络、镜像服务关系</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210261043542.png" alt="image-20221026104343363" style="zoom:50%;" /><h5 id="虚拟机创建过程"><a href="#虚拟机创建过程" class="headerlink" title="虚拟机创建过程"></a>虚拟机创建过程</h5><ul><li><p>资源准备</p><ul><li><p>通过Keystone进行用户身份认证，通过认证后，用户即可与Openstack API节点通信，触发创建请求</p></li><li><p>通过调度器获得启动虚拟机的最佳位置：通过工作守护进程获得物理节点上的资源状态；Nova-scheduler</p></li></ul></li><li><p>创建流程</p><ul><li><p>调用身份认证进行身份验证</p></li><li><p>生成用于后续调用的令牌</p></li><li><p>访问镜像服务以获取镜像列表，并获取目标基础镜像</p></li><li><p>处理计算服务 API 请求</p></li><li><p>处理计算服务对安全组和密钥调用的请求</p></li><li><p>调用网络服务 API 确定可用网络</p></li><li><p>通过计算节点调度程序选择 Hypervisor 节点</p></li><li><p>调用块存储服务 API 为实例分配卷</p></li><li><p>通过计算服务API调用在 Hypervisor 节点启动实例</p></li><li><p>调用网络服务API为实例分配网络资源</p></li></ul></li></ul><h5 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h5><h5 id="物理部署示例"><a href="#物理部署示例" class="headerlink" title="物理部署示例"></a>物理部署示例</h5><h5 id="四种节点"><a href="#四种节点" class="headerlink" title="四种节点"></a>四种节点</h5><h5 id="物理部署模型-估算"><a href="#物理部署模型-估算" class="headerlink" title="物理部署模型-估算"></a>物理部署模型-估算</h5><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><h5 id="DevOps-和-Openstack"><a href="#DevOps-和-Openstack" class="headerlink" title="DevOps 和 Openstack"></a>DevOps 和 Openstack</h5><h5 id="OpenStack-Ansible"><a href="#OpenStack-Ansible" class="headerlink" title="OpenStack Ansible"></a>OpenStack Ansible</h5><h4 id="云控制器"><a href="#云控制器" class="headerlink" title="云控制器"></a>云控制器</h4><h4 id="计算节点"><a href="#计算节点" class="headerlink" title="计算节点"></a>计算节点</h4><h5 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h5><h5 id="Magnum"><a href="#Magnum" class="headerlink" title="Magnum"></a>Magnum</h5><h4 id="存储节点"><a href="#存储节点" class="headerlink" title="存储节点"></a>存储节点</h4><h5 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h5><h5 id="Cinder"><a href="#Cinder" class="headerlink" title="Cinder"></a>Cinder</h5><h4 id="网络节点"><a href="#网络节点" class="headerlink" title="网络节点"></a>网络节点</h4><h5 id="Neutron"><a href="#Neutron" class="headerlink" title="Neutron"></a>Neutron</h5><h5 id="虚拟网络-VLAN-实现"><a href="#虚拟网络-VLAN-实现" class="headerlink" title="虚拟网络 VLAN 实现"></a>虚拟网络 VLAN 实现</h5><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><h4 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h4><h5 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h5><p>集中式计算：完全依赖一台大型的中心计算机的处理能力，即主机</p><p>分布式计算：多个通过网络互联的计算机都具有一定的计算能力，他们相互之间传递数据，实现信息共享，协作共同完成一个处理任务</p><p>分布式系统：将海量计算能力才能处理的问题拆分成许多小块，将小块分配给同一套系统中不同的计算机节点处理，最后将分开计算的结果合并得到最终结果的系统</p><p>分布式计算的一般步骤：</p><ul><li>设计分布式计算模型；分布式任务分配；编写并执行分布式程序【难点：计算任务划分 + 多节点通信】</li></ul><h5 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h5><p>ACID原则：数据库事务正常执行的四个原则：原子性(Atomicity)，一致性(Consistency)，独立性(Isolation)，持久性(Durability)</p><p>CAP理论：一个分布式系统最多能够同时满足一致性(consistency)、可用性(Availability)、分区容错性(Partition tolerance)中的两项</p><p>对于大多数大型互联网服务而言，节点故障、网络故障是常态，均采取保证AP的策略，对于一致性退而求其次，只保证最终一致性</p><p>BASE理论——追求最终一致性</p><ul><li>Basically Available-基本可用：系统出现故障时，允许损失部分可用性，保证核心可用</li><li>Soft State-软状态：允许系统存在中间状态，但中间状态不会影响系统的整体可用性</li><li>Eventual Consistency-最终一致性：所有数据副本经过一定时间后，能最终达到一致的状态</li></ul><p>一致性算法：在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致</p><ul><li>基于消息传递的一致性算法Paxos：<a href="https://www.cnblogs.com/linbingdong/p/6253479.html">https://www.cnblogs.com/linbingdong/p/6253479.html</a> </li><li>基于消息传递的一致性算法Raft： <a href="https://raft.github.io/">https://raft.github.io/</a> </li></ul><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>容错性：能在某些节点发生故障的情况下，利用容错机制避免整套系统服务都不可用</li><li>高可扩展性：能在运行过程中自由地对系统内部节点或现有功能进行扩充，而不影响现有服务的运行</li><li>开放性：决定了一个系统是否具备自我扩展和与其他系统集成的能力；开放的接口+接口遵循协议=更好</li><li>并发处理能力：系统必须保证对象的操作在并发环境中能够安全使用，保证数据一致性和系统高可用性</li><li>透明性：无需让用户知晓系统的内部细节，暴露给用户访问资源和服务的方式，将系统看作是一个整体</li></ul><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>分布式存储系统</p><ul><li>结构化存储：事务处理系统或关系型数据库，数据划分为表、字段和表关系，如分布式MySQL</li><li>非结构化存储：强调很高的可扩展性，存储数据非常自由，代表是分布式文件系统，如HDFS，GFS等</li><li>半结构化存储：解决非结构化数据随机访问性能差的问题，如NoSQL，Key-Value Store，对象存储</li><li>In-memory存储：基于内存的存储系统，利用内存实现极高读写性能，例如Memcached和Redis</li><li>NewSQL：既具备结构化存储的ACID事务支持，又拥有NoSQL半结构化存储的强大可扩展能力</li></ul><p>分布式计算系统</p><ul><li>传统基于消息的系统：MPI（Message Passing Interface）</li><li>Dataflow系统：将计算抽象为高层算子，算子组合为有向无环图，由后端调度引擎并行化调度执行<ul><li>Hadoop：MapReduce；Spark：更多类型的算子</li></ul></li><li>流式计算、图计算、分布式机器学习——Spark都实现了这些类型的分布式计算</li></ul><p>分布式资源管理系统：支持多种计算框架、高可扩展、高容错、高资源利用率、细粒度资源分配</p><ul><li>Yarn：Hadoop 2.0版本，解决了原来Hadoop扩展性较差的问题，可以在框架下自定义算子</li><li>Apache Mesos：加州大学伯克利分校的一个研究项目，现在属于Apache基金会的一个项目</li><li>Spark Standalone：Spark自带的简单的资源管理系统，负责跟踪集群状态并调度计算任务</li><li>Kubernets：谷歌开发的一个强大的容器编排框架，用户通过Kubernets管理容器，不需要和底层交互</li></ul><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>网格系统：</p><ul><li>一种能够整合的合作使用的由多家组织拥有和管理的高端计算机、网络、数据库、实验设备等基础设施</li><li>网格是一类并行、分布式系统，能够在运行时动态分享、选择、聚合地理散布得自治资源，依据它们的可用性、能力、性能、代价以及用户对服务质量的需求，构建满足用户需求的设备组合</li><li>网格技术解决的主要问题是合作研究中的社会问题，包括：<ul><li>改善分布式管理，同时保持对本地资源的全面控制</li><li>改善数据可用性，识别问题和数据访问模式的解决方案</li><li>为学者提供友好的环境，能够访问更大范围的地理上分布的设备，提高产率</li></ul></li></ul><p>P2P系统：</p><ul><li>是一种在对等者之间分配任务和工作负载的分布式应用架构的系统</li><li>所有参与者角色相同，都对外共享它们拥有的一部分硬件资源，这些资源可以被系统内其他参与者访问</li><li>性质：高度分散化；自组织性；多管理域</li><li>特点（优点）：部署门槛低；增长速度快；容错性高；资源的丰富性和多样性高</li><li>应用：共享及分发文件；流媒体；网络电话；志愿计算等</li></ul><p>区块链：</p><ul><li><p>一种去中心化、不可篡改、可追溯、多方共同维护的分布式数据库系统</p></li><li><p>集成了P2P协议、非对称加密技术、共识机制、块链结构等多种技术，解决数据的可信问题</p>  <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210132248086.png" alt="image-20221013224834015" style="zoom:50%;" /></li></ul><h5 id="分布式计算、存储和资源管理系统—Hadoop-2-0"><a href="#分布式计算、存储和资源管理系统—Hadoop-2-0" class="headerlink" title="分布式计算、存储和资源管理系统—Hadoop 2.0"></a>分布式计算、存储和资源管理系统—Hadoop 2.0</h5><ul><li>Yarn做分布式资源管理</li><li>HDFS做分布式存储</li><li>MapReduce做分布式计算</li></ul><p>分布式存储：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251649215.png" alt="image-20221025164945152" style="zoom:50%;" /><p>分布式计算：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251651507.png" alt="image-20221025165158421" style="zoom:50%;" /><p>分布式计算——Hadoop MapReduce 框架：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251653531.png" alt="image-20221025165321351" style="zoom:50%;" /><p>资源管理——Yarn：管理计算机资源、提供用户和程序访问系统资源的API</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251654123.png" alt="image-20221025165433968" style="zoom:50%;" /><p>资源管理——Yarn是可编程的，不仅仅支持自带的MapReduce，还可以自定义算子</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251655762.png" alt="image-20221025165556672" style="zoom:50%;" /><h5 id="分布式计算和资源管理系统—Spark"><a href="#分布式计算和资源管理系统—Spark" class="headerlink" title="分布式计算和资源管理系统—Spark"></a>分布式计算和资源管理系统—Spark</h5><p>没有类似 HDFS 的分布式文件（存储）系统，但是有一套分布式内存管理系统（核心）</p><center>    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251641105.png" alt="image-20221025164127997" style="zoom:45%;" />    <img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251642695.png" alt="image-20221025164200617" style="zoom:45%;" /></center><p>Spark 是建立在弹性分布式数据集（RDD）之上的</p><p>RDD 使得 Spark 可以用一致的方式处理大数据的不同应用场景</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210251646318.png" alt="image-20221025164642100" style="zoom:50%;" /><h4 id="分布式存储系统"><a href="#分布式存储系统" class="headerlink" title="分布式存储系统"></a>分布式存储系统</h4><h5 id="数据和系统类型"><a href="#数据和系统类型" class="headerlink" title="数据和系统类型"></a>数据和系统类型</h5><ul><li><p>分布式文件系统——泛指以分布式的方式存储文件的系统，文件可以多种形式存在</p><ul><li>三种数据类型：二进制大对象(Blob)，定长块，大文件</li><li>提供不同类型的存储服务：对象存储、文件存储、块存储</li><li>可以作为分布式健值存储、分布式表、分布式数据的底层存储（GFS，弹性块存储EBS，Ceph）</li></ul></li><li><p>分布式健值系统</p><ul><li>用来存储关系简单的半结构化数据，提供基于主键的 CRUD 功能</li><li>可以看作是对分布式表的简化，一般用来作缓存，例如 Memcached</li><li>常用技术是一致性 Hash</li></ul></li><li><p>分布式表</p><ul><li>用于存储半结构化数据；以表格为单位组织数据，一个表格有多行，通过主键标识一行</li><li>不仅仅支持简单的CRUD，还支持扫描某个主键的范围和范围查找功能（Google Bigtable）</li></ul></li><li><p>分布式数据库</p><ul><li>基于传统关系型数据库发展而来，例如分布式 MySQL</li></ul></li></ul><h5 id="文件系统的发展"><a href="#文件系统的发展" class="headerlink" title="文件系统的发展"></a>文件系统的发展</h5><ul><li>单机文件系统：使用树型数据结构组织文件、目录以及访问控制；三类数据模型：文件、关系、健值，对应文件系统、数据库、健值存储</li><li>网络文件系统：让用户能够以访问本地文件系统的方式访问远程机器上的文件，提供跨平台的文件共享系统</li><li>并行文件系统：用在大规模并行处理体系结构中，保证一个业务的多个并行任务可以同时对同一个文件的不同位置并行处理</li><li>分布式文件系统：采用集中式管理、分布式存储的架构，将文件实际存储在多个不同的节点上，且每一个部分都有多个副本</li><li>高通量文件系统：专指为大型数据中心设计的分布式文件系统，将数据中心所有的低成本存储资源有效地组织起来服务于上层多种应用的数据存储需求和数据访问需求</li></ul><p>分布式存储系统面临的重要问题：</p><ul><li>如何将数据均匀的分布到多个存储节点</li><li>如何保证提供高可用性的数据多副本始终保持一致</li><li>如何检测节点故障并高效应对</li></ul><p>分布式存储系统的评价指标：</p><ul><li>性能：<ul><li>吞吐率-在某一段时间可以处理的请求总数</li><li>系统响应时间-从某个请求发出到收到结果的时间</li></ul></li><li>可用性：<ul><li>指在系统面对各种异常时可以提供的正常服务能力</li><li>用停止服务的时间和正常时间比重</li></ul></li><li>度量一致性：<ul><li>越强的一致性模型用户使用起来越简单——可能牺牲可用性或分区容错性</li></ul></li><li>可扩展性：<ul><li>能否通过增加服务器数量提高系统能力或者增加服务器的难度</li><li>理想的“线性可扩展”</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode</title>
      <link href="/2022/09/05/Leetcode/"/>
      <url>/2022/09/05/Leetcode/</url>
      
        <content type="html"><![CDATA[<h3 id="2022-09"><a href="#2022-09" class="headerlink" title="2022.09"></a>2022.09</h3><h4 id="9-5"><a href="#9-5" class="headerlink" title="9.5"></a>9.5</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209060904247.png" alt="image-20220906090456163" style="zoom:50%;" /><p>标签：二叉树序列化，哈希表，DFS</p><p>思路：用序列化的方式表示子树，通过字符串比较来判断子树是否重复</p><p>具体操作：通过 dfs 将二叉树序列化成 “root(左子树)(右子树)” 的形式，中间过程包含了所有子树的序列化结果，通过哈希表来保存重复的子树的根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 建立起序列化结果到子树的映射</span></span><br><span class="line">    Map&lt;String, TreeNode&gt; serialToTree = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;TreeNode&gt; repeated = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(repeated);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serial</span> <span class="operator">=</span> </span><br><span class="line">            node.val + <span class="string">&quot;(&quot;</span> + dfs(node.left) + <span class="string">&quot;)(&quot;</span> + dfs(node.right) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (serialToTree.containsKey(serial)) &#123; </span><br><span class="line">            repeated.add(serialToTree.get(serial));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; serialToTree.put(serial, node); &#125;</span><br><span class="line">        <span class="keyword">return</span> serial;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-6"><a href="#9-6" class="headerlink" title="9.6"></a>9.6</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209060920686.png" alt="image-20220906092058579" style="zoom:50%;" /><p>（暴力求解会超时）</p><p>标签：动态规划，哈希表</p><p>思路：分别计算每个字符的贡献，对于下标为 <em>i</em> 的字符，其在字符串中上一次出现在下标 <em>j</em> 处，下一次出现在下标 <em>k</em> 处，那么其贡献的个数为 <strong>(i-j) * (k-i)</strong></p><p>具体操作：先扫描一遍字符串，把每个出现的字符及其对应的位置（下标）通过 list 保存下来并维护一个映射关系（为了计算方便需要，每个 list 开头为 -1，结尾为 s.length()），然后遍历扫描结果按照思路中的计算方法进行计算并累加求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniqueLetterString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(ch)) &#123;</span><br><span class="line">            map.put(ch, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            map.get(ch).add(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(ch).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : map.keySet()) &#123;</span><br><span class="line">        List&lt;Integer&gt; tmp = map.get(ch);</span><br><span class="line">        tmp.add(s.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; tmp.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            res += (tmp.get(i) - tmp.get(i-<span class="number">1</span>)) * (tmp.get(i+<span class="number">1</span>) - tmp.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209070905821.png" alt="image-20220907090554737" style="zoom:50%;" /><p>思路：通过 <em>split(“\s+”)</em> 方法获取所有的单词（注意去掉前置和后置的空格，否则得到的单词中有空串）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reorderSpaces</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> text.length();</span><br><span class="line">    String[] words = text.trim().split(<span class="string">&quot;\s+&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numOfSpace</span> <span class="operator">=</span> len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; ++i) &#123;</span><br><span class="line">        numOfSpace -= words[i].length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">intervalSpaceCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        intervalSpaceCnt = numOfSpace / (list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSpaceCnt</span> <span class="operator">=</span> numOfSpace - intervalSpaceCnt * (list.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(list.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; intervalSpaceCnt; ++j) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; leftSpaceCnt; ++j) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-8"><a href="#9-8" class="headerlink" title="9.8"></a>9.8</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209081036138.png" alt="image-20220908103617060" style="zoom:50%;" /><p>先考虑特殊情况，当 k = n-1 时，通过大小交替的排序方式可以满足题目要求，即 [1,n,2,n-1,3,n-2,4, …]</p><p>故想到，可以将 1~n-k 先按顺序排列，剩 k 个数大小交替排列，即 [1, 2, …, n-k, n, n-k+1, n-1, n-k+2,…]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] constructArray(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n - k; ++i) &#123;</span><br><span class="line">        ans[i-<span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">even</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ans[n - k + j] = n - odd;</span><br><span class="line">            ++odd;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[n - k + j] = n - even;</span><br><span class="line">            --even;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-9"><a href="#9-9" class="headerlink" title="9.9"></a>9.9</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209090949235.png" alt="image-20220909094926123" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(String[] logs)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; logs.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logs[i].equals(<span class="string">&quot;./&quot;</span>)) &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logs[i].equals(<span class="string">&quot;../&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (steps &gt; <span class="number">0</span>) --steps;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ++steps;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-10"><a href="#9-10" class="headerlink" title="9.10"></a>9.10</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209101151018.png" alt="image-20220910115125927" style="zoom:50%;" /><p>标签：深度搜索，二叉搜索树</p><p>思路：根据二叉搜索树的性质，有以下情况</p><ul><li>若某一节点的<strong>左</strong>子节点<strong>不在</strong>边界范围内，则该节点的<strong>左子树</strong>都<strong>不在</strong>边界范围内</li><li>若某一节点的<strong>右</strong>子节点<strong>不在</strong>边界范围内，则该节点的<strong>右子树</strong>都<strong>不在</strong>边界范围内</li><li>若某一节点的<strong>左</strong>子节点<strong>在</strong>边界范围内，则该节点的<strong>右子树</strong>都<strong>在</strong>边界范围内</li><li>若某一节点的<strong>右</strong>子节点<strong>在</strong>边界范围内，则该节点的<strong>左子树</strong>都<strong>在</strong>边界范围内</li></ul><p>故可以迭代地将不满足条件的节点从二叉搜索树中剔除</p><p>注意：迭代之前需要用类似的方法找到一个满足条件的新的根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">null</span> &amp;&amp; (root.val &lt; low || root.val &gt; high)) &#123;</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; low) &#123; root = root.right; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; root = root.left; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.left.val &lt; low) &#123; node.left = node.left.right; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; node = node.left; &#125;</span><br><span class="line">&#125;</span><br><span class="line">node = root;</span><br><span class="line"><span class="keyword">while</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.right.val &gt; high) &#123; node.right = node.right.left; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; node = node.right; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另附上递归（深度搜索）的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; high) &#123; <span class="keyword">return</span> trimBST(root.left, low, high); &#125;</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; low) &#123; <span class="keyword">return</span> trimBST(root.right, low, high); &#125;</span><br><span class="line">root.left = trimBST(root.left, low, high);</span><br><span class="line">root.right = <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-11"><a href="#9-11" class="headerlink" title="9.11"></a>9.11</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209110953590.png" alt="image-20190911095307193" style="zoom:50%;" /><p>标签：贪心，优先队列</p><p>思路：每个人应得的报酬根据其工作质量的比例从总报酬中分配，并需要满足不低于最低期望，如①式</p><p>记一个工人的最低期望工资与对应工作质量之比为ε，经推导，要使总报酬最低，需要总工作质量相同的情况下使得最大的ε值最小，也即，选定了最大ε值的工人之后，其余工人工作质量之和尽量小<br>$$<br>Pay_{i}=\Sigma Pay_{i}×\frac{Quality_{i}}{\Sigma Quality_{i}}≥Wage_{i};①\<br>\Sigma Pay_{i}≥\Sigma Quality_{i}×\frac{Wage_{i}}{Quality_{i}};②\<br>\Sigma Pay_{i}≥\Sigma Quality_{i}×\epsilon_{max};③\<br>$$<br>具体操作：将工人按照ε值从小到大的排序，并逐个添加到一个以工作质量为比较标准的最大堆中，保证先入堆的工人ε值较小。从第k个工人入堆开始需要计算当前k个人产生的总成本，与已有结果比较取更小者。下一个工人入堆之前，需要将已有的k个工人中工作质量最优的人剔除（最大ε值增加而总工作质量尽量地减小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">mincostToHireWorkers</span><span class="params">(<span class="type">int</span>[] quality, <span class="type">int</span>[] wage, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wage.length;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; worker = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        worker.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;quality[i], wage[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    worker.sort((a, b) -&gt; &#123; <span class="keyword">return</span> a[<span class="number">1</span>] * b[<span class="number">0</span>] - a[<span class="number">0</span>] * b[<span class="number">1</span>]; &#125;);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">    <span class="type">double</span> <span class="variable">minCost</span> <span class="operator">=</span> Double.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalQuality</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k-<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> worker.get(i)[<span class="number">0</span>];</span><br><span class="line">        totalQuality += q;</span><br><span class="line">        pq.offer(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k-<span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> worker.get(i)[<span class="number">0</span>];</span><br><span class="line">        totalQuality += q;</span><br><span class="line">        pq.offer(q);</span><br><span class="line">        <span class="type">double</span> <span class="variable">ratio</span> <span class="operator">=</span> worker.get(i)[<span class="number">1</span>] / (<span class="type">double</span>) q;</span><br><span class="line">        minCost = Math.min(minCost, totalQuality * ratio);</span><br><span class="line">        totalQuality -= pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-12"><a href="#9-12" class="headerlink" title="9.12"></a>9.12</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209122134037.png" alt="image-20220912213454957" style="zoom:50%;" /><p>思路：排序后遍历比较</p><p>具体操作：将数组降序排列，一次遍历，同时满足 <strong>①第k个数大于等于k</strong> 且 <strong>② 第k+1个数小于k</strong> 则返回k，若不满足条件①则不存在特征值，若不满足条件②则继续遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">specialArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Integer[] a = Arrays.stream(nums).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">    Arrays.sort(a, Collections.reverseOrder());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= a.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i-<span class="number">1</span>] &gt;= i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == a.length || a[i] &lt; i) &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-13"><a href="#9-13" class="headerlink" title="9.13"></a>9.13</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209131100155.png" alt="image-20220913110028095" style="zoom:50%;" /><p>思路：要使交换后一个 n 位数尽量大，应当在前 k 位已经最大的情况下，将第 k+1 位与第 k+2 到第 n 位中最大且最靠近个位的位进行交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSwap</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; intBits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; intBitsInOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">intBit</span> <span class="operator">=</span> temp % <span class="number">10</span>;</span><br><span class="line">        intBits.add(intBit);</span><br><span class="line">        intBitsInOrder.add(intBit);</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    intBitsInOrder.sort(Comparator.naturalOrder());</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intBits.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">indexToChange</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intBits.get(i) == intBitsInOrder.get(i)) <span class="keyword">continue</span>;</span><br><span class="line">        indexToChange = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (indexToChange == -<span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; indexToChange; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intBits.get(i) == intBitsInOrder.get(indexToChange)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxSwap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n-<span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j;</span><br><span class="line">                <span class="keyword">if</span> (index == indexToChange) index = i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (index == i) index = indexToChange;</span><br><span class="line">                maxSwap = maxSwap * <span class="number">10</span> + intBits.get(index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxSwap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// unreachable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-14"><a href="#9-14" class="headerlink" title="9.14"></a>9.14</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209140035840.png" alt="image-20220914003555785" style="zoom:50%;" /><p>傻子题不想动脑子了…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">trimMean</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> len * <span class="number">5</span> / <span class="number">100</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; len-n; ++i) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / (len - <span class="number">2</span>*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-15"><a href="#9-15" class="headerlink" title="9.15"></a>9.15</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209152105646.png" alt="image-20220915210536590" style="zoom:50%;" /><p>思路：过滤+排序，可以使用 Java8 中的 <em>Stream</em> 类型来清晰地处理</p><p>具体实现：<em>filter</em> 过滤流中的元素；<em>sorted</em> 对流中的元素排序；<em>map</em> 对流中的元素进行映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">filterRestaurants</span><span class="params">(<span class="type">int</span>[][] restaurants, <span class="type">int</span> veganFriendly, <span class="type">int</span> maxPrice, <span class="type">int</span> maxDistance)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Arrays.stream(restaurants)</span><br><span class="line">.filter(e -&gt; veganFriendly == <span class="number">0</span> || veganFriendly == <span class="number">1</span> &amp;&amp; e[<span class="number">2</span>] == <span class="number">1</span>)</span><br><span class="line">.filter(e -&gt; e[<span class="number">3</span>] &lt;= maxPrice)</span><br><span class="line">.filter(e -&gt; e[<span class="number">4</span>] &lt;= maxDistance)</span><br><span class="line">.sorted((a, b) -&gt; a[<span class="number">1</span>] != b[<span class="number">1</span>] ? b[<span class="number">1</span>] - a[<span class="number">1</span>] : b[<span class="number">0</span>] - a[<span class="number">0</span>])</span><br><span class="line">.map(e -&gt; e[<span class="number">0</span>])</span><br><span class="line">.toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-16"><a href="#9-16" class="headerlink" title="9.16"></a>9.16</h4><p>太难了做不出来，答案也看不懂，咕咕咕~</p><h4 id="9-17"><a href="#9-17" class="headerlink" title="9.17"></a>9.17</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209171006533.png" alt="image-20220917100645450" style="zoom:50%;" /><p>简单题美滋滋~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLengthBetweenEqualCharacters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">Set&lt;Character&gt; letters = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">letters.add(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : letters) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.indexOf(ch);</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.lastIndexOf(ch);</span><br><span class="line">maxLen = Math.max(j-i-<span class="number">1</span>, maxLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-18"><a href="#9-18" class="headerlink" title="9.18"></a>9.18</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209181754074.png" alt="image-20220918175455009" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-19"><a href="#9-19" class="headerlink" title="9.19"></a>9.19</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209191026089.png" alt="image-20220919102640021" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] frequencySort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (freqMap.containsKey(nums[i])) &#123;</span><br><span class="line">freqMap.replace(nums[i], freqMap.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">freqMap.put(nums[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Integer[] temp = Arrays.stream(nums).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">Arrays.sort(temp, (x,y) -&gt;</span><br><span class="line">freqMap.get(x) == freqMap.get(y) ? y-x : freqMap.get(x)-freqMap.get(y));</span><br><span class="line"><span class="keyword">return</span> Arrays.stream(temp).mapToInt(Integer::valueOf).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-20"><a href="#9-20" class="headerlink" title="9.20"></a>9.20</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209201951230.png" alt="image-20220920195130145" style="zoom:50%;" /><blockquote><p>不会做… 抄的网上的答案…</p></blockquote><p>思路：递归地按照从大到小的顺序把数组中的数放入k个槽位中，使得每个槽位中数的和小于等于目标和</p><p>剪枝策略：<strong>若 <code>cur[j]</code> 与 <code>cur[j-1]</code> 相等，意味着在 <code>cur[j-1]</code> 时已经完成了搜索，可跳过当前的搜索</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line"><span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">subSum</span> <span class="operator">=</span> sum / k;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="type">int</span>[] curSum = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line"><span class="keyword">return</span> dfs(nums, curSum, subSum, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] curSum, <span class="type">int</span> subSum, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; curSum.length; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; curSum[j] == curSum[j-<span class="number">1</span>]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">curSum[j] += nums[i];</span><br><span class="line"><span class="keyword">if</span> (curSum[j] &lt;= subSum &amp;&amp; dfs(nums, curSum, subSum, i-<span class="number">1</span>)) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">curSum[j] -= nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-21"><a href="#9-21" class="headerlink" title="9.21"></a>9.21</h4><p>咕咕咕~</p><h4 id="9-22"><a href="#9-22" class="headerlink" title="9.22"></a>9.22</h4><p>？？？</p><h4 id="9-23"><a href="#9-23" class="headerlink" title="9.23"></a>9.23</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231258100.png" alt="image-20220923125807981" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.head.prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.head.next = <span class="built_in">this</span>.tail;</span><br><span class="line">        <span class="built_in">this</span>.tail.prev = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="built_in">this</span>.tail.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; ++i) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        node.next = <span class="built_in">this</span>.head.next;</span><br><span class="line">        <span class="built_in">this</span>.head.next.prev = node;</span><br><span class="line">        node.prev = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="built_in">this</span>.head.next = node;</span><br><span class="line">        ++<span class="built_in">this</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        node.prev = <span class="built_in">this</span>.tail.prev;</span><br><span class="line">        <span class="built_in">this</span>.tail.prev.next = node;</span><br><span class="line">        node.next = <span class="built_in">this</span>.tail;</span><br><span class="line">        <span class="built_in">this</span>.tail.prev = node;</span><br><span class="line">        ++<span class="built_in">this</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="built_in">this</span>.length) &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.length) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; ++i) &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> curr.prev;</span><br><span class="line">            prev.next = node;</span><br><span class="line">            node.prev = prev;</span><br><span class="line">            node.next = curr;</span><br><span class="line">            curr.prev = node;</span><br><span class="line">            ++<span class="built_in">this</span>.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.length) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; ++i) &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> curr.prev;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            --<span class="built_in">this</span>.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《自动化测试》课程笔记</title>
      <link href="/2022/08/10/NJU-Software-Testing/"/>
      <url>/2022/08/10/NJU-Software-Testing/</url>
      
        <content type="html"><![CDATA[<p>课程预习资料来源：<a href="https://www.icourse163.org/learn/NJU-1001773008?tid=1450627499#/">https://www.icourse163.org/learn/NJU-1001773008?tid=1450627499#/</a></p><h2 id="预习"><a href="#预习" class="headerlink" title="预习"></a>预习</h2><h3 id="软件测试基础"><a href="#软件测试基础" class="headerlink" title="软件测试基础"></a>软件测试基础</h3><h4 id="PIE-模型"><a href="#PIE-模型" class="headerlink" title="PIE 模型"></a><em>PIE</em> 模型</h4><p>概念辨析：</p><ul><li><em>Fault</em>：程序中存在的静态错误（编程过程中产生）</li><li><em>Error</em>：程序因运行到其中的 <em>Fault(s)</em> 而进入的错误的中间状态（程序运行时产生）</li><li><em>Failure</em>：<em>Error(s)</em> 传播到程序外部，使得用户观测到与预期不符的错误行为（程序行为完成时产生）</li></ul><p><em>PIE</em> 模型：</p><ul><li>Execution/Reachability：程序中含有 <em>fault</em> 的地方必须被执行到</li><li>Infection：程序必须进入错误的中间状态（<em>error</em>）</li><li>Propagation：被感染的状态必须传播到程序外部，即导致程序错误的输出结果（产生 <em>failure</em>）</li></ul><p>针对 <em>PIE</em> 模型的分析：</p><ul><li>测试不一定能执行到带有 <em>fault</em> 的语句</li><li>测试执行到带有 <em>fault</em> 的语句，不一定会触发 <em>error</em></li><li>测试执行到带有 <em>fault</em> 的语句并触发 <em>error</em>，不一定会产生 <em>failure</em></li></ul><h4 id="软件测试术语"><a href="#软件测试术语" class="headerlink" title="软件测试术语"></a>软件测试术语</h4><p>测试用例（<em>test case</em>）：</p><ul><li>测试输入（<em>test input</em>）：<em>test data</em></li><li>测试预言（<em>test oracle</em>）：<em>expected output</em></li><li>其他（<em>others</em>）：<em>environment</em></li></ul><p>测试（<em>testing</em>）：执行测试并观测 <em>failure</em>（发现 <em>bug</em>）</p><p>调试（<em>debugging</em>）：定位、理解并改正 <em>fault</em>（修复 <em>bug</em>）</p><p>确认（<em>validation</em>）：确认规格文档是否与用户需求相符</p><p>确认（<em>verification</em>）：确认最终实现是否满足规格文档</p><p>静态测试（<em>static testing</em>）：不运行程序</p><p>动态测试（<em>dynamic testing</em>）：运行程序</p><p>黑盒测试（<em>black-box testing</em>）：不需要源代码</p><p>白盒测试（<em>white-box testing</em>）：需要源代码</p><p>灰盒测试（<em>gray-box testing</em>）：通过反编译等手段获得了部分结构信息</p><p>测试过程：<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102310315.png" alt="image-20220810231017192" style="zoom:50%;" /></p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><h4 id="测试中的图"><a href="#测试中的图" class="headerlink" title="测试中的图"></a>测试中的图</h4><p>测试路径：从初始节点到终结节点的一条路径（可以通过设定哑节点使初始节点和终结节点唯一）</p><p>测试路径代表了测试用例的执行情况（有些路径可以被多个测试用例执行到，有些路径不可被执行到）</p><p>path( <em>t</em> ) 表示测试 <em>t</em> 执行的测试路径；path( <em>T</em> ) 表示测试集合 <em>T</em> 执行的测试路径集合</p><p>本课程不考虑非确定性环境，即认为一个测试用例只能执行到一条测试路径</p><h4 id="图覆盖准则"><a href="#图覆盖准则" class="headerlink" title="图覆盖准则"></a>图覆盖准则</h4><p>语法可达（<em>Syntactic reach</em>）：通过语法构建的图中存在一条路径</p><p>语义可达（<em>Semantic reach</em>）：存在能够被执行到的测试路径</p><p>覆盖（<em>Cover</em>）：</p><ul><li>如果节点 <em>v</em> 在测试路径 <em>p</em> 中，则该测试路径 <em>p</em> 覆盖节点 <em>v</em></li><li>如果边 <em>e</em> 在测试路径 <em>p</em> 中，则该测试路径 <em>p</em> 覆盖边 <em>e</em></li><li>如果子路径 <em>p’</em> 在测试路径 <em>p</em> 中，则该测试路径 <em>p</em> 覆盖子路径 <em>p’</em></li></ul><p>测试需求（<em>Test Requirement</em>）：描述测试路径性质</p><p>测试准则（<em>Test Criterion</em>）：描述测试需求的规则</p><p>给定一个测试准则 <em>C</em>，派生出对应的测试需求集 <em>TR</em>，定义一个测试用例集 <em>T</em>  满足 <em>C</em>，当且仅当对于 <em>TR</em> 中的每个测试需求，集合 path( <em>T</em> ) 中都存在一条测试路径满足该测试需求</p><h4 id="结构化覆盖"><a href="#结构化覆盖" class="headerlink" title="结构化覆盖"></a>结构化覆盖</h4><p>顶点覆盖；边覆盖；边对覆盖（字面意思）</p><p>n-路径覆盖：为了定义的完整性，要求长度覆盖小于等于 n 的所有路径</p><p>蕴含（<em>Subsume</em>）：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151107010.png" alt="image-20220815110709940" style="zoom: 40%;" /><p>结构化覆盖的例子：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151109982.png" alt="image-20220815110904886" style="zoom:50%;" /><h4 id="控制流测试"><a href="#控制流测试" class="headerlink" title="控制流测试"></a>控制流测试</h4><p>将程序按照一定的粒度（语句、语句块、函数、模块）转换为控制流图</p><p>使用 <em>Soot</em> 为 <em>Java</em> 程序自动生成控制流图</p><h4 id="数据流测试"><a href="#数据流测试" class="headerlink" title="数据流测试"></a>数据流测试</h4><p>关于数据流的几个定义：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151113624.png" alt="image-20220815111350511" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151114319.png" alt="image-20220815111440247" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151115743.png" alt="image-20220815111513638" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151116857.png" alt="image-20220815111601773" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151117998.png" alt="image-20220815111711863" style="zoom:40%;" /><p>数据流覆盖准则：</p><p>定义覆盖；引用覆盖；定义引用路径覆盖</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151118980.png" alt="image-20220815111825820" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151119254.png" alt="image-20220815111953197" style="zoom:40%;" /><h4 id="JUNIT-使用示例"><a href="#JUNIT-使用示例" class="headerlink" title="JUNIT 使用示例"></a>JUNIT 使用示例</h4><p>Maven 中的配置信息：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151121881.png" alt="image-20220815112155844" style="zoom:50%;" /><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><h4 id="随机测试"><a href="#随机测试" class="headerlink" title="随机测试"></a>随机测试</h4><p>随机测试（模糊测试）</p><p>自适应随机测试</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151127955.png" alt="image-20220815112710890" style="zoom:40%;" /><p>反随机测试（应对离散的输入域）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151129731.png" alt="image-20220815112944651" style="zoom:40%;" /><h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><p>将输入域划分为一系列子集（等价类），在每个子集中选取有代表性的测试用例进行测试</p><p>划分准则：不同类型数据的处理；不同的数据流或控制流；合法或非法输入</p><p>等价类划分需要满足完备性和无冗余性</p><h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><p>（字面意思）</p><h4 id="组合测试"><a href="#组合测试" class="headerlink" title="组合测试"></a>组合测试</h4><p>完全组合测试：组合数等于各输入等价类个数的乘积，测试代价高</p><p>两两组合测试：覆盖任意两个测试变量之间所有的取值组合（可以推广到 <em>T-wise combinatorial test</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208151148998.png" alt="image-20220815114858813" style="zoom:40%;" /><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><h4 id="功能测试简介"><a href="#功能测试简介" class="headerlink" title="功能测试简介"></a>功能测试简介</h4><p>功能测试常用步骤：</p><ul><li>根据需求细分功能点</li><li>根据功能点派生测试需求</li><li>根据测试需求设计功能测试用例</li><li>逐项执行功能测试用例验证产品</li></ul><h4 id="探索式测试"><a href="#探索式测试" class="headerlink" title="探索式测试"></a>探索式测试</h4><p>探索式测试是一种软件测试风格</p><p>强调独立测试人员的个人职责和自由</p><p>将测试学习、设计、执行、结果分析作为相互支持的活动</p><p>在整个项目中并行地执行</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208161241281.png" alt="image-20220816124129162" style="zoom:40%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208161242881.png" alt="image-20220816124227760" style="zoom:40%;" /><p>强调：关注价值、风险驱动</p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>度量方法：</p><ul><li>服务端性能采用 CPU、内存等使用率来度量</li><li>客户端性能通常根据系统处理特定用户请求的响应时间来度量</li></ul><p>响应时间 = 服务端响应时间 + 客户端响应时间</p><p>并发用户数（取决于测试对象的目标业务场景）</p><p>吞吐量：单位时间内处理的用户请求数量</p><p>负载测试：验证系统在正常的负载条件下的行为</p><p>压力测试：评估系统处于或超过预期负载时的行为</p><h3 id="移动应用测试"><a href="#移动应用测试" class="headerlink" title="移动应用测试"></a>移动应用测试</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Android 测试工具：</p><ul><li><em>Monkey</em></li><li><em>Android Instrumentation</em></li><li><em>Android BDD-Calabash</em></li></ul><p>众包测试：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208161249785.png" alt="image-20220816124907539" style="zoom:40%;" /><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h3 id="一些测试思想："><a href="#一些测试思想：" class="headerlink" title="一些测试思想："></a>一些测试思想：</h3><p><strong>模糊测试</strong>：通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072113715.png" alt="image-20220907211354434" style="zoom: 50%;" /><p><strong>变异测试</strong>：在细节方面改进程序源代码的软件测试方法。这些所谓的变异，是基于良好定义的变异操作，这些操作或者是模拟典型应用错误（例如：使用错误的操作符或者变量名字），或者是强制产生有效地测试（例如使得每个表达式都等于0）。目的是帮助测试者发现有效地测试，或者定位测试数据的弱点，或者是在执行中很少（或从不）使用的代码的弱点。</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072115661.png" alt="image-20220907211512430" style="zoom: 50%;" /><p><strong>蜕变测试</strong>：用来缓解“测试准则问题”的软件测试技术。 测试准则是一种让测试人员判定程序是否能通过测试的机制。当测试人员对于所选择的测试用例难以确定预期的正确结果，或无法判定程序输出是否满足预期的结果时，便认为存在“测试准则问题”。</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072116482.png" alt="image-20220907211603369" style="zoom:50%;" /><p><strong>差分测试</strong>：通过将同一测试用例运行到一系列相似功能的应用中观察执行差异来检测 bug</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209072116833.png" alt="image-20220907211634669" style="zoom:50%;" /><h3 id="一些已有的研究成果："><a href="#一些已有的研究成果：" class="headerlink" title="一些已有的研究成果："></a>一些已有的研究成果：</h3><ul><li>自动化测试脚本修复</li><li>测试用例推荐</li><li>基于互联网群体 智能的软件测试</li><li>智能软件测试</li><li>众包协作：一棵Bug报告树的生长</li><li>面向群体智能的测试报告自动化分析</li><li>面向群体智能的Bug截屏文本自动生成</li><li>基于截图理解的测试回放技术</li><li>基于深度图像理 解的报告排序</li><li>基于多源信息语义关联的众测报告半监督聚类</li><li>基于强化学习和图像理解的跨平台测试技术</li><li>面向群体智能的测试自动回放</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209092049620.png" alt="image-20220909204917288" style="zoom:50%;" /><h3 id="变异测试"><a href="#变异测试" class="headerlink" title="变异测试"></a>变异测试</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>变异测试的产生：</p><ul><li><p><strong>模拟</strong>缺陷，<strong>量化</strong>缺陷检测能力，指示测试有效性</p><ul><li><p>模拟：变异产生错误版本，模拟探测 bug 的过程</p></li><li><p>量化：变异得分（变异杀死率）</p></li></ul></li></ul><p>变异体：基于语法变换规则，通过对源程序进行程序变换得到的一系列变体（假设源程序不包含缺陷；假设变异体表达了某种缺陷）</p><p>变异得分：变异测试对测试套件检错能力的量化（变异体杀死率）</p><p>变异体的分类：有效；夭折（编译不通过）；冗余（等价、重复、蕴含）</p><p>变异算子：</p><ul><li><p>一系列语法变换规则</p></li><li><p>变异的依据，反应了测试人员关注的缺陷种类</p></li><li><p>基本形式</p><ul><li>对程序源码进行变换</li><li>对程序编译结果（中间表示）进行变换</li><li>元变异</li></ul></li></ul><p>基础假设：</p><ul><li>缺陷是简单的、可模拟的</li><li>缺陷是可叠加的</li><li>缺陷检测是有效的</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231453551.png" alt="image-20220923145344456" style="zoom:50%;" /><p>变异体筛选：对变异体进行筛选；对变异算子进行筛选（研究方向：变异算子的定义与约减策略）</p><p>变异体生成：将选中的变异算子实例化（研究方向：元变异，基于字节码操作，热替换）</p><p>变异体优化：</p><ul><li>识别等价变异体：代码优化 / 数据流分析</li><li>识别冗余变异体：操作符角度 / 缺陷层级角度 / 程序分析角度</li></ul><p>变异体执行：变异测试过程中最昂贵的阶段</p><ul><li><p>研究内容：针对<strong>计算变异得分</strong>（场景A）/ <strong>计算变异矩阵</strong>（场景B）优化执行过程</p></li><li><p>优化策略</p><ul><li>改变测试用例顺序（A）</li><li>匹配测试用例与变异体（A）</li><li>避免执行必定存活的变异体（A, B）</li><li>限定变异体的执行时间（A, B）</li></ul></li></ul><p>变异得分计算：（研究内容：变异杀死的条件，测试预言的生成）</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>评估作用：变异得分评估测试充分性</p><p>引导作用：利用变异测试 / 分析结果引导测试过程</p><p>传统应用：应用于确定性系统</p><ul><li>测试生成</li><li>语言生成</li><li>测试优化</li><li>debug 引导</li></ul><p>变异 &amp; AI：应用于非确定性系统</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231455917.png" alt="image-20220923145535799" style="zoom:50%;" /><h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><h4 id="起源与发展"><a href="#起源与发展" class="headerlink" title="起源与发展"></a>起源与发展</h4><p>模糊测试的诞生：</p><p>由字符乱码能够导致程序崩溃的现象启发，为提高 UINX 系统的可靠性，以随机字符串作为输入，运行操作系统组件，观察是否发生崩溃</p><p>近期发展：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231502603.png" alt="image-20220923150234520" style="zoom:50%;" /><h4 id="概念与架构"><a href="#概念与架构" class="headerlink" title="概念与架构"></a>概念与架构</h4><p>初始构想：工具（模糊器 Fuzzer） + 目标（待测程序 PUT） + 循环（执行程序 ⇆ 崩溃分派）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231508681.png" alt="image-20220923150810475" style="zoom:40%;" /><p>相关术语：</p><ul><li>模糊：从模糊输入空间得到输入来执行 DUT 的过程</li><li>模糊测试：应用模糊过程来验证 DUT 是否违反正确性策略的测试技术</li><li>模糊器：用于实现模糊测试的程序（核心，需要完成输入生成、测试执行和输出分析）</li><li>模糊运动：Fuzzer 按照特定的 Correctness Policy 在给定 DUT 上的一次具体的执行</li><li>缺陷预言：用于确定一次给定执行是否违反具体 Correctness Policy 的程序</li><li>模糊配置：控制和描述模糊（测试）算法的数据和约束</li><li>种子输入：在模糊测试过程中为输入生成提供基准的测试输入</li></ul><p>模糊测试框架：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202209231520555.png" alt="image-20220923152000213" style="zoom:40%;" /><h4 id="家族与分类"><a href="#家族与分类" class="headerlink" title="家族与分类"></a>家族与分类</h4><p>模糊测试家族：</p><ul><li>AFL家族（C/C++）：AFL、AFLFast、AFLSmart、AFLNet、 AFLGo、AFLIoT、FairFuzz、Mopt.、Neuzz</li><li>LibFuzzer家族（C/C++）：LibFuzzer、Entropic</li><li>JQF家族（Java）：JQF、BeDivFuzz、CONFETTI</li><li>其他（Rust、Python等）：Angora、DeepXplore</li></ul><p>模糊测试分类：</p><ul><li><p>按照采用的运行时信息：</p><ul><li>黑盒：仅从输入输出着手优化，利用输入格式或输出状态引导测试，效率高但有效性欠缺</li><li>白盒：使用混合分析、污点分析等昂贵白盒分析技术进行优化，利用详细程序分析结果引导测试，有效行高但效率低适配性差</li><li>灰盒：使用轻量级插桩监控程序，执行时收集各类信息并以此引导测试，黑盒白盒 trade-off</li></ul></li><li><p>按照输入生成的策略：</p><ul><li>基于变异：本质上是将种子输入转换为比特串进行变换，易于泛化但容易破环输入结构</li><li>基于生成：本质上是利用给定/挖掘/学习得到的文法规则来构建结构化输入，适用于对输入结构性要求较高的场景，但需要人工赋予一定的领域知识</li></ul></li><li><p>按照引导过程：</p><ul><li>Search-based：将测试转化为搜索问题，以代码覆盖率作为指示器、以启发式算法为核心，将测试导向更高覆盖的方向</li><li>Gradient-based：将测试转化为优化问题，以最大化缺陷发掘输入为目标构建目标函数，梯度下降算法迭代求最优解（若缺陷离散且无法预知，则将目标退阶为代码覆盖）</li></ul></li><li><p>按照测试的目的：</p><ul><li>定向：针对程序中的某个目标位置进行快而有效的测试</li><li>非定向：验证程序的正确性，检测程序中潜在的缺陷</li></ul></li><li><p>按照应用领域：网络协议、Compiler、DNN、IoT、内核</p></li><li><p>按照优化角度：种子调度、变异策略、能量调度、过程建模</p></li></ul><h4 id="iSE模糊测试"><a href="#iSE模糊测试" class="headerlink" title="iSE模糊测试"></a>iSE模糊测试</h4><h3 id="移动应用测试-1"><a href="#移动应用测试-1" class="headerlink" title="移动应用测试"></a>移动应用测试</h3><h4 id="众包测试"><a href="#众包测试" class="headerlink" title="众包测试"></a>众包测试</h4><h4 id="自动化测试-1"><a href="#自动化测试-1" class="headerlink" title="自动化测试"></a>自动化测试</h4><p>人为驱动的测试行为转化为机器执行</p><p>提升效率、降低成本、快速回归测试、保证测试一致性</p><p>开发时间周期长、对测试人员要求高、脚本维护开销大</p><p>adb 捕获移动应用内部状态</p><p>Appium</p><h3 id="代码摘要"><a href="#代码摘要" class="headerlink" title="代码摘要"></a>代码摘要</h3><p>代码摘要：翻译任务；特殊的文本摘要</p><p>研究目的：为缺少注释的旧代码补上注释；为新代码自动化生成注释</p><p>潜在应用场景：代码理解；代码审核；代码定位</p><p>早期工作：本文检索，从代码中提取关键词进行组合</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210141029336.png" alt="image-20221014102949158" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202210141032878.png" alt="image-20221014103234674" style="zoom:50%;" /><p>中期工作：分析已有工作的有效性（提取的关键词和程序员实际认为的关键词是否相符等问题）并提出优化方案</p><p>近期工作：数据驱动，深度学习模型</p><p>测试：</p><ul><li>黑盒，白盒，灰盒</li><li>单元，集成，系统</li><li>功能，性能，安全，</li></ul><ul><li>正向：等价类划分（组合，正交实验设计）</li><li>负向：故障假设（边界值，…）</li></ul><p>Bug：</p><ul><li>显性</li><li>隐性</li></ul><p>智能系统</p><p>图</p><p>软件分析 -&gt; 代码的图结构</p><p>随机：自适应随机</p><ul><li>AI for SE</li><li>SE for AI</li></ul>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 UniRLTest</title>
      <link href="/2022/08/03/About-UniRLTest/"/>
      <url>/2022/08/03/About-UniRLTest/</url>
      
        <content type="html"><![CDATA[<p>有幸能参与到实验室学长的一个项目当中，简单记录一下整个项目和一些收获</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><em>UniRLTest</em> 即 <em>Universal Reinforcement Learning Test</em>，是基于图像识别、深度强化学习等实现的跨平台软件测试工具</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端部分主要负责与后端和设备进行通讯，接收后端传来的操作指令并在设备上执行，获取设备上应用的屏幕截图并传给后端进行分析</p><p>文件大致结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">../urt/urt-frontend</span><br><span class="line">│  client.py</span><br><span class="line">│  launcher.py</span><br><span class="line">│  logger.py</span><br><span class="line">│  plt.py</span><br><span class="line">│  urt_android.py</span><br><span class="line">│          </span><br><span class="line">├─android</span><br><span class="line">│  │  action_executor.py</span><br><span class="line">│  │  plt_android.py</span><br><span class="line">│  │  screen_capture.py</span><br><span class="line">│  │  tool_base.py</span><br><span class="line">│  │  utils.py</span><br><span class="line">│      </span><br><span class="line">├─pc</span><br><span class="line">│  │  action_executor.py</span><br><span class="line">│  │  plt_pc.py</span><br><span class="line">│  │  screen_capture.py</span><br><span class="line">│  │  tool_base.py</span><br><span class="line">│          </span><br><span class="line">├─web</span><br><span class="line">│  │  action_executor.py</span><br><span class="line">│  │  plt_web.py</span><br><span class="line">│  │  screen_capture.py</span><br><span class="line">│  │  tool_base.py</span><br><span class="line">│</span><br><span class="line">├─configs</span><br><span class="line">│  │  configure.py</span><br><span class="line">│  │  ssh_config.json</span><br><span class="line">│  │</span><br><span class="line">│  ├─android    </span><br><span class="line">│  │</span><br><span class="line">│  ├─web</span><br><span class="line">│          </span><br><span class="line">├─coverages</span><br><span class="line">│              </span><br><span class="line">├─logs   </span><br></pre></td></tr></table></figure><p>前端的运行需要一个配置文件作为额外参数（e.g. configs/android/anymemo.json），配置文件结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// e.g.&quot;android&quot;/&quot;web&quot;/&quot;pc&quot;</span></span><br><span class="line"><span class="attr">&quot;serial_no&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 测试使用的设备</span></span><br><span class="line"><span class="attr">&quot;screen_size&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">// 设备的屏幕尺寸（屏幕截图的分辨率）</span></span><br><span class="line"><span class="attr">&quot;server_proj_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 服务器上部署的后端项目的路径，e.g.&quot;/root/urt&quot;</span></span><br><span class="line"><span class="attr">&quot;server_screenshot_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 后端保存屏幕截图的文件夹路径，e.g.&quot;screenshots&quot;</span></span><br><span class="line"><span class="attr">&quot;local_screenshot_path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 本地保存屏幕截图的文件路径，e.g.&quot;anymemo.png&quot;</span></span><br><span class="line"><span class="attr">&quot;window_keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;total_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 测试的总时长，单位为秒</span></span><br><span class="line"><span class="attr">&quot;banner_height&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;remote_port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">// 在服务器上使用的端口号，e.g.&quot;5000&quot;</span></span><br><span class="line"><span class="attr">&quot;app&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="comment">// 被测试应用的基本信息</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">//e.g.&quot;budgetwatch&quot;</span></span><br><span class="line"><span class="attr">&quot;pkg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">//e.g.&quot;protect.budgetwatch&quot;</span></span><br><span class="line"><span class="attr">&quot;main_activity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="comment">//e.g.&quot;protect.budgetwatch.test.InstrumentedActivity&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>此部分内容根据论文初稿整理</p></blockquote><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208051749222.png" alt="image-20220805174903049" style="zoom:50%;" /><h4 id="后端的功能主要分为两大模块："><a href="#后端的功能主要分为两大模块：" class="headerlink" title="后端的功能主要分为两大模块："></a>后端的功能主要分为两大模块：</h4><h5 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h5><ul><li><p>提取组件和页面布局特征</p><ul><li>使用 <em>Canny Edge Detection</em> 技术从屏幕截图中提取组件</li><li>根据提取到的组件构建一棵组件树来表示页面布局特征</li></ul></li><li><p>组件 Embedding</p><ul><li>组件图像经过卷积神经网络处理得到一个 4096 维向量，表示组件的图像信息</li><li>将屏幕截图的组件位置变为全白而其余地方变为全黑而得到的图片，经过卷积神经网络处理得到一个 4096 维向量，表示组件的位置信息（不使用坐标是为了相对图像信息有足够的权重）</li><li>组件图像经过卷积神经网络处理得到一个 14 维独热向量，表示组件的类型</li><li>将上述结果拼接而成一个 8206 维的向量，即为 embedding 的结果</li><li>以上所说的卷积神经网络，是一个预训练好的用于判断组件类型的 VGG-16 模型，4096 维的向量是其倒数第二层的输出，14 维的向量是其最后一层的输出</li></ul></li><li><p>页面布局 Embedding</p><ul><li>将树状结构的页面布局转化为字符串</li><li>将该字符串使用预训练好的 LSTM 模型处理，输出 512 维的向量，即为 embedding 的结果</li></ul></li><li><p>页面（app 状态）表示</p><ul><li>计算所有组件的 embedding 向量的平均值，即用一个 8206 维的向量表示所有组件</li><li>将组件和页面布局的 embedding 结果连接成 8718 维的向量，表示整个页面（app 状态）</li></ul></li></ul><h5 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h5><blockquote><p>这部分在此没有详细展开说明</p></blockquote><ul><li>动作生成<ul><li>用 17 维的独热向量表示动作类型</li><li>用 8026 维的向量表示实施动作的组件（没有则做 zero-padding）</li><li>用一维向量表示 window size 参数（没有则做 zero-padding）</li><li>表示一个动作的向量由上述向量连接而成</li></ul></li><li><em>Q-Network</em> 模型训练<ul><li>Q-Network 使用含有四个隐藏层的全连接神经网络</li><li>replay-memory 中保存了每次状态转换以及其对应的奖励值，也是训练模型的数据来源</li><li>随着测试的进行，模型需要被不断训练和更新</li></ul></li><li>动作决定<ul><li>通过 <em>Q-Network</em> 的输出可以得到当前页面下，所有可能动作被执行的优先级</li><li>使用 Boltzmann Strategy 决定下一个被执行的动作（避免被困在局部最优解）</li></ul></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p>Web 应用的测试和 PC 端应用的测试本人没有参与，所以以下内容只涉及安卓应用测试</p></blockquote><h4 id="安卓应用插桩测试方法"><a href="#安卓应用插桩测试方法" class="headerlink" title="安卓应用插桩测试方法"></a>安卓应用插桩测试方法</h4><h5 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h5><ul><li>Java：jdk8（较老的 gradle 无法用 jdk11 运行）和 jdk11（较新的 gradle 需要至少 jdk11 运行）</li><li>Gradle：不用额外安装，项目中自带的 gradlew 脚本能在当前自动安装对应版本的 gradle</li><li>Android SDK：使用 Android Studio 统一管理，环境变量中正确设置ANDROID_HOME的值</li></ul><h5 id="构建原项目："><a href="#构建原项目：" class="headerlink" title="构建原项目："></a>构建原项目：</h5><ul><li><p>在项目目录下执行如下命令进行构建：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --no-daemon --stacktrace assembleDebug</span><br></pre></td></tr></table></figure></li><li><p><em>–no-daemon</em> 表示 Gradle 守护进程会在命令执行完成后自动退出，不会常驻后台（因为不同应用依赖不同版本的gradle，守护进程没法很好的被复用，无需常驻后台）</p></li><li><p><em>–stacktrace</em> 表示若报错会打印堆栈信息</p></li><li><p><em>assembleDebug</em> 表示构建 debug 包</p></li><li><p>这一步的目的是保证应用本身可正常构建（其构建产物不会被后续使用）</p></li></ul><h5 id="添加插桩代码："><a href="#添加插桩代码：" class="headerlink" title="添加插桩代码："></a>添加插桩代码：</h5><ul><li><h6 id="使用-python-脚本一键插桩："><a href="#使用-python-脚本一键插桩：" class="headerlink" title="使用 python 脚本一键插桩："></a>使用 python 脚本一键插桩：</h6>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python instrument.py &#123;x&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：脚本完成了如下操作</p></li></ul><ol><li><p>备份 <em>app</em> 目录下的 <em>build.gradle</em>，并添加一个 <em>apply</em> 语句以应用 <em>jacoco</em> 插件</p></li><li><p>在 <em>app</em> 目录下添加 <em>jacoco-multi.gradle</em> 或 <em>jacoco-multi-kt.gradle</em>，包含了 <em>jacoco</em> 配置，其中后者是应对 <em>kotlin</em> 项目的配置（该配置文件是一个骨架，后面需要进行修改）</p></li><li><p>备份并修改 <em>AndroidManifest.xml</em> 配置文件，注册 <em>InstrumentedActiviy</em> 和 <em>JacocoInstrumentation</em> </p></li><li><p>向源码中加入三个文件：<em>FinishListener</em>、<em>InstrumentedActiviy</em> 和J <em>acocoInstrumentation</em></p></li></ol><p>（上述 <em>app</em> 目录为源码所在目录，一般为 <em>app</em>，也有可能为其它名称，该脚本若未检测到 <em>app</em> 目录，则会提示输入该目录的名称，需要用户自行判别目录并输入，有时源码所在目录就是项目目录，则输入一个点<code>.</code>表示项目目录即可；<em>AndroidManifest.xml</em> 文件默认路径为 <em>app/src/main</em> 下，若检测不到，会要求用户输入其完整路径；源码 <em>java</em> 目录默认为 <em>app/src/main/java</em>，若检测不到，会要求用户输入其完整路径）</p><ul><li><h6 id="修改-build-和-jacoco-配置："><a href="#修改-build-和-jacoco-配置：" class="headerlink" title="修改 build 和 jacoco 配置："></a>修改 build 和 jacoco 配置：</h6></li></ul><ol><li>检查源码语言是纯 <em>java</em> 还是使用了 <em>kotlin</em>，若使用了 <em>kotlin</em>，检查是否在 <em>app/build.gradle</em> 中 <em>apply</em> 了带 <em>“-kt”</em> 的 <em>jacoco</em> 配置，若没有，则需进行替换</li><li>查看 <em>build/intermediates</em> 下的 <em>javac</em> 或 <em>classes</em> 目录，若没有 <em>javac</em> 目录而有 <em>classes</em> 目录，则将 <em>jacoco</em>配置中的 <em>javac</em> 全部替换成 <em>classes</em></li><li>（假定上一步是 <em>javac</em> 目录）在 <em>javac</em> 目录下查看 <em>app</em> 构建类型，一般是 <em>xxxDebug</em>，选一个作为测试类型，以后只用该类型的 <em>apk</em>（在 <em>build/outputs/apk</em> 目录下有对应的 <em>apk</em> 文件），修改 <em>jacoco</em> 配置中的 <em>variantName</em> 变量为测试类型的名称</li></ol><h5 id="构建插桩后的应用："><a href="#构建插桩后的应用：" class="headerlink" title="构建插桩后的应用："></a>构建插桩后的应用：</h5><ul><li><p>使用相同的命令构建：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --no-daemon --stacktrace assembleDebug</span><br></pre></td></tr></table></figure></li></ul><p>这一步若出现报错，可能有以下几种情况：</p><ul><li><p><em>java</em> 版本不对（仔细查看报错信息，调整 <em>jdk</em> 版本）</p></li><li><p><em>jacoco</em> 配置出错，无法设置 <em>outputLocation</em> 属性。这种情况是由于 <em>gradle</em> 版本较低导致的，将<em>jacoco</em> 配置中的 <em>outputLocation</em> 全部替换成 <em>destination</em>，然后将以下三行改掉：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// classDirectories.from = files(...)</span></span><br><span class="line"><span class="comment">// sourceDirectories.from = files(...)</span></span><br><span class="line"><span class="comment">// executionData.from = ecFile</span></span><br><span class="line">classDirectories = files(...)</span><br><span class="line">sourceDirectories = files(...)</span><br><span class="line">executionData = files(ecFile)  <span class="comment">// 注意这里要套一个files</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="安装并运行插桩后的应用："><a href="#安装并运行插桩后的应用：" class="headerlink" title="安装并运行插桩后的应用："></a>安装并运行插桩后的应用：</h5><ul><li><p>检查本机是否已经连上用于测试的安卓设备（真机或虚拟机）：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure></li><li><p>项目目录下，在用于测试的设备上安装插桩后的应用：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb [-s &#123;设备名称&#125;] install ./app/build/outputs/xxxDebug.apk</span><br></pre></td></tr></table></figure></li><li><p>通过源码查看应用的{包名}，并在测试设备上运行安装的应用：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb [-s &#123;设备名称&#125;] shell am instrument &#123;包名&#125;/.test.JacocoInstrumentation</span><br></pre></td></tr></table></figure></li></ul><p>此时手机会打开插桩后的应用，随便交互几步后，关闭该应用并在后台进程中<strong>杀死</strong>该应用（若不杀死则会不断生成新的覆盖率数据）</p><ul><li>若插桩后的应用存在打开时闪退的问题，可能是由应用的主题导致的：<ul><li>尝试修改 <em>app/src/main/AndroidManifest.xml</em> 中 <em>application</em> 的 <em>android:theme</em> 属性，将原来的例如 <em>AnyMemo.Theme.Dark</em> 修改为 <em>AnyMemo.Theme.Dark</em><em>.NoActionBar</em>**，再重新构建和安装</li><li>插桩后出现闪退问题的一般定位方法如下：<ol><li>打开一个命令行，使用<code>adb logcat *:D</code>命令跟踪日志</li><li>到另一个命令行中启动 <em>instrumentation</em></li><li>切换到第一步的命令行，<em>ctrl+c</em> 停止打印，自底向上查找相关的报错信息</li></ol></li></ul></li></ul><h5 id="导出覆盖率数据并生成报告："><a href="#导出覆盖率数据并生成报告：" class="headerlink" title="导出覆盖率数据并生成报告："></a>导出覆盖率数据并生成报告：</h5><ul><li><p>覆盖率数据文件被保存在 <em>/data/data/&lt;包名&gt;/files</em> 目录下，通过如下命令导出这些文件：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次导出需要创建中间目录</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">mkdir</span> /sdcard/coverage</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面run-as后为应用包名</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">run-as org.liberty.android.fantastischmemo</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">mv</span> files/*.ec /sdcard/coverage</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目标路径为空则默认为当前目录</span></span><br><span class="line">adb pull /sdcard/coverage [目标路径]</span><br></pre></td></tr></table></figure></li><li><p>下面将 <em>coverage</em> 目录下所有 <em>.ec</em> 文件移动到该应用的项目目录下的 <em>app/build/jacoco</em> 目录下（没有则创建），在项目目录下使用如下命令生成报告（报告生成在 <em>app/build/reports</em> 目录下）：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --no-daemon --stacktrace multiJacocoTestReport</span><br></pre></td></tr></table></figure></li></ul><h4 id="安卓测试实验流程"><a href="#安卓测试实验流程" class="headerlink" title="安卓测试实验流程"></a>安卓测试实验流程</h4><ul><li>在安卓设备上安装插桩后的应用</li><li>在前端项目目录下的 <em>configs/android</em>/ 目录下添加被测应用对应的配置信息（xxx.json）</li><li>在服务器上启动后端（执行命令：<em>sh run.sh</em>）</li><li>在本地启动前端（执行命令：<em>python urt_android xxx.json</em>）</li><li>测试设备开始运行被测应用，<em>UniRLTest</em> 测试进行中 …</li><li>测试结束，覆盖率数据生成在前端项目目录下的 <em>coverages</em>/xxx/ 目录下</li><li>手动生成测试报告（具体步骤已在安卓应用插桩测试中讲过）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> NJU-iSE </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> 自动化测试 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学《软件分析》课程笔记</title>
      <link href="/2022/07/14/NJU-Static-Analysis/"/>
      <url>/2022/07/14/NJU-Static-Analysis/</url>
      
        <content type="html"><![CDATA[<p>课程内容来源：<a href="https://tai-e.pascal-lab.net/">https://tai-e.pascal-lab.net/</a></p><p>实验作业的实现：<a href="https://github.com/Ling-Yuchen/Tai-e-assignments/">https://github.com/Ling-Yuchen/Tai-e-assignments/</a></p><p>部分实验作业思路参考：<a href="https://vgalaxy.gitee.io/2022/05/05/static-analysis/">https://vgalaxy.gitee.io/2022/05/05/static-analysis/</a></p><h2 id="01-Introduction"><a href="#01-Introduction" class="headerlink" title="01 - Introduction"></a>01 - Introduction</h2><h3 id="1-静态分析：运行前对程序进行分析"><a href="#1-静态分析：运行前对程序进行分析" class="headerlink" title="1. 静态分析：运行前对程序进行分析"></a>1. 静态分析：运行前对程序进行分析</h3><p>​        是否存在私有信息泄露？</p><p>​        是否存在空指针异常？</p><p>​        是否存在强制类型转换异常？</p><p>​        是否允许存在指向同一内存块的指针？</p><p>​        是否存在 fail 的 <em>assert</em> 语句？</p><p>​        是否存在可以删除的死代码？</p><p>​        ……</p><h3 id="2-莱斯定理（Rice’s-Theorem）"><a href="#2-莱斯定理（Rice’s-Theorem）" class="headerlink" title="2. 莱斯定理（Rice’s Theorem）"></a>2. 莱斯定理（<em>Rice’s Theorem</em>）</h3><p><em>Any non-trivial property of the behavior of programs in a r.e. language is undecidable.</em></p><p>通俗来讲就是，以平时常用的编程语言写的程序，对于其有用的动态运行时性质，无法做出准确判断</p><p>——不存在完美的（<em>sound &amp; complete</em>）静态分析</p><p>对 soundness 妥协：产生漏报（<em>false negatives</em>）（可以接受）</p><p>对 completeness 妥协：产生误报（<em>false positive</em>s）（不希望发生）</p><p>静态分析：在确保 <em>soundness</em> 的前提下，在分析的准确度和速度之间做出有效的平衡</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207132057151.png" alt="img" style="zoom:50%;" /><h3 id="3-静态分析技术：抽象-近似"><a href="#3-静态分析技术：抽象-近似" class="headerlink" title="3. 静态分析技术：抽象+近似"></a>3. 静态分析技术：抽象+近似</h3><p>抽象（<em>abstraction</em>）：把具体域的值映射到抽象域的值</p><p>近似（Over-approximation）：在抽象层面定义转移函数；由于无法枚举所有路径，所以使用  <em>flow merging</em> 处理  <em>control flow</em></p><h3 id="本节重点"><a href="#本节重点" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>静态分析与（动态）测试的区别？</li><li>理解 soundness, completeness, false negatives 和 false positives 的概念</li><li>为什么静态分析需要保证 soundness？</li><li>怎样理解 abstraction 和 over-approximation？</li></ul><h2 id="02-Intermediate-Representation"><a href="#02-Intermediate-Representation" class="headerlink" title="02 - Intermediate Representation"></a>02 - Intermediate Representation</h2><h3 id="1-编译器（Compiler）与静态分析（Static-Analysis）"><a href="#1-编译器（Compiler）与静态分析（Static-Analysis）" class="headerlink" title="1. 编译器（Compiler）与静态分析（Static Analysis）"></a>1. 编译器（<em>Compiler</em>）与静态分析（<em>Static Analysis</em>）</h3><p>编译器：源码 =&gt;（词法分析器 Scanner）=&gt; Tokens =&gt;（语法分析器 Parser）=&gt; AST =&gt;（类型检查 Type Checker）=&gt; Decorated AST =&gt;（Translator）=&gt; IR =&gt;（Code Generator）=&gt; 机器码</p><p>静态分析需要在编译器前端生成的 IR 的基础上进行，e.g. 代码优化</p><h3 id="2-抽象语法树（AST）-vs-中间表示（IR）"><a href="#2-抽象语法树（AST）-vs-中间表示（IR）" class="headerlink" title="2. 抽象语法树（AST） vs. 中间表示（IR）"></a>2. 抽象语法树（<em>AST</em>） vs. 中间表示（<em>IR</em>）</h3><p>抽象语法树：贴近语法结构；依赖于不同语言；适合做快速的类型检查；缺少控制流信息</p><p>中间表示：贴近机器码；具有语言无关性；简洁而统一；包含控制流信息；通常作为静态分析的基础</p><h3 id="3-中间表示（三地址码）"><a href="#3-中间表示（三地址码）" class="headerlink" title="3. 中间表示（三地址码）"></a>3. 中间表示（三地址码）</h3><p>右侧最多只有一个操作符；每种指令都有对应的三地址码</p><ul><li>x = y <em>bop</em> z</li><li>x = <em>uop</em> y</li><li>x = y</li><li>goto L</li><li>if x goto L</li><li>if x <em>rop</em> y goto L</li></ul><h3 id="4-真实的静态分析器中的三地址码：Soot’s-IP"><a href="#4-真实的静态分析器中的三地址码：Soot’s-IP" class="headerlink" title="4. 真实的静态分析器中的三地址码：Soot’s IP"></a>4. 真实的静态分析器中的三地址码：Soot’s IP</h3><p>关于 JVM 的补充：</p><p>invoke-special:    call constructor，call superclass methods，call private methods</p><p>invoke-virtual:    call instance methods（virtual dispatch）</p><p>invoke-interface:    cannot optimize，checking interface implementation</p><p>invoke-static:    call static methods</p><p>method signature:    class name，return type，method name，parameter type</p><h3 id="5-控制流分析"><a href="#5-控制流分析" class="headerlink" title="5. 控制流分析"></a>5. 控制流分析</h3><p>输入三地址码，输出控制流图</p><p>Basic Block 定义：有且仅有一个入口和一个出口的指令块</p><p>确定 Basic Block 的算法：</p><ul><li>第一条指令是基本块的入口</li><li>所有跳转的目标指令是基本块的入口</li><li>所有跳转指令的下一条指令是基本块的入口</li><li>从一个入口指令到下一条入口指令的前一条指令构成一个基本块</li></ul><p>控制流图：</p><p>节点为基本块（<em>basic blocks</em>）</p><p>一条从基本块A到基本块B的边表示，存在从A尾部到B首部的有条件或无条件跳转，或者顺序上B紧跟着A且A的最后一条指令不是无条件跳转</p><p>加上 Entry 和 Exit 表示程序的入口和出口（类似哨兵节点）</p><h3 id="本节重点-1"><a href="#本节重点-1" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>编译器和静态分析器之间的关系？</li><li>理解三地址码及其通常的形式（in IR Jimple）</li><li>怎样在 IR 的基础上构建 basic blocks？</li><li>怎样在 basic blocks 的基础上构建控制流图？</li></ul><h2 id="03-Data-Flow-Analysis（Application）"><a href="#03-Data-Flow-Analysis（Application）" class="headerlink" title="03 - Data Flow Analysis（Application）"></a>03 - Data Flow Analysis（Application）</h2><h3 id="1-数据流分析概览"><a href="#1-数据流分析概览" class="headerlink" title="1. 数据流分析概览"></a>1. 数据流分析概览</h3><p>How <em>application-specific Data</em>（abstraction） <em>Flows</em>（safe-approximation） through the <em>Nodes</em> （Transfer function）and <em>Edges</em>（Control-flow handling） of CFG？</p><p>may analysis：输出信息可能是正确的（over-approximation）</p><p>must analysis：输出信息必须是正确的（under-approximation）</p><h3 id="2-数据流分析前驱知识"><a href="#2-数据流分析前驱知识" class="headerlink" title="2. 数据流分析前驱知识"></a>2. 数据流分析前驱知识</h3><p>Input and Output States</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141511690.png" alt="img" style="zoom:50%;" /><p>在数据流分析应用中，将每一个 <em>program point</em> 与一个 表示该点所有观测到的 <em>program states</em> 的集合的抽象的<em>数据流值（data-flow value）</em> 联系起来</p><p>数据流分析是对所有的语句，通过解析 safe-approximation 的约束规则，得到一个 solution（给每个 <em>program point</em> 一个 <em>data-flow value</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141528212.png" alt="img" style="zoom: 50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141533764.png" alt="img" style="zoom: 50%;" /><h3 id="3-定义可达性分析（Reaching-Definition-Analysis）"><a href="#3-定义可达性分析（Reaching-Definition-Analysis）" class="headerlink" title="3. 定义可达性分析（Reaching Definition Analysis）"></a>3. 定义可达性分析（<em>Reaching Definition Analysis</em>）</h3><p>定义可达性：A definition <em>d</em> at program point <em>p</em> reaches a point <em>q</em> if there is a path from <em>p</em> to <em>q</em> such that <em>d</em> is not killed along the path.</p><p>定义可达性可以用于 <em>侦测可能的未定义的变量</em></p><p><strong>理解定义可达性分析：</strong></p><p>用一个比特表示某个变量在某一点的定义可达性</p><p>用一个 n 维比特向量表示 n 个变量在某一点的定义可达性</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141559532.png" alt="1" style="zoom:50%;" /><p><strong>定义可达性分析算法：</strong></p><p>注意：</p><p>在算法模板中边界条件（OUT[entry]）单独初始化</p><p>对于 OUT[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141602719.png" alt="img" style="zoom:50%;" /><p>为什么该迭代算法最终会停下来？</p><p>对于 Transfer Function，OUT[S] 只受 IN[S] 的影响，当个更多的 facts 流入 IN[S] 时，要么被 kill 要么存活下来并永远被保留，故 OUT[S] 永远不会缩减（e.g. 0 =&gt; 1 或 1 =&gt; 1），又因为定义的变量数量是有限的，故该迭代一定会停下来（实际上到达了一个不动点）</p><h3 id="4-活跃变量分析（Live-Variable-Analysis）"><a href="#4-活跃变量分析（Live-Variable-Analysis）" class="headerlink" title="4. 活跃变量分析（Live Variable Analysis）"></a>4. 活跃变量分析（<em>Live Variable Analysis</em>）</h3><p>Live variable analysis tells whether the value of <em>variable v</em> at <em>program point p</em> could be used along some path in CFG starting at <em>p</em>（AND <em>v</em> should not be redefined before usage）. If so, <em>v</em> is live at <em>p</em>. Otherwise, <em>v</em> is dead at <em>p</em>.</p><p>活跃变量信息可用于寄存器分配（倾向于使用存有 dead value 的寄存器来存新数据）</p><p><strong>理解活跃变量分析：</strong></p><p>用一个比特表示某个变量在某一点是否活跃</p><p>用一个 n 维比特向量表示 n 个变量在某一点是否活跃</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141823269.png" alt="1" style="zoom:50%;" /><p>注意 use 的定义为：在重定义之前被使用</p><p><strong>活跃变量分析算法：</strong></p><p>注意：</p><p>在算法模板中边界条件（IN[entry]）单独初始化</p><p>对于 IN[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141826606.png" alt="img" style="zoom:50%;" /><h3 id="5-可用表达式分析（Available-Expressions-Analysis）"><a href="#5-可用表达式分析（Available-Expressions-Analysis）" class="headerlink" title="5. 可用表达式分析（Available Expressions Analysis）"></a>5. 可用表达式分析（<em>Available Expressions Analysis</em>）</h3><p>一个表达式，形如 <em>x op y</em>，在某个 <em>program point p</em> 是可用的，需要满足：</p><ul><li>从 <em>ENTRY</em> 到 <em>p</em> 的所有路径都必须计算过 <em>x op y</em> 的值</li><li>在这些路径各自最后一次计算该表达式的值之后没有修改过 <em>x</em> 或 <em>y</em> 的值</li></ul><p><strong>理解可用表达式分析：</strong></p><p>用一个比特表示某个表达式在某点是否可用</p><p>用一个 n 维比特向量表示 n 个表达式在某点是否可用</p><p>注意这是一个 must analysis</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171149946.png" alt="1" style="zoom:50%;" /><p><strong>可用表达式分析算法：</strong></p><p>注意在 must analysis 中的初始化方式</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171151583.png" alt="img" style="zoom:50%;" /><h3 id="6-不同数据流分析应用的对比"><a href="#6-不同数据流分析应用的对比" class="headerlink" title="6. 不同数据流分析应用的对比"></a>6. 不同数据流分析应用的对比</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171210734.png" alt="1" style="zoom:50%;" /><h3 id="本节重点-2"><a href="#本节重点-2" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>理解三种数据流分析</li><li>能说出三种数据流分析的相似与不同</li><li>理解迭代算法为什么最终能停下来</li></ul><h2 id="04-Data-Flow-Analysis（Foundations）"><a href="#04-Data-Flow-Analysis（Foundations）" class="headerlink" title="04 - Data Flow Analysis（Foundations）"></a>04 - Data Flow Analysis（Foundations）</h2><h3 id="1-从另一个角度来看迭代算法"><a href="#1-从另一个角度来看迭代算法" class="headerlink" title="1. 从另一个角度来看迭代算法"></a>1. 从另一个角度来看迭代算法</h3><p>假设给定的 CFG 有 <em>k</em> 个节点，迭代算法每次迭代更新每个节点的 OUT[n]</p><p>定义 <em>k-tuple</em> (OUT[n1], … , OUT[nk])，则该元组为集合 V^k 的一个元素（V 是数据流分析的值的域）</p><p>那么每次迭代可以视作作用了转移函数和流控制处理的一次映射，即：F:  V^k —&gt; V^k</p><p>整个算法就是在不断地输出这样的 <em>k-tuple</em> 直到出现连续两个相同的为止</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171602188.png" alt="img" style="zoom:50%;" /><p>迭代算法会在 X = F(X) 处停下来，即数学定义上的一个不动点（<em>fixed point</em>）</p><p>思考：</p><ul><li>算法能保证到达不动点吗？</li><li>如果能，那么只有一个不动点吗？若超过一个不动点，那么我们能到达最优解的不动点吗？</li><li>算法要多久才能到达不动点？（时间复杂度）</li></ul><h3 id="2-偏序"><a href="#2-偏序" class="headerlink" title="2. 偏序"></a>2. 偏序</h3><p>偏序关系（<em>Partial Order</em>）满足自反性、反对称性、传递性</p><p>一个偏序集（<em>poset</em>）中的任意两个元素之间不一定满足偏序关系</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171807638.png" alt="img" style="zoom:50%;" /><h3 id="3-上界和下界"><a href="#3-上界和下界" class="headerlink" title="3. 上界和下界"></a>3. 上界和下界</h3><p>上界（<em>upper bound</em>）和下界（<em>lower bound</em>）</p><p>最小上界（<em>least upper bound</em>）和最大下界（<em>greatest lower bound</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171809088.png" alt="img" style="zoom:50%;" /><p>最小上界（<em>least upper bound</em>）和最大下界（<em>greatest lower bound</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171809056.png" alt="img" style="zoom:50%;" /><p>不是每个偏序集都有最小上界（最大下界）；若偏序集存在最小上界（最大下界），则是唯一的</p><h3 id="4-格、半格、全格、格的积"><a href="#4-格、半格、全格、格的积" class="headerlink" title="4. 格、半格、全格、格的积"></a>4. 格、半格、全格、格的积</h3><p>格（<em>Lattice</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181246948.png" alt="img" style="zoom:50%;" /><p>半格（<em>Semilattice</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181251145.png" alt="1" style="zoom:50%;" /><p>全格（<em>Complete Lattice</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181253998.png" alt="img" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181257563.png" alt="1" style="zoom:50%;" /><p>有穷格一定是全格，全格不一定是有穷格</p><p>格的积（<em>Product Lattice</em>）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181811085.png" alt="img" style="zoom:50%;" /><h3 id="5-通过格来表达数据流分析框架"><a href="#5-通过格来表达数据流分析框架" class="headerlink" title="5. 通过格来表达数据流分析框架"></a>5. 通过格来表达数据流分析框架</h3><p>数据流分析框架（D, L, F）：</p><ul><li>D：数据流的方向（<em>forward</em> 或 <em>backward</em>）</li><li>L：一个包含分析域（<em>domain</em>）以及 <em>join</em> 和 <em>meet</em> 操作的格</li><li>F：一组定义在在域（<em>domain</em>）上的转移函数（<em>transfer function</em>）</li></ul><p>数据流分析可以视作：对格的值迭代地作用转移函数（<em>transfer function</em>）和 <em>join</em> 或 <em>meet</em> 操作</p><h3 id="6-单调性与不动点定理"><a href="#6-单调性与不动点定理" class="headerlink" title="6. 单调性与不动点定理"></a>6. 单调性与不动点定理</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181843635.png" alt="img" style="zoom:50%;" /><p><strong>证明：不动点存在且是最小（大）的</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181851338.png" alt="img" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181855231.png" alt="img" style="zoom:50%;" /><h3 id="7-将迭代算法和不动点定理关联在一起"><a href="#7-将迭代算法和不动点定理关联在一起" class="headerlink" title="7. 将迭代算法和不动点定理关联在一起"></a>7. 将迭代算法和不动点定理关联在一起</h3><p>将迭代算法和不动点定理做出以下关联</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207182103098.png" alt="2" style="zoom:50%;" /><p>故只要证明 <em>function F</em> 是单调的</p><p>之前已经说明 <em>transfer function</em> 是单调的，故只要证明 <em>join/meet function</em> 是单调的</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207182111913.png" alt="img" style="zoom:50%;" /><p>到这里为止，我们可以用格的数学概念和不动点定理严格证明：</p><p>数据流分析的迭代算法一定能停下来（到达不动点），并且一定是最大（最小）不动点</p><h3 id="8-格的视角下的-May-Must-Analysis"><a href="#8-格的视角下的-May-Must-Analysis" class="headerlink" title="8. 格的视角下的 May / Must Analysis"></a>8. 格的视角下的 May / Must Analysis</h3><p>无论是 May Analysis 还是 Must Analysis，都是从 unsafe 的情况向 safe but useless 的情况迭代</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207182148271.png" alt="3" style="zoom:50%;" /><h3 id="9-MOP"><a href="#9-MOP" class="headerlink" title="9. MOP"></a>9. MOP</h3><p>Meet-Over-All-Paths Solution（MOP）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242025411.png" alt="img" style="zoom:50%;" /><p>迭代算法与 MOP 的比较：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242036375.png" alt="img" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242037852.png" alt="1" style="zoom:50%;" /><p>迭代算法得到的结果没有 MOP 准确，但当 <em>Transfer Function</em> 满足分配律的时候，迭代算法可以做到和 MOP 一样准确（可以用集合的交并进行操作的 <em>Transfer Function</em> 都是满足分配律的）</p><h3 id="10-常量传播分析（Constant-Propagation-Analysis）"><a href="#10-常量传播分析（Constant-Propagation-Analysis）" class="headerlink" title="10. 常量传播分析（Constant Propagation Analysis）"></a>10. 常量传播分析（<em>Constant Propagation Analysis</em>）</h3><p>常量传播（<em>Constant Propagation</em>）：对于给定的变量 <em>x</em>，在某一个 <em>program point p</em>，确定该变量是否确保持有一个常量值（<em>must analysis</em> ）</p><p>与之前的数据流分析不同，常量传播 CFG 中每个节点的 IN 和 OUT 都是键值对 <em>(x, v)</em> 的集合（<em>x</em> 表示变量名， <em>v</em> 表示变量持有的值）</p><p>根据数据流分析框架 (D, L, F) 来对常量传播分析进行定义：</p><ul><li>常量传播分析的数据流是正向的（<em>forward</em>）</li><li>常量传播分析的格模型</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242130437.png" alt="img" style="zoom: 50%;" /><ul><li>常量传播分析的转移函数</li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242113532.png" alt="1" style="zoom:50%;" /><p>常量传播分析的 <em>Transfer Function</em> 不满足分配律</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242139017.png" alt="img" style="zoom:50%;" /><h3 id="11-工作列表算法"><a href="#11-工作列表算法" class="headerlink" title="11. 工作列表算法"></a>11. 工作列表算法</h3><p>工作列表算法（<em>Worklist Algorithm</em>）是迭代算法的一种优化，在实际场景中更常用</p><p>迭代算法的主体操作流程清晰直观但有很多冗余步骤，工作列表算法可以做到每次仅对有变化的部分施加转移函数</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242145947.png" alt="img" style="zoom:50%;" /><h3 id="本节重点-3"><a href="#本节重点-3" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>从函数的角度理解迭代算法</li><li>理解格的概念</li><li>理解不动点定理</li><li>用格来概括 <em>may/must analysis</em></li><li>理解 MOP 和迭代算法之间的联系</li><li>常量传播分析</li><li>工作列表算法</li></ul><h2 id="05-Interprocedural-Analysis"><a href="#05-Interprocedural-Analysis" class="headerlink" title="05 - Interprocedural Analysis"></a>05 - Interprocedural Analysis</h2><h3 id="1-为什么需要过程间分析"><a href="#1-为什么需要过程间分析" class="headerlink" title="1. 为什么需要过程间分析"></a>1. 为什么需要过程间分析</h3><p>仅对单个方法进行静态分析，若出现了对别的方法的调用，为了确保分析的正确性，只能认为该调用可以做任何事情，从而使得分析结果不够准确。例如，在常量传播分析中，分析 <em>x = fun()</em> 会认为 <em>x</em> 是 NAC，但方法 <em>fun()</em> 可能返回的是一个常数，即 <em>int fun() { return 0; }</em></p><h3 id="2-调用图的构造"><a href="#2-调用图的构造" class="headerlink" title="2. 调用图的构造"></a>2. 调用图的构造</h3><p>调用图：程序中调用关系的表示方式</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271046525.png" alt="1" style="zoom:50%;" /><p>调用图的应用：过程间分析的基础，程序的优化、理解、debug、测试 ……</p><p>OO 语言的调用图的构造（以 JAVA 为代表）：</p><ul><li>类层次分析（<em>CHA，Class Hierarchy Analysis</em>）：效率高</li><li>指针分析（<em>k-CFA，Pointer Analysis</em>）：精确度高</li></ul><p>JAVA 中的方法调用共有五种，其中 <em>invokedynamic</em> 在此不做考虑，由于 <em>Virtual Call</em> 的目标方法是运行时动态确定的（多态），故构造调用图的难点和关键在于如何处理 <em>Virtual Call</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271059481.png" alt="1" style="zoom:50%;" /><p><em>Virtual Call</em> 的方法分派依据 <em>receiver object</em> 的类型 <em>c</em> 和方法的签名 <em>m</em> （形如 *&lt;ClassType：ReturnType MehtodName（ParameterTypes）&gt;*），定义函数 <em>Dispatch(c, m)</em> 去模拟运行时方法分派，总的思路是优先在子类中匹配，匹配不到则递归地到父类中匹配</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271118454.png" alt="1" style="zoom:50%;" /><p><strong>类层次分析（<em>Class Hierarchy Analysis</em>）</strong></p><p>适用于 IDE 等场景，快速分析并对准确性没有较高的要求</p><p>定义函数 <em>Resolve(cs)</em> 解析方法调用的可能的目标方法，分别处理 <em>static call</em>，<em>special call</em> 和 <em>virtual call</em></p><p>注意 <em>special call</em> 中调用父类方法的时候需要递归寻找，为了形式统一使用用 <em>Dispatch</em> 函数</p><p>注意 <em>virtual call</em> 需要对对象的声明类型及其所有子类做 <em>Dispatch</em>（可能产生假的目标方法，不够准确）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271158826.png" alt="1" style="zoom:50%;" /><p>下面是 CHA 的一个例子，注意理解 <em>Resolve( b.foo() )</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271210904.png" alt="1" style="zoom:50%;" /><p>通过 CHA 来构造调用图：从入口方法（<em>main</em>）开始，对每一个可达的方法 <em>m</em> 中的每一个调用点 <em>cs</em>，解析目标方法（*Resolve(cs)*），重复该过程知道没有新的方法被发现。具体算法如下：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271234192.png" alt="img" style="zoom:50%;" /><h3 id="3-过程间控制流图"><a href="#3-过程间控制流图" class="headerlink" title="3. 过程间控制流图"></a>3. 过程间控制流图</h3><p>回顾：控制流图（<em>CFG</em>）可以表示一个独立的方法的结构</p><p>过程间控制流图（<em>ICFG，Interprocedural Control-Flow Graph</em>）可以表示整个程序的结构，包含程序中每个方法自己的控制流图以及两类额外的边：从调用点指向被调用方法的 <em>Call edges</em> 和从被调用方法的返回语句指向返回点（即调用点的下一条语句）的 <em>Return edges</em>，额外的边的信息从构造的调用图中可以获取。概述如下图：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271459841.png" alt="img" style="zoom:50%;" /><h3 id="4-过程间数据流分析"><a href="#4-过程间数据流分析" class="headerlink" title="4. 过程间数据流分析"></a>4. 过程间数据流分析</h3><p>基于 ICFG 进行程序分析，其 <em>Transfer Function</em> 不仅需要正常的 <em>Node Transfer</em> 还要处理 <em>Call Edge Transfer</em>（用于传参） 和 <em>Return Edge Transfer</em>（用于传递返回值）</p><p><strong>过程间常量传播分析（<em>Interprocedural Constant Propagation</em>）</strong></p><p>在 ICFG 中保留了调用点到返回点之间相连的边（<em>call-to-return edge</em>），能使得 ICFG 能够传递本地数据流（单个 CFG 内产生的数据流）</p><p>在本地方法的 CFG 中的 <em>Node Transfer</em> 需要把调用点的左值变量 <em>kill</em> 掉（<em>Return Edge Transfer</em> 会覆盖这些变量的值）</p><p>下面是一个详细示例：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271523413.png" alt="1" style="zoom:50%;" /><h3 id="本节重点-4"><a href="#本节重点-4" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>如何通过 CHA 构建调用图</li><li>过程间控制流图的概念</li><li>过程间数据流分析的概念</li><li>过程间常量传播分析</li></ul><h2 id="06-Pointer-Analysis"><a href="#06-Pointer-Analysis" class="headerlink" title="06 - Pointer Analysis"></a>06 - Pointer Analysis</h2><h3 id="1-为什么需要指针分析"><a href="#1-为什么需要指针分析" class="headerlink" title="1. 为什么需要指针分析"></a>1. 为什么需要指针分析</h3><p>基于指向关系进行分析，能有效避免 CHA 中出现 <em>fake target</em> 的问题</p><p>例如：针对语句 { A a = new A(); a.fun(); }，CHA 在解析 <em>a.fun()</em> 时会得到所有 A 类型及其子类的签名为 <em>fun()</em> 的方法，而使用指针分析则可以找到唯一的一个目标方法，提高分析的准确性</p><h3 id="2-指针分析的介绍"><a href="#2-指针分析的介绍" class="headerlink" title="2. 指针分析的介绍"></a>2. 指针分析的介绍</h3><p>指针分析是基础的静态分析，计算一个指针能够指向内存中的哪些地址</p><p>对于面向对象语言，以 JAVA 为例，指针分析计算一个指针（<em>variable or field</em>）能够指向哪些对象</p><p>指针分析可以看作一种 <em>may analysis</em>，计算结果是一个 <em>over-approximation</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281010951.png" alt="img" style="zoom:50%;" /><p>概念辨析：指针分析 vs. 别名分析</p><p>指针分析回答的问题：Which objects a pointer can point to ?</p><p>别名分析回答的问题：Can two pointers point to the same object ?</p><p>别名分析的结果可由指针分析的结果推到而来</p><h3 id="3-影响指针分析的关键要素"><a href="#3-影响指针分析的关键要素" class="headerlink" title="3. 影响指针分析的关键要素"></a>3. 影响指针分析的关键要素</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271601082.png" alt="img" style="zoom:50%;" /><p><strong>堆抽象（<em>Heap Abstraction</em>）</strong></p><p>为了保证静态分析能够终止，对堆内存进行建模，把 <em>动态分配的无限的具体对象</em>  构建成 <em>有限的抽象的对象</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271611034.png" alt="1" style="zoom:50%;" /><p>调用点抽象技术（<em>Allocation-Site Abstraction</em>）</p><p>将实例对象抽象成创建点，每个创建点建立一个抽象对象，用来表示该创建点分配的具体对象（在循环中的同一个创建点实际运行时会创建多个具体对象，但由于只有一个创建点只会创建一个抽象对象）</p><p><strong>上下文敏感（<em>Context Sensitivity</em>）</strong></p><p>上下文敏感的分析中，对同一个方法的不同调用进行区分，对每一个上下文都分析一次目标方法</p><p>上下文不敏感的分析中，对同一个方法的不同调用做数据流的合并处理，只分析一次，可能丢失精度</p><p><strong>流敏感（<em>Flow Sensitivity</em>）</strong></p><p>流敏感的分析是尊重语句的执行顺序的，程序中每个位置都维护了一个包含指向关系的 map</p><p>流不敏感的分析是忽视控制流的顺序的，整个程序只维护了一个包含指向关系的 map</p><p><strong>分析域（<em>Analysis Scope</em>）</strong></p><p>全程序分析：计算程序中所有指针的信息，服务所有可能的应用</p><p>需求驱动分析：只计算需要用到的指针的信息，服务特定的应用</p><h3 id="4-指针分析需要分析的语句"><a href="#4-指针分析需要分析的语句" class="headerlink" title="4. 指针分析需要分析的语句"></a>4. 指针分析需要分析的语句</h3><p>指针分析只关注 <em>Pointer-Affecting Statements</em></p><p>JAVA 中的指针：</p><ul><li>本地变量（<em>local variable</em>）<em>e.g.</em>  x</li><li>静态字段（<em>static field</em>）<em>e.g.</em>  C.f</li><li>实例字段（<em>instance field</em>）<em>e.g.</em>  x.f</li><li>数组元素（<em>array element</em>）<em>e.g.</em>  array[i]</li></ul><p>在数组元素的指针分析中，忽略数组下标，把整个数组视作一个单独的 <em>field</em></p><p>处理静态字段的方式与处理本地变量相似，处理数组元素的方式与处理实例字段相似</p><p>JAVA 中的 <em>pointer-affecting statements</em>：</p><ul><li>创建 New    <em>x = new T()</em></li><li>赋值 Assign    <em>x = y</em></li><li>存储 Store    <em>x.f = y</em></li><li>加载 Load    <em>y = x.f</em></li><li>调用 Call    <em>r = x.k(a, …)</em></li></ul><h3 id="本节重点-5"><a href="#本节重点-5" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>什么是指针分析</li><li>理解影响指针分析的关键要素</li><li>理解指针分析需要分析哪些内容</li></ul><h2 id="07-Pointer-Analysis（Foundations）"><a href="#07-Pointer-Analysis（Foundations）" class="headerlink" title="07 - Pointer Analysis（Foundations）"></a>07 - Pointer Analysis（Foundations）</h2><blockquote><p>本章节介绍使用调用点抽象技术、上下文不敏感、流不敏感的全程序指针分析</p></blockquote><h3 id="1-指针分析的规则"><a href="#1-指针分析的规则" class="headerlink" title="1. 指针分析的规则"></a>1. 指针分析的规则</h3><p>在 JAVA 的指针分析中，常用流不敏感的方式（效率高，精度损失可接受）</p><p>指针分析的域及其表示：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281054043.png" alt="img" style="zoom:50%;" /><p>不同语句的指针分析规则：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281059426.png" alt="1" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281109304.png" alt="img" style="zoom:50%;" /><h3 id="2-指针分析的实现"><a href="#2-指针分析的实现" class="headerlink" title="2. 指针分析的实现"></a>2. 指针分析的实现</h3><p>指针分析要在指针间传播指向信息，指针分析解决的是指针间的包含约束系统的问题</p><p>实现指针分析的关键在于：当指针集 <em>pt(x)</em> 改变时，要把更新的信息传播给其他与 <em>x</em> 相关的指针</p><p>实现方式：用图去连接相关联的指针，当指针集 <em>pt(x)</em> 改变时，把更新的信息传播给 <em>x</em> 的后继</p><p><strong>指针流图（<em>Pointer Flow Graph，PFG</em>）</strong></p><p>指针流图的节点为 <em>Pointer</em> = *V ∪ (O × F)*，可能是变量或抽象对象的字段</p><p>指针流图的边为 <em>Pointer × Pointer</em>，由 <em>x</em> 指向 <em>y</em> 的边表示 <em>x</em> 指向的对象有可能被 <em>y</em> 指向</p><p>指针流图的边由程序中的语句和处理指针分析的规则来确定：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061225160.png" alt="image-20220806122505050" style="zoom:50%;" /><p>通过指针流图，指针分析问题可以转化为在指针流图上求解传递闭包的问题</p><p>指针分析的复杂性在于构建指针流图和传播指向信息相互依赖（在指针分析的过程中，指针流图也在不断更新迭代，从而再次影响指针分析的过程）：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061238046.png" alt="image-20220806123814992" style="zoom:50%;" /><h3 id="3-指针分析的算法"><a href="#3-指针分析的算法" class="headerlink" title="3. 指针分析的算法"></a>3. 指针分析的算法</h3><p><strong>完整的算法过程：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061242284.png" alt="image-20220806124226182" style="zoom:50%;" /><p>关于算法中 <em>WL</em>，即 <em>Worklist</em> 的解释：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061248121.png" alt="image-20220806124824952" style="zoom:50%;" /><h3 id="4-带有方法调用的指针分析"><a href="#4-带有方法调用的指针分析" class="headerlink" title="4. 带有方法调用的指针分析"></a>4. 带有方法调用的指针分析</h3><p>过程间的指针分析需要构建调用图，使用 <em>CHA</em> 基于声明类型解析目标方法可能产生 <em>fake target</em>，在指针分析中，可以基于变量的指针集进行解析，得到更准确的调用图（<em>on-the fly call graph construnction</em>）</p><p><strong>方法调用的指针分析规则：</strong></p><p>一个方法调用要做的四件事：Dispatch；传 receiver object；传参数；传返回值</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061604497.png" alt="image-20220806160402337" style="zoom:50%;" /><p>思考：为什么不在 <em>PFG</em> 中添加由 <em>x</em> 到 <em>m_this</em> 的边？</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061653145.png" alt="image-20220806165315061" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061653241.png" alt="image-20220806165343145" style="zoom:50%;" /><p>过程间指针分析和调用图的构建相互依赖，同时进行</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061726888.png" alt="image-20220806172637806" style="zoom:50%;" /><p><strong>带有方法调用的指针分析的算法实现：</strong></p><p>（黄底内容为新增部分）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061729060.png" alt="image-20220806172859940" style="zoom:50%;" /><h3 id="本节重点-6"><a href="#本节重点-6" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>理解指针分析的规则</li><li>理解指针流图</li><li>理解指针分析的方法</li><li>理解指针分析处理方法调用的规则</li><li>理解过程间指针分析算法</li><li>理解即时调用图构建</li></ul><h2 id="08-Pointer-Analysis（Context-Sensitivity）"><a href="#08-Pointer-Analysis（Context-Sensitivity）" class="headerlink" title="08 - Pointer Analysis（Context Sensitivity）"></a>08 - Pointer Analysis（Context Sensitivity）</h2><blockquote><p>本章节介绍使用调用点抽象技术、上下文敏感、流不敏感的全程序指针分析</p></blockquote><h3 id="1-上下文敏感指针分析介绍"><a href="#1-上下文敏感指针分析介绍" class="headerlink" title="1. 上下文敏感指针分析介绍"></a>1. 上下文敏感指针分析介绍</h3><p><strong>为什么需要上下文敏感技术：</strong></p><p>在动态执行的时候，一个方法可能被调用多次，而不同调用的上下文不同（传参不同、返回点不同），故在上下文不敏感的指针分析中，不同调用上下文混合的数据流在程序中传播，产生假的数据流，影响程序分析的精度；引入上下文敏感技术，区分不同上下文之间的数据流，可以提升程序分析的精度</p><p><strong>上下文的表示方式：</strong></p><p>使用调用点来作为上下文：用一系列调用点来链式表示每个上下文（栈抽象）</p><p><strong>上下文敏感的实现：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081252673.png" alt="image-20220808125210400" style="zoom:50%;" /><p><strong>上下文敏感的堆抽象：</strong></p><p>在 <em>OO</em> 程序中，经常需要修改堆上对象，因此在实际情况中，上下文敏感技术需要应用于堆抽象</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081300289.png" alt="image-20220808130043102" style="zoom:50%;" /><p>为什么上下文敏感的堆抽象能够提升分析精度：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081302280.png" alt="image-20220808130257124" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081538904.png" alt="image-20220808153838733" style="zoom:50%;" /><h3 id="2-上下文敏感指针分析规则"><a href="#2-上下文敏感指针分析规则" class="headerlink" title="2. 上下文敏感指针分析规则"></a>2. 上下文敏感指针分析规则</h3><p><strong>上下文敏感指针分析的域及其表示：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081542619.png" alt="image-20220808154228430" style="zoom:50%;" /><p><strong>上下文敏感指针分析的规则：</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081554195.png" alt="image-20220808155432112" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081609672.png" alt="image-20220808160955460" style="zoom:50%;" /><h3 id="3-上下文敏感指针分析算法"><a href="#3-上下文敏感指针分析算法" class="headerlink" title="3. 上下文敏感指针分析算法"></a>3. 上下文敏感指针分析算法</h3><p>基本思路和上下文不敏感的指针分析相似，即：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081847583.png" alt="image-20220808184754519" style="zoom:50%;" /><p>其中 <em>PFG with C.S.</em> 是一个有向图，定义如下：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081850174.png" alt="image-20220808185051069" style="zoom:50%;" /><p><em>PFG with C.S.</em> 边的建立：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081854521.png" alt="image-20220808185440449" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081856242.png" alt="image-20220808185605023" style="zoom:50%;" /><p>上下文敏感指针分析完整算法：</p><p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208082003685.png" alt="image-20220808200312549"></p><h3 id="4-上下文敏感技术的变种"><a href="#4-上下文敏感技术的变种" class="headerlink" title="4. 上下文敏感技术的变种"></a>4. 上下文敏感技术的变种</h3><blockquote><p>上下文敏感指针分析算法中 <em>Select</em> 方法的具体实现方式</p></blockquote><p><strong>调用点敏感（<em>Call-site Sensitivity</em>）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208082233180.png" alt="image-20220808223352053" style="zoom:50%;" /><p>为了避免产生过多的上下文，保证指针分析在合理的时间内完成，需要对调用链的长度进行限制（<em>e.g.</em> 递归调用能够产生很长的调用链），故引入 <em>k-Limiting Context Abstraction</em>，即选用最后的 <em>k</em> 个调用点作为上下文：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091134010.png" alt="image-20220809113401843" style="zoom:50%;" /><p><strong>调用对象敏感（<em>Object Sensitivity</em>）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091220974.png" alt="image-20220809122016842" style="zoom:50%;" /><p>在 <em>OO</em> 语言的实际应用中，调用对象敏感效果比调用点敏感速度更快、效果更好</p><p><strong>调用类型敏感（<em>Type Sensitivity</em>）</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091409784.png" alt="image-20220809140913638" style="zoom:50%;" /><p>调用类型敏感是对调用对象敏感的一种粗粒度的抽象，获取了更快的分析速度，牺牲了精度</p><p><strong>三种上下文敏感技术变体的对比</strong></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091415141.png" alt="image-20220809141528031" style="zoom:50%;" /><h3 id="本节重点-7"><a href="#本节重点-7" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>上下文敏感的概念</li><li>上下文敏感的堆抽象的概念</li><li>为什么上下文敏感和上下文敏感的堆抽象能够提升分析的精度</li><li>上下文敏感的指针分析的规则</li><li>上下文敏感指针分析的算法</li><li>常见的上下文敏感技术的变体</li><li>常见的上下文敏感技术的变体的不同与联系</li></ul><h2 id="09-Static-Analysis-For-Security"><a href="#09-Static-Analysis-For-Security" class="headerlink" title="09 - Static Analysis For Security"></a>09 - Static Analysis For Security</h2><h3 id="1-信息流安全"><a href="#1-信息流安全" class="headerlink" title="1. 信息流安全"></a>1. 信息流安全</h3><p>与访问控制不同，信息流表示一种端到端的数据流动</p><p>给程序中的变量赋予不同的密级（<em>Security Level</em>）以构建实现信息流安全的策略</p><p>密级可以用格（<em>Lattice</em>）进行建模，虽然二元密级（<em>Low &amp; High</em>）最为常见和常用，但是也可以存在复杂的密级结构：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101547940.png" alt="image-20220810154757779" style="zoom: 40%;" /><p>非干涉策略（<em>Noninterference Policy</em>）：不允许信息从高密级流向低密级</p><h3 id="2-保密性和完整性"><a href="#2-保密性和完整性" class="headerlink" title="2. 保密性和完整性"></a>2. 保密性和完整性</h3><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101553122.png" alt="image-20220810155305010" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101557442.png" alt="image-20220810155701257" style="zoom:50%;" /><h3 id="3-显式流和隐藏信道"><a href="#3-显式流和隐藏信道" class="headerlink" title="3. 显式流和隐藏信道"></a>3. 显式流和隐藏信道</h3><p>显式流（<em>explicit flow</em>）：通过直接拷贝进行的信息流动</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101837830.png" alt="image-20220810183716782" style="zoom:50%;" /><p>隐式流（<em>implicit flow</em>）：控制流受到高密级信息的影响，如果产生的副作用能被观测到则会信息泄露</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101836377.png" alt="image-20220810183644320" style="zoom:50%;" /><p>隐藏信道（<em>hidden channel</em>）：不是用来传递信息流的内容将信息间接地传递出去，造成信息泄露</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102026254.png" alt="image-20220810202644130" style="zoom:50%;" /><p>就保密性而言，隐藏信道泄露的信息量有限，就完整性而言，隐藏信道不会造成什么危害，故应当优先处理显式流中的信息流安全问题</p><h3 id="4-污点分析"><a href="#4-污点分析" class="headerlink" title="4. 污点分析"></a>4. 污点分析</h3><p>污点分析（<em>Taint Analysis</em>）将程序中的数据分为两类：</p><ul><li><em>Data of interest</em>，将某些标签与其进行绑定，称之为污点数据（<em>tainted data</em>）</li><li><em>Other data</em>，称之为非污点数据（<em>untainted data</em>）</li></ul><p>污点数据的源头称为 <em>source</em>，实际情况中，污点数据通常来源于某些方法（<em>sources</em>）的返回值</p><p>污点分析追踪污点数据，观测其是否会流入某个特定的地方（<em>sink</em>） ，实际情况下通常是某些方法传参</p><p>污点分析的两种应用：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102046001.png" alt="image-20220810204620890" style="zoom:50%;" /><p>污点分析和指针分析本质上具有高度一致性，可以依据指针分析来做污点分析：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102050227.png" alt="image-20220810205031124" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102054790.png" alt="image-20220810205425522" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102058692.png" alt="image-20220810205817421" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102102679.png" alt="image-20220810210253547" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102100445.png" alt="image-20220810210049208" style="zoom:50%;" /><h3 id="本节重点-8"><a href="#本节重点-8" class="headerlink" title="本节重点"></a>本节重点</h3><ul><li>信息流安全的概念</li><li>保密性和完整性的概念</li><li>显式流和隐藏信道的概念</li><li>如何使用污点分析的检测有安全隐患的信息流</li></ul><h2 id="实验作业部分"><a href="#实验作业部分" class="headerlink" title="实验作业部分"></a>实验作业部分</h2><h3 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h3><ul><li>为 Java 实现一个活跃变量分析（Live Variable Analysis）</li><li>实现一个通用的迭代求解器（Iterative Solver），用于求解数据流分析问题，也就是本次作业中的活跃变量分析</li></ul><p><em>LiveVariableAnalysis</em> 类提供了一个活跃变量分析器，提供算法执行过程中所需要的接口（图中红色的方法标注），作为 <em>Solver</em> 类的一个私有变量</p><p><em>Solver</em> 类执行整个算法流程（大致分为初始化和循环体两个模块），分析结果以一个 <em>DataflowResult</em> 类的对象返回</p><p>注意 <em>LiveVariableAnalysis</em> 类只关注逻辑，IN, OUT, EXIT, ENTRY 等信息由 <em>DataflowResult</em> 类通过 <em>inFacts</em> 和 <em>outFacts</em> 两个 Map 管理</p><p>注意作业中为了简化实现难度没有使用 basic blocks，以单条语句为单位处理</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207151730781.png" alt="1" style="zoom: 40%;" /><h3 id="A2"><a href="#A2" class="headerlink" title="A2"></a>A2</h3><ul><li>为 Java 实现常量传播算法</li><li>实现一个通用的 worklist 求解器，并用它来解决一些数据流分析问题，例如本次的常量传播</li></ul><p>与 A1 的任务总体结构相同，理解常量传播和 worklist 的实现方式并读懂提供的框架源码即可</p><p>注意 newBoundryFact() 需要将方法的参数初始化为 NAC（参数不由方法本身决定，故必不是常量）</p><p>注意 transferNode() 的返回值为一个布尔类型，worklist 算法中不需要重复判断 OUT 是否被改变</p><p>注意 CPFact 类的设计，变量不在某个 CPFact 对象中视为 UNDEF</p><p>（有部分隐藏用例没有通过，大概猜测是在 evaluate() 方法中一些除了 Var, IntLiteral 和 BinaryExp 其他一些特殊类型的 expression 没有考虑的缘故，暂且搁置）</p><p>关于 debug：在 IntelliJ IDEA 中进行断点调试的时候，出现 ”<em>Skipped breakpoint at … because it happened inside debugger evaluation</em>“，打条件断点的地方被跳过，是由于测试时使用了多线程，将断点设置中 <em>Suspend</em> 选项的 <em>All</em> 改成 <em>Thread</em> 即可（如图所示）</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207261829825.png" alt="1" style="zoom:50%;" /><h3 id="A3"><a href="#A3" class="headerlink" title="A3"></a>A3</h3><ul><li>为 Java 实现一个死代码（dead code）检测算法</li></ul><p>该死代码检测作业需要找出两种死代码：不可达代码和无用赋值</p><p>不可达代码又分为控制流不可达（e.g. Return 语句之后的代码）和分支不可达（e.g. 条件跳转处的条件为常量）</p><p>本次作业需要用到 A1 中实现的活跃变量分析（寻找无用赋值）和 A2 中实现的常量传播分析（寻找分支不可达的代码），并新补充实现 <em>DeadCodeDetection</em> 类中的 <em>analyse</em> 方法</p><p>在 <em>analyse</em> 方法中，已经构建了程序的控制流图、常量传播分析结果和活跃变量分析结果，需要以此为据找出可以被判定为死代码的语句，以一个集合的形式返回</p><p>一开始的思路是直接寻找死代码语句，但发现由于在数据流不向后继续传递，在确定一条语句为死代码后难以判断其后继语句是否为死代码，故转换思路，通过确定活代码来反推死代码，总体思路为从程序入口处开始，借助常量传播分析结果和活跃变量分析结果，在控制流图上遍历所有可能被执行的活代码并标记，没有被标记到的节点即为死代码</p><h3 id="A4"><a href="#A4" class="headerlink" title="A4"></a>A4</h3><ul><li>为 Java 实现一个类层次结构分析（Class Hierarchy Analysis，CHA）</li><li>实现过程间常量传播</li><li>实现过程间数据流传播的 worklist 求解器</li></ul><p>类层次结构分析部分需要实现 <em>buildCallGraph</em>、<em>resolve</em> 和 <em>dispatch</em> 三个方法，课件中已经给出了相应的算法流程，模拟实现即可</p><ul><li><em>callSite.getMethodRef().getDeclaringClass()</em> 获取调用点的对象的声明类型</li><li><em>callSite.getMethodRef().getSubsignature()</em> 获取调用点方法的子签名（一个方法的子签名只包含它的方法名和方法签名的描述符）</li><li>成员变量 <em>hierarchy</em> 中包含了所有类和接口的继承和实现关系</li></ul><p>过程间的常量传播需要考虑 <em>transferNode</em> 和 <em>transferEdge</em> 两种情况：</p><ul><li><em>transferNode</em> 分为 <em>transferCallNode</em> 和 <em>transfeNonCallNode</em>：由于调用由 <em>transferEdge</em> 处理，<em>transferCallNode</em> 只需要做恒等传播；而 <em>transfeNonCallNode</em> 与 A2 中的非过程间常量传播的 <em>transferNode</em> 相同</li><li><em>transferEdge</em> 分为 <em>transferCallToReturnEdge</em>、<em>transferCallEdge</em> 和 <em>transferReturnEdge</em>：<em>transferCallToReturnEdge</em> 需要将调用点的左值 kill 掉（如果存在的话）；<em>transferCallEdge</em> 需要完成参数的值的传递；<em>transferReturnEdge</em> 需要完成返回值向调用点左值的赋值（如果存在的话）</li></ul><p>（注意 <em>transferEdge</em> 的返回值是一个新的 <em>Fact</em>，不改变已有的 <em>Fact</em>）</p><p>e.g. 下图中蓝色虚线箭头为 <em>callEdge</em>，红色虚线箭头为 <em>returnEdge</em>，黑色虚线箭头为 <em>callToReturnEdge</em></p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207292143391.png" alt="image-20220729214359229" style="zoom: 33%;" /><p>在实现 worklist 求解器时，注意与之前实现的不同之处有：</p><ul><li><p>初始化时，需要对所有的 <em>entry method</em> 的 <em>entry</em> 节点进行 <em>newBoundaryFact</em>（可使用 <em>icfg.entryMethods().toList()</em> 获取所有的 <em>entry method</em>）</p></li><li><p>执行算法流程时，每个节点的 <em>inFact</em> 不再是和所有前驱节点的 <em>outFact</em> 做 <em>meet</em> 操作获得，而是和所有汇入的边所带来的 <em>Fact</em> 做 <em>meet</em> 操作获得</p></li></ul><h3 id="A5"><a href="#A5" class="headerlink" title="A5"></a>A5</h3><ul><li>为 Java 实现非上下文敏感的指针分析</li><li>为指针分析实现一个调用图的实时构建算法</li></ul><p>作业文档足够详细，难度不大，按照算法流程实现即可，注意：</p><ol><li>每个方法可能有多个返回值，也有可能没有返回值</li><li>处理方法调用时需要的 dispatch 方法已经给出（*resolveCallee()*）可直接调用</li><li>新引入的静态字段、静态方法调用和数组在需要算法中进行处理的位置</li><li><em>var.getStoreFields()、var.getLoadArrays()、var.getInvokes()</em> 等接口可直接获取变量相关的语句</li><li><em>AddReachable</em> 方法使用了<a href="https://refactoringguru.cn/design-patterns/visitor">访问者设计模式 </a></li><li>提供的框架将算法中 Δ 的计算融入了 <em>propagate</em> 方法中</li></ol><p>参考算法流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Solve(m_entry):</span><br><span class="line">WL=[], PFG=&#123;&#125;, S=&#123;&#125;, RM=&#123;&#125;, CG=&#123;&#125;</span><br><span class="line">addReachable(m_entry)</span><br><span class="line">while WL is not empty do</span><br><span class="line">remove &lt;n, pts&gt; from WL</span><br><span class="line">Δ = pts - pt(n)</span><br><span class="line">Propagate(n, Δ)</span><br><span class="line">if n represents a variable x then</span><br><span class="line">foreach o ∈ Δ do</span><br><span class="line">foreach x.f = y ∈ S do</span><br><span class="line">AddEdge(y, o.f)</span><br><span class="line">foreach y = x.f ∈ S do</span><br><span class="line">AddEdge(o.f, y)</span><br><span class="line">foreach x[*] = y ∈ S do</span><br><span class="line">AddEdge(y, o[*])</span><br><span class="line">foreach y = x[*] ∈ S do</span><br><span class="line">AddEdge(o[*], y)</span><br><span class="line">ProcessCall(x, o)</span><br><span class="line"></span><br><span class="line">AddReachable(m):</span><br><span class="line">if m ∉ RM then</span><br><span class="line">add m to RM</span><br><span class="line">S ∪= S_m</span><br><span class="line">foreach i: x = new T() ∈ S_m do</span><br><span class="line">add &lt;x, &#123;o_i&#125;&gt; to WL</span><br><span class="line">foreach x = y ∈ S_m do</span><br><span class="line">AddEdge(y, x)</span><br><span class="line">foreach T.f = y ∈ S_m do</span><br><span class="line">AddEdge(y, T.f)</span><br><span class="line">foreach y = T.f ∈ S_m do</span><br><span class="line">AddEdge(T.f, y)</span><br><span class="line">foreach l: x = T.k(a1,...,an) ∈ S_m do</span><br><span class="line">f = Dispatch(_, k)</span><br><span class="line">if l → f ∉ CG then</span><br><span class="line">add l → f to CG</span><br><span class="line">AddReachable(f)</span><br><span class="line">foreach parameter p_i of f do</span><br><span class="line">AddEdge(a_i, p_i)</span><br><span class="line">AddEdge(f_ret, x)</span><br><span class="line"></span><br><span class="line">ProcessCall(x, o):</span><br><span class="line">foreach l: r = x.k(a1,...,an) ∈ S_m do</span><br><span class="line">m = Dispatch(o, k)</span><br><span class="line">add &lt;m_this, &#123;o&#125;&gt; to WL</span><br><span class="line">if l → m ∉ CG then</span><br><span class="line">add l → f to CG</span><br><span class="line">AddReachable(m)</span><br><span class="line">foreach parameter p_i of m do</span><br><span class="line">AddEdge(a_i, p_i)</span><br><span class="line">AddEdge(m_ret, r)</span><br><span class="line"></span><br><span class="line">AddEdge(s, t):</span><br><span class="line">if s → t ∉ PFG then</span><br><span class="line">add s → t to PFG</span><br><span class="line">if pt(s) is not empty then</span><br><span class="line">add &lt;t, pt(s)&gt; to WL</span><br><span class="line"></span><br><span class="line">Propagate(n, pts):</span><br><span class="line">if pts is not empty then</span><br><span class="line">pt(n) ∪= pts</span><br><span class="line">foreach n → s ∈ PFG do</span><br><span class="line">add &lt;s, pts&gt; to WL</span><br></pre></td></tr></table></figure><h3 id="A6"><a href="#A6" class="headerlink" title="A6"></a>A6</h3><ul><li>为 Java 实现一个上下文敏感的指针分析框架</li><li>作为指针分析的一部分，随着指针分析一起实现调用图（call graph）构建</li><li>实现几种常见的上下文敏感策略（context sensitivity variants）</li></ul><p>与 A5 相似，注意上下文的正确对应即可</p><h3 id="A7"><a href="#A7" class="headerlink" title="A7"></a>A7</h3><blockquote><p>开放性作业</p></blockquote><ul><li>为 Java 实现一个 alias-aware 的过程间常量传播分析</li></ul><p>在 A4 的基础上，利用 A6 中实现的指针分析的分析结果，得到更精确的过程间常量传播分析</p><p>A4 在 A3 的基础上，解决了把所有方法调用的返回值全部置为 <em>NAC</em> 的问题</p><p>A7 在 A4 的基础上，解决了把所有 <em>load</em> 语句（e.g. x = y.f）给变量的赋值全部置为 <em>NAC</em> 的问题</p><p>简言之就是，对于 <em>load</em> 语句 <em>x = y.f</em>，找出所有形如 <em>z.f = w</em>（<em>z.f</em> 满足条件是 <em>y.f</em> 的别名）的 <em>store</em> 语句，将所有变量 <em>w</em> 对应的值做 <em>meet</em> 操作并赋值给 <em>x</em></p><p>满足互为别名的条件：</p><ul><li>实例字段（<em>x.f</em> 和 <em>y.g</em>）<ul><li>字段 <em>f</em> 和字段 <em>g</em> 相同</li><li>变量 <em>x</em> 和变量 <em>y</em> 对应的指针集有交集</li></ul></li><li>静态字段（<em>T.f</em> 和 <em>Q.g</em>）<ul><li>字段 <em>f</em> 和字段 <em>g</em> 相同</li><li>类 <em>T</em> 和类 <em>Q</em> 相同</li></ul></li><li>数组元素（<em>a[i]</em> 和 *b[j]*）<ul><li>变量 <em>a</em> 和变量 <em>b</em> 对应的指针集有交集</li><li>变量 <em>i</em> 和变量 <em>j</em> 都不是 <em>UNDEF</em> 并且变量 <em>i</em> 和变量 <em>j</em> 都是常量时其值相等</li></ul></li></ul><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101501773.png" alt="image-20220810150109665" style="zoom:50%;" /><p>修改 <em>transferNonCallNode</em> 方法，对所有 <strong><em>load</em> 语句和 <em>store</em> 语句</strong>进行单独处理：</p><ul><li>对于 <em>load</em> 语句，不做 A4 中的常量传播，找出将所有满足别名关系的 <em>store</em> 语句加以处理</li><li>对于 <em>store</em> 语句，需要将所有满足别名关系的 <em>load</em> 语句加入到 <em>solver</em> 的 <em>worklist</em> 中（本质上来讲，满足别名关系的 <em>load</em> 语句会动态地成为对应 <em>store</em> 语句的后继）</li></ul><h3 id="A8"><a href="#A8" class="headerlink" title="A8"></a>A8</h3><blockquote><p>开放性作业</p></blockquote><ul><li>为 Java 实现污点分析</li></ul><p>污点分析和指针分析的不同之处在于，污点可以在对象之间传播（因为污点和数据内容相关），所以不仅需要在方法调用处处理 <em>sources</em> 和 <em>sinks</em>（获取污点数据/得到污点流），还需要额外进行污点传播</p><p>在方法调用中特殊的污点传播：由 <em>base</em> 变量传给 <em>result</em>；由参数传给 <em>base</em> 变量；由参数传给 <em>result</em>，这些规则会在初始化的时候作为输入给出，可以通过 <em>TaintConfig</em> 类的 <em>getTransfer</em> 方法调用</p><p>总的来说，污点分析需要与 A6 中实现的指针分析相结合，并实现以下规则：</p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208111805794.png" alt="image-20220811180518725" style="zoom:50%;" /><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208111806418.png" alt="image-20220811180603335" style="zoom:50%;" /><p><strong>我的思路：</strong></p><ul><li><p><em>TaintAnalysiss</em> 中添加（实现）的主要 API：</p><ul><li><em>captureTaintObj</em>：执行 <em>Call(source)</em> 规则，返回一个新的污点对象</li><li><em>captureTaintTransfer</em>：执行特殊的污点传播规则，方法内部调用链三个私有方法 <em>captureBaseToResult</em>、<em>captureArgToBase</em> 和 <em>captureArgToResult</em>，分别执行规则 <em>Call(base-to-result)<em>、</em>Call(arg-to-base)</em> 和 <em>Call(arg-to-result)</em>  </li><li><em>collectTaintFlows</em>：执行 <em>Call(sink)</em> 规则，返回一个污点流的集合，即污点分析的结果</li></ul></li><li><p>在分析有返回值的方法调用时，调用 <em>taintAnalysis.captureTaintObj</em> 获取污点对象，并将其加入 <em>result</em> 变量的指针集中</p></li><li><p>在分析方法调用时，调用 <em>taintAnalysis.captureTaintTransfer</em> 处理污点传播</p></li></ul><p><strong>出现的问题及解决方式：</strong></p><p>当污点对象传播到某个变量的指针集中时，以该变量作为参数的方法调用可能已经被分析过，并且可能不会被再一次加入 <em>worklist</em>，导致分析结果有所遗漏（方法调用中特殊的污点传播的分析是安插在指针分析过程中的）</p><p>对 <em>propagate</em> 方法进行改进，若一个变量的指针集中有新流入污点对象，则从现有的调用图中获取所有的调用点，找到以该变量作为参数的调用点，并对该调用点单独执行一次 <em>captureTaintTransfer</em></p>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> 静态分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
