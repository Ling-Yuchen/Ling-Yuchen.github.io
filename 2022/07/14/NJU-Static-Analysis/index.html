<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Yoson Ling">





<title>南京大学《软件分析》课程笔记（更新中） | Yoson&#39;s Blog</title>



    <link rel="icon" href="/FisherGirl.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Yoson&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Yoson&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">南京大学《软件分析》课程笔记（更新中）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Yoson Ling</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">七月 14, 2022&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Learning/">Learning</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>课程内容来源：<a target="_blank" rel="noopener" href="https://tai-e.pascal-lab.net/">https://tai-e.pascal-lab.net/</a></p>
<p>实验作业的实现：<a target="_blank" rel="noopener" href="https://github.com/Ling-Yuchen/Tai-e-assignments/">https://github.com/Ling-Yuchen/Tai-e-assignments/</a></p>
<p>部分实验作业思路参考：<a target="_blank" rel="noopener" href="https://vgalaxy.gitee.io/2022/05/05/static-analysis/">https://vgalaxy.gitee.io/2022/05/05/static-analysis/</a></p>
<h2 id="01-Introduction"><a href="#01-Introduction" class="headerlink" title="01 - Introduction"></a>01 - Introduction</h2><h4 id="1-静态分析：运行前对程序进行分析"><a href="#1-静态分析：运行前对程序进行分析" class="headerlink" title="1. 静态分析：运行前对程序进行分析"></a>1. 静态分析：运行前对程序进行分析</h4><p>​        是否存在私有信息泄露？</p>
<p>​        是否存在空指针异常？</p>
<p>​        是否存在强制类型转换异常？</p>
<p>​        是否允许存在指向同一内存块的指针？</p>
<p>​        是否存在 fail 的 <em>assert</em> 语句？</p>
<p>​        是否存在可以删除的死代码？</p>
<p>​        ……</p>
<h4 id="2-莱斯定理（Rice’s-Theorem）"><a href="#2-莱斯定理（Rice’s-Theorem）" class="headerlink" title="2. 莱斯定理（Rice’s Theorem）"></a>2. 莱斯定理（<em>Rice’s Theorem</em>）</h4><p><em>Any non-trivial property of the behavior of programs in a r.e. language is undecidable.</em></p>
<p>通俗来讲就是，以平时常用的编程语言写的程序，对于其有用的动态运行时性质，无法做出准确判断</p>
<p>——不存在完美的（<em>sound &amp; complete</em>）静态分析</p>
<p>对 soundness 妥协：产生漏报（<em>false negatives</em>）（可以接受）</p>
<p>对 completeness 妥协：产生误报（<em>false positive</em>s）（不希望发生）</p>
<p>静态分析：在确保 <em>soundness</em> 的前提下，在分析的准确度和速度之间做出有效的平衡</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207132057151.png" alt="img" style="zoom:50%;" />



<h4 id="3-静态分析技术：抽象-近似"><a href="#3-静态分析技术：抽象-近似" class="headerlink" title="3. 静态分析技术：抽象+近似"></a>3. 静态分析技术：抽象+近似</h4><p>抽象（<em>abstraction</em>）：把具体域的值映射到抽象域的值</p>
<p>近似（Over-approximation）：在抽象层面定义转移函数；由于无法枚举所有路径，所以使用  <em>flow merging</em> 处理  <em>control flow</em></p>
<h4 id="本节重点"><a href="#本节重点" class="headerlink" title="本节重点"></a>本节重点</h4><ul>
<li>静态分析与（动态）测试的区别？</li>
<li>理解 soundness, completeness, false negatives 和 false positives 的概念</li>
<li>为什么静态分析需要保证 soundness？</li>
<li>怎样理解 abstraction 和 over-approximation？</li>
</ul>
<h2 id="02-Intermediate-Representation"><a href="#02-Intermediate-Representation" class="headerlink" title="02 - Intermediate Representation"></a>02 - Intermediate Representation</h2><h4 id="1-编译器（Compiler）与静态分析（Static-Analysis）"><a href="#1-编译器（Compiler）与静态分析（Static-Analysis）" class="headerlink" title="1. 编译器（Compiler）与静态分析（Static Analysis）"></a>1. 编译器（<em>Compiler</em>）与静态分析（<em>Static Analysis</em>）</h4><p>编译器：源码 =&gt;（词法分析器 Scanner）=&gt; Tokens =&gt;（语法分析器 Parser）=&gt; AST =&gt;（类型检查 Type Checker）=&gt; Decorated AST =&gt;（Translator）=&gt; IR =&gt;（Code Generator）=&gt; 机器码</p>
<p>静态分析需要在编译器前端生成的 IR 的基础上进行，e.g. 代码优化</p>
<h4 id="2-抽象语法树（AST）-vs-中间表示（IR）"><a href="#2-抽象语法树（AST）-vs-中间表示（IR）" class="headerlink" title="2. 抽象语法树（AST） vs. 中间表示（IR）"></a>2. 抽象语法树（<em>AST</em>） vs. 中间表示（<em>IR</em>）</h4><p>抽象语法树：贴近语法结构；依赖于不同语言；适合做快速的类型检查；缺少控制流信息</p>
<p>中间表示：贴近机器码；具有语言无关性；简洁而统一；包含控制流信息；通常作为静态分析的基础</p>
<h4 id="3-中间表示（三地址码）"><a href="#3-中间表示（三地址码）" class="headerlink" title="3. 中间表示（三地址码）"></a>3. 中间表示（三地址码）</h4><p>右侧最多只有一个操作符；每种指令都有对应的三地址码</p>
<ul>
<li>x = y <em>bop</em> z</li>
<li>x = <em>uop</em> y</li>
<li>x = y</li>
<li>goto L</li>
<li>if x goto L</li>
<li>if x <em>rop</em> y goto L</li>
</ul>
<h4 id="4-真实的静态分析器中的三地址码：Soot’s-IP"><a href="#4-真实的静态分析器中的三地址码：Soot’s-IP" class="headerlink" title="4. 真实的静态分析器中的三地址码：Soot’s IP"></a>4. 真实的静态分析器中的三地址码：Soot’s IP</h4><p>关于 JVM 的补充：</p>
<p>invoke-special:    call constructor，call superclass methods，call private methods</p>
<p>invoke-virtual:    call instance methods（virtual dispatch）</p>
<p>invoke-interface:    cannot optimize，checking interface implementation</p>
<p>invoke-static:    call static methods</p>
<p>method signature:    class name，return type，method name，parameter type</p>
<h4 id="5-控制流分析"><a href="#5-控制流分析" class="headerlink" title="5. 控制流分析"></a>5. 控制流分析</h4><p>输入三地址码，输出控制流图</p>
<p>Basic Block 定义：有且仅有一个入口和一个出口的指令块</p>
<p>确定 Basic Block 的算法：</p>
<ul>
<li>第一条指令是基本块的入口</li>
<li>所有跳转的目标指令是基本块的入口</li>
<li>所有跳转指令的下一条指令是基本块的入口</li>
<li>从一个入口指令到下一条入口指令的前一条指令构成一个基本块</li>
</ul>
<p>控制流图：</p>
<p>节点为基本块（<em>basic blocks</em>）</p>
<p>一条从基本块A到基本块B的边表示，存在从A尾部到B首部的有条件或无条件跳转，或者顺序上B紧跟着A且A的最后一条指令不是无条件跳转</p>
<p>加上 Entry 和 Exit 表示程序的入口和出口（类似哨兵节点）</p>
<h4 id="本节重点-1"><a href="#本节重点-1" class="headerlink" title="本节重点"></a>本节重点</h4><ul>
<li>编译器和静态分析器之间的关系？</li>
<li>理解三地址码及其通常的形式（in IR Jimple）</li>
<li>怎样在 IR 的基础上构建 basic blocks？</li>
<li>怎样在 basic blocks 的基础上构建控制流图？</li>
</ul>
<h2 id="03-Data-Flow-Analysis（Application）"><a href="#03-Data-Flow-Analysis（Application）" class="headerlink" title="03 - Data Flow Analysis（Application）"></a>03 - Data Flow Analysis（Application）</h2><h4 id="1-数据流分析概览"><a href="#1-数据流分析概览" class="headerlink" title="1. 数据流分析概览"></a>1. 数据流分析概览</h4><p>How <em>application-specific Data</em>（abstraction） <em>Flows</em>（safe-approximation） through the <em>Nodes</em> （Transfer function）and <em>Edges</em>（Control-flow handling） of CFG？</p>
<p>may analysis：输出信息可能是正确的（over-approximation）</p>
<p>must analysis：输出信息必须是正确的（under-approximation）</p>
<h4 id="2-数据流分析前驱知识"><a href="#2-数据流分析前驱知识" class="headerlink" title="2. 数据流分析前驱知识"></a>2. 数据流分析前驱知识</h4><p>Input and Output States</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141511690.png" alt="img" style="zoom:50%;" />

<p>在数据流分析应用中，将每一个 <em>program point</em> 与一个 表示该点所有观测到的 <em>program states</em> 的集合的抽象的<em>数据流值（data-flow value）</em> 联系起来</p>
<p>数据流分析是对所有的语句，通过解析 safe-approximation 的约束规则，得到一个 solution（给每个 <em>program point</em> 一个 <em>data-flow value</em>）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141528212.png" alt="img" style="zoom: 50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141533764.png" alt="img" style="zoom: 50%;" />

<h4 id="2-定义可达性分析（Reaching-Definition-Analysis）"><a href="#2-定义可达性分析（Reaching-Definition-Analysis）" class="headerlink" title="2. 定义可达性分析（Reaching Definition Analysis）"></a>2. 定义可达性分析（<em>Reaching Definition Analysis</em>）</h4><p>定义可达性：A definition <em>d</em> at program point <em>p</em> reaches a point <em>q</em> if there is a path from <em>p</em> to <em>q</em> such that <em>d</em> is not killed along the path.</p>
<p>定义可达性可以用于 <em>侦测可能的未定义的变量</em></p>
<p><strong>理解定义可达性分析：</strong></p>
<p>用一个比特表示某个变量在某一点的定义可达性</p>
<p>用一个 n 维比特向量表示 n 个变量在某一点的定义可达性</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141559532.png" alt="1" style="zoom:50%;" />

<p><strong>定义可达性分析算法：</strong></p>
<p>注意：</p>
<p>在算法模板中边界条件（OUT[entry]）单独初始化</p>
<p>对于 OUT[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141602719.png" alt="img" style="zoom:50%;" />

<p>为什么该迭代算法最终会停下来？</p>
<p>对于 Transfer Function，OUT[S] 只受 IN[S] 的影响，当个更多的 facts 流入 IN[S] 时，要么被 kill 要么存活下来并永远被保留，故 OUT[S] 永远不会缩减（e.g. 0 =&gt; 1 或 1 =&gt; 1），又因为定义的变量数量是有限的，故该迭代一定会停下来（实际上到达了一个不动点）</p>
<h4 id="4-活跃变量分析（Live-Variable-Analysis）"><a href="#4-活跃变量分析（Live-Variable-Analysis）" class="headerlink" title="4. 活跃变量分析（Live Variable Analysis）"></a>4. 活跃变量分析（<em>Live Variable Analysis</em>）</h4><p>Live variable analysis tells whether the value of <em>variable v</em> at <em>program point p</em> could be used along some path in CFG starting at <em>p</em>（AND <em>v</em> should not be redefined before usage）. If so, <em>v</em> is live at <em>p</em>. Otherwise, <em>v</em> is dead at <em>p</em>.</p>
<p>活跃变量信息可用于寄存器分配（倾向于使用存有 dead value 的寄存器来存新数据）</p>
<p><strong>理解活跃变量分析：</strong></p>
<p>用一个比特表示某个变量在某一点是否活跃</p>
<p>用一个 n 维比特向量表示 n 个变量在某一点是否活跃</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141823269.png" alt="1" style="zoom:50%;" />

<p>注意 use 的定义为：在重定义之前被使用</p>
<p><strong>活跃变量分析算法：</strong></p>
<p>注意：</p>
<p>在算法模板中边界条件（IN[entry]）单独初始化</p>
<p>对于 IN[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207141826606.png" alt="img" style="zoom:50%;" />

<h4 id="5-可用表达式分析（Available-Expressions-Analysis）"><a href="#5-可用表达式分析（Available-Expressions-Analysis）" class="headerlink" title="5. 可用表达式分析（Available Expressions Analysis）"></a>5. 可用表达式分析（<em>Available Expressions Analysis</em>）</h4><p>一个表达式，形如 <em>x op y</em>，在某个 <em>program point p</em> 是可用的，需要满足：</p>
<ul>
<li>从 <em>ENTRY</em> 到 <em>p</em> 的所有路径都必须计算过 <em>x op y</em> 的值</li>
<li>在这些路径各自最后一次计算该表达式的值之后没有修改过 <em>x</em> 或 <em>y</em> 的值</li>
</ul>
<p><strong>理解可用表达式分析：</strong></p>
<p>用一个比特表示某个表达式在某点是否可用</p>
<p>用一个 n 维比特向量表示 n 个表达式在某点是否可用</p>
<p>注意这是一个 must analysis</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171149946.png" alt="1" style="zoom:50%;" />



<p><strong>可用表达式分析算法：</strong></p>
<p>注意在 must analysis 中的初始化方式</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171151583.png" alt="img" style="zoom:50%;" />

<h4 id="6-不同数据流分析应用的对比"><a href="#6-不同数据流分析应用的对比" class="headerlink" title="6. 不同数据流分析应用的对比"></a>6. 不同数据流分析应用的对比</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171210734.png" alt="1" style="zoom:50%;" />

<h4 id="本节重点-2"><a href="#本节重点-2" class="headerlink" title="本节重点"></a>本节重点</h4><ul>
<li>理解三种数据流分析</li>
<li>能说出三种数据流分析的相似与不同</li>
<li>理解迭代算法为什么最终能停下来</li>
</ul>
<h2 id="04-Data-Flow-Analysis（Foundations）"><a href="#04-Data-Flow-Analysis（Foundations）" class="headerlink" title="04 - Data Flow Analysis（Foundations）"></a>04 - Data Flow Analysis（Foundations）</h2><h4 id="1-从另一个角度来看迭代算法"><a href="#1-从另一个角度来看迭代算法" class="headerlink" title="1. 从另一个角度来看迭代算法"></a>1. 从另一个角度来看迭代算法</h4><p>假设给定的 CFG 有 <em>k</em> 个节点，迭代算法每次迭代更新每个节点的 OUT[n]</p>
<p>定义 <em>k-tuple</em> (OUT[n1], … , OUT[nk])，则该元组为集合 V^k 的一个元素（V 是数据流分析的值的域）</p>
<p>那么每次迭代可以视作作用了转移函数和流控制处理的一次映射，即：F:  V^k —&gt; V^k</p>
<p>整个算法就是在不断地输出这样的 <em>k-tuple</em> 直到出现连续两个相同的为止</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171602188.png" alt="img" style="zoom:50%;" />

<p>迭代算法会在 X = F(X) 处停下来，即数学定义上的一个不动点（<em>fixed point</em>）</p>
<p>思考：</p>
<ul>
<li>算法能保证到达不动点吗？</li>
<li>如果能，那么只有一个不动点吗？若超过一个不动点，那么我们能到达最优解的不动点吗？</li>
<li>算法要多久才能到达不动点？（时间复杂度）</li>
</ul>
<h4 id="2-偏序"><a href="#2-偏序" class="headerlink" title="2. 偏序"></a>2. 偏序</h4><p>偏序关系（<em>Partial Order</em>）满足自反性、反对称性、传递性</p>
<p>一个偏序集（<em>poset</em>）中的任意两个元素之间不一定满足偏序关系</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171807638.png" alt="img" style="zoom:50%;" />

<h4 id="3-上界和下界"><a href="#3-上界和下界" class="headerlink" title="3. 上界和下界"></a>3. 上界和下界</h4><p>上界（<em>upper bound</em>）和下界（<em>lower bound</em>）</p>
<p>最小上界（<em>least upper bound</em>）和最大下界（<em>greatest lower bound</em>）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171809088.png" alt="img" style="zoom:50%;" />

<p>最小上界（<em>least upper bound</em>）和最大下界（<em>greatest lower bound</em>）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207171809056.png" alt="img" style="zoom:50%;" />

<p>不是每个偏序集都有最小上界（最大下界）；若偏序集存在最小上界（最大下界），则是唯一的</p>
<h4 id="4-格、半格、全格、格的积"><a href="#4-格、半格、全格、格的积" class="headerlink" title="4. 格、半格、全格、格的积"></a>4. 格、半格、全格、格的积</h4><p>格（<em>Lattice</em>）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181246948.png" alt="img" style="zoom:50%;" />

<p>半格（<em>Semilattice</em>）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181251145.png" alt="1" style="zoom:50%;" />

<p>全格（<em>Complete Lattice</em>）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181253998.png" alt="img" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181257563.png" alt="1" style="zoom:50%;" />

<p>有穷格一定是全格，全格不一定是有穷格</p>
<p>格的积（<em>Product Lattice</em>）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181811085.png" alt="img" style="zoom:50%;" />

<h4 id="5-通过格来表达数据流分析框架"><a href="#5-通过格来表达数据流分析框架" class="headerlink" title="5. 通过格来表达数据流分析框架"></a>5. 通过格来表达数据流分析框架</h4><p>数据流分析框架（D, L, F）：</p>
<ul>
<li>D：数据流的方向（<em>forward</em> 或 <em>backward</em>）</li>
<li>L：一个包含分析域（<em>domain</em>）以及 <em>join</em> 和 <em>meet</em> 操作的格</li>
<li>F：一组定义在在域（<em>domain</em>）上的转移函数（<em>transfer function</em>）</li>
</ul>
<p>数据流分析可以视作：对格的值迭代地作用转移函数（<em>transfer function</em>）和 <em>join</em> 或 <em>meet</em> 操作</p>
<h4 id="6-单调性与不动点定理"><a href="#6-单调性与不动点定理" class="headerlink" title="6. 单调性与不动点定理"></a>6. 单调性与不动点定理</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181843635.png" alt="img" style="zoom:50%;" />

<p><strong>证明：不动点存在且是最小（大）的</strong></p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181851338.png" alt="img" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207181855231.png" alt="img" style="zoom:50%;" />

<h4 id="7-将迭代算法和不动点定理关联在一起"><a href="#7-将迭代算法和不动点定理关联在一起" class="headerlink" title="7. 将迭代算法和不动点定理关联在一起"></a>7. 将迭代算法和不动点定理关联在一起</h4><p>将迭代算法和不动点定理做出以下关联</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207182103098.png" alt="2" style="zoom:50%;" />

<p>故只要证明 <em>function F</em> 是单调的</p>
<p>之前已经说明 <em>transfer function</em> 是单调的，故只要证明 <em>join/meet function</em> 是单调的</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207182111913.png" alt="img" style="zoom:50%;" />

<p>到这里为止，我们可以用格的数学概念和不动点定理严格证明：</p>
<p>数据流分析的迭代算法一定能停下来（到达不动点），并且一定是最大（最小）不动点</p>
<h4 id="8-格的视角下的-May-Must-Analysis"><a href="#8-格的视角下的-May-Must-Analysis" class="headerlink" title="8. 格的视角下的 May / Must Analysis"></a>8. 格的视角下的 May / Must Analysis</h4><p>无论是 May Analysis 还是 Must Analysis，都是从 unsafe 的情况向 safe but useless 的情况迭代</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207182148271.png" alt="3" style="zoom:50%;" />

<h4 id="9-MOP"><a href="#9-MOP" class="headerlink" title="9. MOP"></a>9. MOP</h4><p>Meet-Over-All-Paths Solution（MOP）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242025411.png" alt="img" style="zoom:50%;" />

<p>迭代算法与 MOP 的比较：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242036375.png" alt="img" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242037852.png" alt="1" style="zoom:50%;" />

<p>迭代算法得到的结果没有 MOP 准确，但当 <em>Transfer Function</em> 满足分配律的时候，迭代算法可以做到和 MOP 一样准确（可以用集合的交并进行操作的 <em>Transfer Function</em> 都是满足分配律的）</p>
<h4 id="10-常量传播分析（Constant-Propagation-Analysis）"><a href="#10-常量传播分析（Constant-Propagation-Analysis）" class="headerlink" title="10. 常量传播分析（Constant Propagation Analysis）"></a>10. 常量传播分析（<em>Constant Propagation Analysis</em>）</h4><p>常量传播（<em>Constant Propagation</em>）：对于给定的变量 <em>x</em>，在某一个 <em>program point p</em>，确定该变量是否确保持有一个常量值（<em>must analysis</em> ）</p>
<p>与之前的数据流分析不同，常量传播 CFG 中每个节点的 IN 和 OUT 都是键值对 <em>(x, v)</em> 的集合（<em>x</em> 表示变量名， <em>v</em> 表示变量持有的值）</p>
<p>根据数据流分析框架 (D, L, F) 来对常量传播分析进行定义：</p>
<ul>
<li>常量传播分析的数据流是正向的（<em>forward</em>）</li>
<li>常量传播分析的格模型</li>
</ul>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242130437.png" alt="img" style="zoom: 50%;" />

<ul>
<li>常量传播分析的转移函数</li>
</ul>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242113532.png" alt="1" style="zoom:50%;" />

<p>常量传播分析的 <em>Transfer Function</em> 不满足分配律</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242139017.png" alt="img" style="zoom:50%;" />

<h4 id="11-工作列表算法"><a href="#11-工作列表算法" class="headerlink" title="11. 工作列表算法"></a>11. 工作列表算法</h4><p>工作列表算法（<em>Worklist Algorithm</em>）是迭代算法的一种优化，在实际场景中更常用</p>
<p>迭代算法的主体操作流程清晰直观但有很多冗余步骤，工作列表算法可以做到每次仅对有变化的部分施加转移函数</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207242145947.png" alt="img" style="zoom:50%;" />

<h4 id="本节重点-3"><a href="#本节重点-3" class="headerlink" title="本节重点"></a>本节重点</h4><ul>
<li>从函数的角度理解迭代算法</li>
<li>理解格的概念</li>
<li>理解不动点定理</li>
<li>用格来概括 <em>may/must analysis</em></li>
<li>理解 MOP 和迭代算法之间的联系</li>
<li>常量传播分析</li>
<li>工作列表算法</li>
</ul>
<h2 id="05-Interprocedural-Analysis"><a href="#05-Interprocedural-Analysis" class="headerlink" title="05 - Interprocedural Analysis"></a>05 - Interprocedural Analysis</h2><h4 id="1-为什么需要过程间分析"><a href="#1-为什么需要过程间分析" class="headerlink" title="1. 为什么需要过程间分析"></a>1. 为什么需要过程间分析</h4><p>仅对单个方法进行静态分析，若出现了对别的方法的调用，为了确保分析的正确性，只能认为该调用可以做任何事情，从而使得分析结果不够准确。例如，在常量传播分析中，分析 <em>x = fun()</em> 会认为 <em>x</em> 是 NAC，但方法 <em>fun()</em> 可能返回的是一个常数，即 <em>int fun() { return 0; }</em></p>
<h4 id="2-调用图的构造"><a href="#2-调用图的构造" class="headerlink" title="2. 调用图的构造"></a>2. 调用图的构造</h4><p>调用图：程序中调用关系的表示方式</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271046525.png" alt="1" style="zoom:50%;" />

<p>调用图的应用：过程间分析的基础，程序的优化、理解、debug、测试 ……</p>
<p>OO 语言的调用图的构造（以 JAVA 为代表）：</p>
<ul>
<li>类层次分析（<em>CHA，Class Hierarchy Analysis</em>）：效率高</li>
<li>指针分析（<em>k-CFA，Pointer Analysis</em>）：精确度高</li>
</ul>
<p>JAVA 中的方法调用共有五种，其中 <em>invokedynamic</em> 在此不做考虑，由于 <em>Virtual Call</em> 的目标方法是运行时动态确定的（多态），故构造调用图的难点和关键在于如何处理 <em>Virtual Call</em></p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271059481.png" alt="1" style="zoom:50%;" />

<p><em>Virtual Call</em> 的方法分派依据 <em>receiver object</em> 的类型 <em>c</em> 和方法的签名 <em>m</em> （形如 *&lt;ClassType：ReturnType MehtodName（ParameterTypes）&gt;*），定义函数 <em>Dispatch(c, m)</em> 去模拟运行时方法分派，总的思路是优先在子类中匹配，匹配不到则递归地到父类中匹配</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271118454.png" alt="1" style="zoom:50%;" />

<p><strong>类层次分析（<em>Class Hierarchy Analysis</em>）</strong></p>
<p>适用于 IDE 等场景，快速分析并对准确性没有较高的要求</p>
<p>定义函数 <em>Resolve(cs)</em> 解析方法调用的可能的目标方法，分别处理 <em>static call</em>，<em>special call</em> 和 <em>virtual call</em></p>
<p>注意 <em>special call</em> 中调用父类方法的时候需要递归寻找，为了形式统一使用用 <em>Dispatch</em> 函数</p>
<p>注意 <em>virtual call</em> 需要对对象的声明类型及其所有子类做 <em>Dispatch</em>（可能产生假的目标方法，不够准确）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271158826.png" alt="1" style="zoom:50%;" />

<p>下面是 CHA 的一个例子，注意理解 <em>Resolve( b.foo() )</em></p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271210904.png" alt="1" style="zoom:50%;" />

<p>通过 CHA 来构造调用图：从入口方法（<em>main</em>）开始，对每一个可达的方法 <em>m</em> 中的每一个调用点 <em>cs</em>，解析目标方法（*Resolve(cs)*），重复该过程知道没有新的方法被发现。具体算法如下：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271234192.png" alt="img" style="zoom:50%;" />

<h4 id="3-过程间控制流图"><a href="#3-过程间控制流图" class="headerlink" title="3. 过程间控制流图"></a>3. 过程间控制流图</h4><p>回顾：控制流图（<em>CFG</em>）可以表示一个独立的方法的结构</p>
<p>过程间控制流图（<em>ICFG，Interprocedural Control-Flow Graph</em>）可以表示整个程序的结构，包含程序中每个方法自己的控制流图以及两类额外的边：从调用点指向被调用方法的 <em>Call edges</em> 和从被调用方法的返回语句指向返回点（即调用点的下一条语句）的 <em>Return edges</em>，额外的边的信息从构造的调用图中可以获取。概述如下图：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271459841.png" alt="img" style="zoom:50%;" />

<h4 id="4-过程间数据流分析"><a href="#4-过程间数据流分析" class="headerlink" title="4. 过程间数据流分析"></a>4. 过程间数据流分析</h4><p>基于 ICFG 进行程序分析，其 <em>Transfer Function</em> 不仅需要正常的 <em>Node Transfer</em> 还要处理 <em>Call Edge Transfer</em>（用于传参） 和 <em>Return Edge Transfer</em>（用于传递返回值）</p>
<p><strong>过程间常量传播分析（<em>Interprocedural Constant Propagation</em>）</strong></p>
<p>在 ICFG 中保留了调用点到返回点之间相连的边（<em>call-to-return edge</em>），能使得 ICFG 能够传递本地数据流（单个 CFG 内产生的数据流）</p>
<p>在本地方法的 CFG 中的 <em>Node Transfer</em> 需要把调用点的左值变量 <em>kill</em> 掉（<em>Return Edge Transfer</em> 会覆盖这些变量的值）</p>
<p>下面是一个详细示例：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271523413.png" alt="1" style="zoom:50%;" />

<h4 id="本节重点-4"><a href="#本节重点-4" class="headerlink" title="本节重点"></a>本节重点</h4><ul>
<li>如何通过 CHA 构建调用图</li>
<li>过程间控制流图的概念</li>
<li>过程间数据流分析的概念</li>
<li>过程间常量传播分析</li>
</ul>
<h2 id="06-Pointer-Analysis"><a href="#06-Pointer-Analysis" class="headerlink" title="06 - Pointer Analysis"></a>06 - Pointer Analysis</h2><h4 id="1-为什么需要指针分析"><a href="#1-为什么需要指针分析" class="headerlink" title="1. 为什么需要指针分析"></a>1. 为什么需要指针分析</h4><p>基于指向关系进行分析，能有效避免 CHA 中出现 <em>fake target</em> 的问题</p>
<p>例如：针对语句 { A a = new A(); a.fun(); }，CHA 在解析 <em>a.fun()</em> 时会得到所有 A 类型及其子类的签名为 <em>fun()</em> 的方法，而使用指针分析则可以找到唯一的一个目标方法，提高分析的准确性</p>
<h4 id="2-指针分析的介绍"><a href="#2-指针分析的介绍" class="headerlink" title="2. 指针分析的介绍"></a>2. 指针分析的介绍</h4><p>指针分析是基础的静态分析，计算一个指针能够指向内存中的哪些地址</p>
<p>对于面向对象语言，以 JAVA 为例，指针分析计算一个指针（<em>variable or field</em>）能够指向哪些对象</p>
<p>指针分析可以看作一种 <em>may analysis</em>，计算结果是一个 <em>over-approximation</em></p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281010951.png" alt="img" style="zoom:50%;" />

<p>概念辨析：指针分析 vs. 别名分析</p>
<p>指针分析回答的问题：Which objects a pointer can point to ?</p>
<p>别名分析回答的问题：Can two pointers point to the same object ?</p>
<p>别名分析的结果可由指针分析的结果推到而来</p>
<h4 id="3-影响指针分析的关键要素"><a href="#3-影响指针分析的关键要素" class="headerlink" title="3. 影响指针分析的关键要素"></a>3. 影响指针分析的关键要素</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271601082.png" alt="img" style="zoom:50%;" />

<p><strong>堆抽象（<em>Heap Abstraction</em>）</strong></p>
<p>为了保证静态分析能够终止，对堆内存进行建模，把 <em>动态分配的无限的具体对象</em>  构建成 <em>有限的抽象的对象</em></p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207271611034.png" alt="1" style="zoom:50%;" />

<p>调用点抽象技术（<em>Allocation-Site Abstraction</em>）</p>
<p>将实例对象抽象成创建点，每个创建点建立一个抽象对象，用来表示该创建点分配的具体对象（在循环中的同一个创建点实际运行时会创建多个具体对象，但由于只有一个创建点只会创建一个抽象对象）</p>
<p><strong>上下文敏感（<em>Context Sensitivity</em>）</strong></p>
<p>上下文敏感的分析中，对同一个方法的不同调用进行区分，对每一个上下文都分析一次目标方法</p>
<p>上下文不敏感的分析中，对同一个方法的不同调用做数据流的合并处理，只分析一次，可能丢失精度</p>
<p><strong>流敏感（<em>Flow Sensitivity</em>）</strong></p>
<p>流敏感的分析是尊重语句的执行顺序的，程序中每个位置都维护了一个包含指向关系的 map</p>
<p>流不敏感的分析是忽视控制流的顺序的，整个程序只维护了一个包含指向关系的 map</p>
<p><strong>分析域（<em>Analysis Scope</em>）</strong></p>
<p>全程序分析：计算程序中所有指针的信息，服务所有可能的应用</p>
<p>需求驱动分析：只计算需要用到的指针的信息，服务特定的应用</p>
<h4 id="4-指针分析需要分析的语句"><a href="#4-指针分析需要分析的语句" class="headerlink" title="4. 指针分析需要分析的语句"></a>4. 指针分析需要分析的语句</h4><p>指针分析只关注 <em>Pointer-Affecting Statements</em></p>
<p>JAVA 中的指针：</p>
<ul>
<li>本地变量（<em>local variable</em>）<em>e.g.</em>  x</li>
<li>静态字段（<em>static field</em>）<em>e.g.</em>  C.f</li>
<li>实例字段（<em>instance field</em>）<em>e.g.</em>  x.f</li>
<li>数组元素（<em>array element</em>）<em>e.g.</em>  array[i]</li>
</ul>
<p>在数组元素的指针分析中，忽略数组下标，把整个数组视作一个单独的 <em>field</em></p>
<p>处理静态字段的方式与处理本地变量相似，处理数组元素的方式与处理实例字段相似</p>
<p>JAVA 中的 <em>pointer-affecting statements</em>：</p>
<ul>
<li>创建 New    <em>x = new T()</em></li>
<li>赋值 Assign    <em>x = y</em></li>
<li>存储 Store    <em>x.f = y</em></li>
<li>加载 Load    <em>y = x.f</em></li>
<li>调用 Call    <em>r = x.k(a, …)</em></li>
</ul>
<h4 id="本节重点-5"><a href="#本节重点-5" class="headerlink" title="本节重点"></a>本节重点</h4><ul>
<li>什么是指针分析</li>
<li>理解影响指针分析的关键要素</li>
<li>理解指针分析需要分析哪些内容</li>
</ul>
<h2 id="07-Pointer-Analysis（Foundations）"><a href="#07-Pointer-Analysis（Foundations）" class="headerlink" title="07 - Pointer Analysis（Foundations）"></a>07 - Pointer Analysis（Foundations）</h2><blockquote>
<p>本章节介绍使用调用点抽象技术、上下文不敏感、流不敏感的全程序指针分析</p>
</blockquote>
<h4 id="1-指针分析的规则"><a href="#1-指针分析的规则" class="headerlink" title="1. 指针分析的规则"></a>1. 指针分析的规则</h4><p>在 JAVA 的指针分析中，常用流不敏感的方式（效率高，精度损失可接受）</p>
<p>指针分析的域及其表示：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281054043.png" alt="img" style="zoom:50%;" />

<p>不同语句的指针分析规则：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281059426.png" alt="1" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207281109304.png" alt="img" style="zoom:50%;" />

<h4 id="2-指针分析的实现"><a href="#2-指针分析的实现" class="headerlink" title="2. 指针分析的实现"></a>2. 指针分析的实现</h4><p>指针分析要在指针间传播指向信息，指针分析解决的是指针间的包含约束系统的问题</p>
<p>实现指针分析的关键在于：当指针集 <em>pt(x)</em> 改变时，要把更新的信息传播给其他与 <em>x</em> 相关的指针</p>
<p>实现方式：用图去连接相关联的指针，当指针集 <em>pt(x)</em> 改变时，把更新的信息传播给 <em>x</em> 的后继</p>
<h5 id="指针流图（Pointer-Flow-Graph，PFG）"><a href="#指针流图（Pointer-Flow-Graph，PFG）" class="headerlink" title="指针流图（Pointer Flow Graph，PFG）"></a>指针流图（<em>Pointer Flow Graph，PFG</em>）</h5><p>指针流图的节点为 <em>Pointer</em> = *V ∪ (O × F)*，可能是变量或抽象对象的字段</p>
<p>指针流图的边为 <em>Pointer × Pointer</em>，由 <em>x</em> 指向 <em>y</em> 的边表示 <em>x</em> 指向的对象有可能被 <em>y</em> 指向</p>
<p>指针流图的边由程序中的语句和处理指针分析的规则来确定：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061225160.png" alt="image-20220806122505050" style="zoom:50%;" />

<p>通过指针流图，指针分析问题可以转化为在指针流图上求解传递闭包的问题</p>
<p>指针分析的复杂性在于构建指针流图和传播指向信息相互依赖（在指针分析的过程中，指针流图也在不断更新迭代，从而再次影响指针分析的过程）：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061238046.png" alt="image-20220806123814992" style="zoom:50%;" />

<h4 id="3-指针分析的算法"><a href="#3-指针分析的算法" class="headerlink" title="3. 指针分析的算法"></a>3. 指针分析的算法</h4><h5 id="完整的算法过程："><a href="#完整的算法过程：" class="headerlink" title="完整的算法过程："></a>完整的算法过程：</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061242284.png" alt="image-20220806124226182" style="zoom:50%;" />

<p>关于算法中 <em>WL</em>，即 <em>Worklist</em> 的解释：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061248121.png" alt="image-20220806124824952" style="zoom:50%;" />

<h4 id="4-带有方法调用的指针分析"><a href="#4-带有方法调用的指针分析" class="headerlink" title="4. 带有方法调用的指针分析"></a>4. 带有方法调用的指针分析</h4><p>过程间的指针分析需要构建调用图，使用 <em>CHA</em> 基于声明类型解析目标方法可能产生 <em>fake target</em>，在指针分析中，可以基于变量的指针集进行解析，得到更准确的调用图（<em>on-the fly call graph construnction</em>）</p>
<h5 id="方法调用的指针分析规则："><a href="#方法调用的指针分析规则：" class="headerlink" title="方法调用的指针分析规则："></a>方法调用的指针分析规则：</h5><p>一个方法调用要做的四件事：Dispatch；传 receiver object；传参数；传返回值</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061604497.png" alt="image-20220806160402337" style="zoom:50%;" />

<p>思考：为什么不在 <em>PFG</em> 中添加由 <em>x</em> 到 <em>m_this</em> 的边？</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061653145.png" alt="image-20220806165315061" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061653241.png" alt="image-20220806165343145" style="zoom:50%;" />

<p>过程间指针分析和调用图的构建相互依赖，同时进行</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061726888.png" alt="image-20220806172637806" style="zoom:50%;" />

<h5 id="带有方法调用的指针分析的算法实现："><a href="#带有方法调用的指针分析的算法实现：" class="headerlink" title="带有方法调用的指针分析的算法实现："></a>带有方法调用的指针分析的算法实现：</h5><p>（黄底内容为新增部分）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208061729060.png" alt="image-20220806172859940" style="zoom:50%;" />

<h4 id="本节重点-6"><a href="#本节重点-6" class="headerlink" title="本节重点"></a>本节重点</h4><ul>
<li>理解指针分析的规则</li>
<li>理解指针流图</li>
<li>理解指针分析的方法</li>
<li>理解指针分析处理方法调用的规则</li>
<li>理解过程间指针分析算法</li>
<li>理解即时调用图构建</li>
</ul>
<h2 id="08-Pointer-Analysis（Context-Sensitivity）"><a href="#08-Pointer-Analysis（Context-Sensitivity）" class="headerlink" title="08 - Pointer Analysis（Context Sensitivity）"></a>08 - Pointer Analysis（Context Sensitivity）</h2><blockquote>
<p>本章节介绍使用调用点抽象技术、上下文敏感、流不敏感的全程序指针分析</p>
</blockquote>
<h4 id="1-上下文敏感指针分析介绍"><a href="#1-上下文敏感指针分析介绍" class="headerlink" title="1. 上下文敏感指针分析介绍"></a>1. 上下文敏感指针分析介绍</h4><h5 id="为什么需要上下文敏感技术："><a href="#为什么需要上下文敏感技术：" class="headerlink" title="为什么需要上下文敏感技术："></a>为什么需要上下文敏感技术：</h5><p>在动态执行的时候，一个方法可能被调用多次，而不同调用的上下文不同（传参不同、返回点不同），故在上下文不敏感的指针分析中，不同调用上下文混合的数据流在程序中传播，产生假的数据流，影响程序分析的精度；引入上下文敏感技术，区分不同上下文之间的数据流，可以提升程序分析的精度</p>
<h5 id="上下文的表示方式："><a href="#上下文的表示方式：" class="headerlink" title="上下文的表示方式："></a>上下文的表示方式：</h5><p>使用调用点来作为上下文：用一系列调用点来链式表示每个上下文（栈抽象）</p>
<h5 id="上下文敏感的实现："><a href="#上下文敏感的实现：" class="headerlink" title="上下文敏感的实现："></a>上下文敏感的实现：</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081252673.png" alt="image-20220808125210400" style="zoom:50%;" />

<h5 id="上下文敏感的堆抽象："><a href="#上下文敏感的堆抽象：" class="headerlink" title="上下文敏感的堆抽象："></a>上下文敏感的堆抽象：</h5><p>在 <em>OO</em> 程序中，经常需要修改堆上对象，因此在实际情况中，上下文敏感技术需要应用于堆抽象</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081300289.png" alt="image-20220808130043102" style="zoom:50%;" />

<p>为什么上下文敏感的堆抽象能够提升分析精度：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081302280.png" alt="image-20220808130257124" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081538904.png" alt="image-20220808153838733" style="zoom:50%;" />

<h4 id="2-上下文敏感指针分析规则"><a href="#2-上下文敏感指针分析规则" class="headerlink" title="2. 上下文敏感指针分析规则"></a>2. 上下文敏感指针分析规则</h4><h5 id="上下文敏感指针分析的域及其表示："><a href="#上下文敏感指针分析的域及其表示：" class="headerlink" title="上下文敏感指针分析的域及其表示："></a>上下文敏感指针分析的域及其表示：</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081542619.png" alt="image-20220808154228430" style="zoom:50%;" />

<h5 id="上下文敏感指针分析的规则："><a href="#上下文敏感指针分析的规则：" class="headerlink" title="上下文敏感指针分析的规则："></a>上下文敏感指针分析的规则：</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081554195.png" alt="image-20220808155432112" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081609672.png" alt="image-20220808160955460" style="zoom:50%;" />

<h4 id="3-上下文敏感指针分析算法"><a href="#3-上下文敏感指针分析算法" class="headerlink" title="3. 上下文敏感指针分析算法"></a>3. 上下文敏感指针分析算法</h4><p>基本思路和上下文不敏感的指针分析相似，即：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081847583.png" alt="image-20220808184754519" style="zoom:50%;" />

<p>其中 <em>PFG with C.S.</em> 是一个有向图，定义如下：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081850174.png" alt="image-20220808185051069" style="zoom:50%;" />

<p><em>PFG with C.S.</em> 边的建立：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081854521.png" alt="image-20220808185440449" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208081856242.png" alt="image-20220808185605023" style="zoom:50%;" />

<p>上下文敏感指针分析完整算法：</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208082003685.png" alt="image-20220808200312549"></p>
<h4 id="4-上下文敏感技术的变种"><a href="#4-上下文敏感技术的变种" class="headerlink" title="4. 上下文敏感技术的变种"></a>4. 上下文敏感技术的变种</h4><blockquote>
<p>上下文敏感指针分析算法中 <em>Select</em> 方法的具体实现方式</p>
</blockquote>
<h5 id="调用点敏感（Call-site-Sensitivity）"><a href="#调用点敏感（Call-site-Sensitivity）" class="headerlink" title="调用点敏感（Call-site Sensitivity）"></a>调用点敏感（<em>Call-site Sensitivity</em>）</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208082233180.png" alt="image-20220808223352053" style="zoom:50%;" />

<p>为了避免产生过多的上下文，保证指针分析在合理的时间内完成，需要对调用链的长度进行限制（<em>e.g.</em> 递归调用能够产生很长的调用链），故引入 <em>k-Limiting Context Abstraction</em>，即选用最后的 <em>k</em> 个调用点作为上下文：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091134010.png" alt="image-20220809113401843" style="zoom:50%;" />

<h5 id="调用对象敏感（Object-Sensitivity）"><a href="#调用对象敏感（Object-Sensitivity）" class="headerlink" title="调用对象敏感（Object Sensitivity）"></a>调用对象敏感（<em>Object Sensitivity</em>）</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091220974.png" alt="image-20220809122016842" style="zoom:50%;" />

<p>在 <em>OO</em> 语言的实际应用中，调用对象敏感效果比调用点敏感速度更快、效果更好</p>
<h5 id="调用类型敏感（Type-Sensitivity）"><a href="#调用类型敏感（Type-Sensitivity）" class="headerlink" title="调用类型敏感（Type Sensitivity）"></a>调用类型敏感（<em>Type Sensitivity</em>）</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091409784.png" alt="image-20220809140913638" style="zoom:50%;" />

<p>调用类型敏感是对调用对象敏感的一种粗粒度的抽象，获取了更快的分析速度，牺牲了精度</p>
<h5 id="三种上下文敏感技术变体的对比"><a href="#三种上下文敏感技术变体的对比" class="headerlink" title="三种上下文敏感技术变体的对比"></a>三种上下文敏感技术变体的对比</h5><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208091415141.png" alt="image-20220809141528031" style="zoom:50%;" />

<h4 id="本节重点-7"><a href="#本节重点-7" class="headerlink" title="本节重点"></a>本节重点</h4><ul>
<li>上下文敏感的概念</li>
<li>上下文敏感的堆抽象的概念</li>
<li>为什么上下文敏感和上下文敏感的堆抽象能够提升分析的精度</li>
<li>上下文敏感的指针分析的规则</li>
<li>上下文敏感指针分析的算法</li>
<li>常见的上下文敏感技术的变体</li>
<li>常见的上下文敏感技术的变体的不同与联系</li>
</ul>
<h2 id="09-Static-Analysis-For-Security"><a href="#09-Static-Analysis-For-Security" class="headerlink" title="09 - Static Analysis For Security"></a>09 - Static Analysis For Security</h2><h4 id="1-信息流安全"><a href="#1-信息流安全" class="headerlink" title="1. 信息流安全"></a>1. 信息流安全</h4><p>与访问控制不同，信息流表示一种端到端的数据流动</p>
<p>给程序中的变量赋予不同的密级（<em>Security Level</em>）以构建实现信息流安全的策略</p>
<p>密级可以用格（<em>Lattice</em>）进行建模，虽然二元密级（<em>Low &amp; High</em>）最为常见和常用，但是也可以存在复杂的密级结构：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101547940.png" alt="image-20220810154757779" style="zoom: 40%;" />

<p>非干涉策略（<em>Noninterference Policy</em>）：不允许信息从高密级流向低密级</p>
<h4 id="2-保密性和完整性"><a href="#2-保密性和完整性" class="headerlink" title="2. 保密性和完整性"></a>2. 保密性和完整性</h4><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101553122.png" alt="image-20220810155305010" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101557442.png" alt="image-20220810155701257" style="zoom:50%;" />

<h4 id="3-显式流和隐藏信道"><a href="#3-显式流和隐藏信道" class="headerlink" title="3. 显式流和隐藏信道"></a>3. 显式流和隐藏信道</h4><p>显式流（<em>explicit flow</em>）：通过直接拷贝进行的信息流动</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101837830.png" alt="image-20220810183716782" style="zoom:50%;" />

<p>隐式流（<em>implicit flow</em>）：控制流受到高密级信息的影响，如果产生的副作用能被观测到则会信息泄露</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101836377.png" alt="image-20220810183644320" style="zoom:50%;" />

<p>隐藏信道（<em>hidden channel</em>）：不是用来传递信息流的内容将信息间接地传递出去，造成信息泄露</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102026254.png" alt="image-20220810202644130" style="zoom:50%;" />

<p>就保密性而言，隐藏信道泄露的信息量有限，就完整性而言，隐藏信道不会造成什么危害，故应当优先处理显式流中的信息流安全问题</p>
<h4 id="4-污点分析"><a href="#4-污点分析" class="headerlink" title="4. 污点分析"></a>4. 污点分析</h4><p>污点分析（<em>Taint Analysis</em>）将程序中的数据分为两类：</p>
<ul>
<li><em>Data of interest</em>，将某些标签与其进行绑定，称之为污点数据（<em>tainted data</em>）</li>
<li><em>Other data</em>，称之为非污点数据（<em>untainted data</em>）</li>
</ul>
<p>污点数据的源头称为 <em>source</em>，实际情况中，污点数据通常来源于某些方法（<em>sources</em>）的返回值</p>
<p>污点分析追踪污点数据，观测其是否会流入某个特定的地方（<em>sink</em>） ，实际情况下通常是某些方法传参</p>
<p>污点分析的两种应用：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102046001.png" alt="image-20220810204620890" style="zoom:50%;" />

<p>污点分析和指针分析本质上具有高度一致性，可以依据指针分析来做污点分析：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102050227.png" alt="image-20220810205031124" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102054790.png" alt="image-20220810205425522" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102058692.png" alt="image-20220810205817421" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102102679.png" alt="image-20220810210253547" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208102100445.png" alt="image-20220810210049208" style="zoom:50%;" />

<h4 id="本节重点-8"><a href="#本节重点-8" class="headerlink" title="本节重点"></a>本节重点</h4><ul>
<li>信息流安全的概念</li>
<li>保密性和完整性的概念</li>
<li>显式流和隐藏信道的概念</li>
<li>如何使用污点分析的检测有安全隐患的信息流</li>
</ul>
<h2 id="10-Datalog-Based-Program-Analysis"><a href="#10-Datalog-Based-Program-Analysis" class="headerlink" title="10 - Datalog-Based Program Analysis"></a>10 - Datalog-Based Program Analysis</h2><p>待补充</p>
<h2 id="11-CFL-Reachability-and-IFDS"><a href="#11-CFL-Reachability-and-IFDS" class="headerlink" title="11 - CFL-Reachability and IFDS"></a>11 - CFL-Reachability and IFDS</h2><p>待补充</p>
<h2 id="12-Soundness-and-Soundiness"><a href="#12-Soundness-and-Soundiness" class="headerlink" title="12 - Soundness and Soundiness"></a>12 - Soundness and Soundiness</h2><p>待补充</p>
<h2 id="实验作业部分"><a href="#实验作业部分" class="headerlink" title="实验作业部分"></a>实验作业部分</h2><h4 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h4><ul>
<li>为 Java 实现一个活跃变量分析（Live Variable Analysis）</li>
<li>实现一个通用的迭代求解器（Iterative Solver），用于求解数据流分析问题，也就是本次作业中的活跃变量分析</li>
</ul>
<p><em>LiveVariableAnalysis</em> 类提供了一个活跃变量分析器，提供算法执行过程中所需要的接口（图中红色的方法标注），作为 <em>Solver</em> 类的一个私有变量</p>
<p><em>Solver</em> 类执行整个算法流程（大致分为初始化和循环体两个模块），分析结果以一个 <em>DataflowResult</em> 类的对象返回</p>
<p>注意 <em>LiveVariableAnalysis</em> 类只关注逻辑，IN, OUT, EXIT, ENTRY 等信息由 <em>DataflowResult</em> 类通过 <em>inFacts</em> 和 <em>outFacts</em> 两个 Map 管理</p>
<p>注意作业中为了简化实现难度没有使用 basic blocks，以单条语句为单位处理</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207151730781.png" alt="1" style="zoom: 40%;" />

<h4 id="A2"><a href="#A2" class="headerlink" title="A2"></a>A2</h4><ul>
<li>为 Java 实现常量传播算法</li>
<li>实现一个通用的 worklist 求解器，并用它来解决一些数据流分析问题，例如本次的常量传播</li>
</ul>
<p>与 A1 的任务总体结构相同，理解常量传播和 worklist 的实现方式并读懂提供的框架源码即可</p>
<p>注意 newBoundryFact() 需要将方法的参数初始化为 NAC（参数不由方法本身决定，故必不是常量）</p>
<p>注意 transferNode() 的返回值为一个布尔类型，worklist 算法中不需要重复判断 OUT 是否被改变</p>
<p>注意 CPFact 类的设计，变量不在某个 CPFact 对象中视为 UNDEF</p>
<p>（有部分隐藏用例没有通过，大概猜测是在 evaluate() 方法中一些除了 Var, IntLiteral 和 BinaryExp 其他一些特殊类型的 expression 没有考虑的缘故，暂且搁置）</p>
<p>关于 debug：在 IntelliJ IDEA 中进行断点调试的时候，出现 ”<em>Skipped breakpoint at … because it happened inside debugger evaluation</em>“，打条件断点的地方被跳过，是由于测试时使用了多线程，将断点设置中 <em>Suspend</em> 选项的 <em>All</em> 改成 <em>Thread</em> 即可（如图所示）</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207261829825.png" alt="1" style="zoom:50%;" />

<h4 id="A3"><a href="#A3" class="headerlink" title="A3"></a>A3</h4><ul>
<li>为 Java 实现一个死代码（dead code）检测算法</li>
</ul>
<p>该死代码检测作业需要找出两种死代码：不可达代码和无用赋值</p>
<p>不可达代码又分为控制流不可达（e.g. Return 语句之后的代码）和分支不可达（e.g. 条件跳转处的条件为常量）</p>
<p>本次作业需要用到 A1 中实现的活跃变量分析（寻找无用赋值）和 A2 中实现的常量传播分析（寻找分支不可达的代码），并新补充实现 <em>DeadCodeDetection</em> 类中的 <em>analyse</em> 方法</p>
<p>在 <em>analyse</em> 方法中，已经构建了程序的控制流图、常量传播分析结果和活跃变量分析结果，需要以此为据找出可以被判定为死代码的语句，以一个集合的形式返回</p>
<p>一开始的思路是直接寻找死代码语句，但发现由于在数据流不向后继续传递，在确定一条语句为死代码后难以判断其后继语句是否为死代码，故转换思路，通过确定活代码来反推死代码，总体思路为从程序入口处开始，借助常量传播分析结果和活跃变量分析结果，在控制流图上遍历所有可能被执行的活代码并标记，没有被标记到的节点即为死代码</p>
<h4 id="A4"><a href="#A4" class="headerlink" title="A4"></a>A4</h4><ul>
<li>为 Java 实现一个类层次结构分析（Class Hierarchy Analysis，CHA）</li>
<li>实现过程间常量传播</li>
<li>实现过程间数据流传播的 worklist 求解器</li>
</ul>
<p>类层次结构分析部分需要实现 <em>buildCallGraph</em>、<em>resolve</em> 和 <em>dispatch</em> 三个方法，课件中已经给出了相应的算法流程，模拟实现即可</p>
<ul>
<li><em>callSite.getMethodRef().getDeclaringClass()</em> 获取调用点的对象的声明类型</li>
<li><em>callSite.getMethodRef().getSubsignature()</em> 获取调用点方法的子签名（一个方法的子签名只包含它的方法名和方法签名的描述符）</li>
<li>成员变量 <em>hierarchy</em> 中包含了所有类和接口的继承和实现关系</li>
</ul>
<p>过程间的常量传播需要考虑 <em>transferNode</em> 和 <em>transferEdge</em> 两种情况：</p>
<ul>
<li><em>transferNode</em> 分为 <em>transferCallNode</em> 和 <em>transfeNonCallNode</em>：由于调用由 <em>transferEdge</em> 处理，<em>transferCallNode</em> 只需要做恒等传播；而 <em>transfeNonCallNode</em> 与 A2 中的非过程间常量传播的 <em>transferNode</em> 相同</li>
<li><em>transferEdge</em> 分为 <em>transferCallToReturnEdge</em>、<em>transferCallEdge</em> 和 <em>transferReturnEdge</em>：<em>transferCallToReturnEdge</em> 需要将调用点的左值 kill 掉（如果存在的话）；<em>transferCallEdge</em> 需要完成参数的值的传递；<em>transferReturnEdge</em> 需要完成返回值向调用点左值的赋值（如果存在的话）</li>
</ul>
<p>（注意 <em>transferEdge</em> 的返回值是一个新的 <em>Fact</em>，不改变已有的 <em>Fact</em>）</p>
<p>e.g. 下图中蓝色虚线箭头为 <em>callEdge</em>，红色虚线箭头为 <em>returnEdge</em>，黑色虚线箭头为 <em>callToReturnEdge</em></p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202207292143391.png" alt="image-20220729214359229" style="zoom: 33%;" />

<p>在实现 worklist 求解器时，注意与之前实现的不同之处有：</p>
<ul>
<li><p>初始化时，需要对所有的 <em>entry method</em> 的 <em>entry</em> 节点进行 <em>newBoundaryFact</em>（可使用 <em>icfg.entryMethods().toList()</em> 获取所有的 <em>entry method</em>）</p>
</li>
<li><p>执行算法流程时，每个节点的 <em>inFact</em> 不再是和所有前驱节点的 <em>outFact</em> 做 <em>meet</em> 操作获得，而是和所有汇入的边所带来的 <em>Fact</em> 做 <em>meet</em> 操作获得</p>
</li>
</ul>
<h4 id="A5"><a href="#A5" class="headerlink" title="A5"></a>A5</h4><ul>
<li>为 Java 实现非上下文敏感的指针分析</li>
<li>为指针分析实现一个调用图的实时构建算法</li>
</ul>
<p>作业文档足够详细，难度不大，按照算法流程实现即可，注意：</p>
<ol>
<li>每个方法可能有多个返回值，也有可能没有返回值</li>
<li>处理方法调用时需要的 dispatch 方法已经给出（*resolveCallee()*）可直接调用</li>
<li>新引入的静态字段、静态方法调用和数组在需要算法中进行处理的位置</li>
<li><em>var.getStoreFields()、var.getLoadArrays()、var.getInvokes()</em> 等接口可直接获取变量相关的语句</li>
<li><em>AddReachable</em> 方法使用了<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/visitor">访问者设计模式 </a></li>
<li>提供的框架将算法中 Δ 的计算融入了 <em>propagate</em> 方法中</li>
</ol>
<p>参考算法流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Solve(m_entry):</span><br><span class="line">	WL=[], PFG=&#123;&#125;, S=&#123;&#125;, RM=&#123;&#125;, CG=&#123;&#125;</span><br><span class="line">	addReachable(m_entry)</span><br><span class="line">	while WL is not empty do</span><br><span class="line">		remove &lt;n, pts&gt; from WL</span><br><span class="line">		Δ = pts - pt(n)</span><br><span class="line">		Propagate(n, Δ)</span><br><span class="line">		if n represents a variable x then</span><br><span class="line">			foreach o ∈ Δ do</span><br><span class="line">				foreach x.f = y ∈ S do</span><br><span class="line">					AddEdge(y, o.f)</span><br><span class="line">				foreach y = x.f ∈ S do</span><br><span class="line">					AddEdge(o.f, y)</span><br><span class="line">				foreach x[*] = y ∈ S do</span><br><span class="line">					AddEdge(y, o[*])</span><br><span class="line">				foreach y = x[*] ∈ S do</span><br><span class="line">					AddEdge(o[*], y)</span><br><span class="line">				ProcessCall(x, o)</span><br><span class="line">				</span><br><span class="line">AddReachable(m):</span><br><span class="line">	if m ∉ RM then</span><br><span class="line">		add m to RM</span><br><span class="line">		S ∪= S_m</span><br><span class="line">		foreach i: x = new T() ∈ S_m do</span><br><span class="line">			add &lt;x, &#123;o_i&#125;&gt; to WL</span><br><span class="line">		foreach x = y ∈ S_m do</span><br><span class="line">			AddEdge(y, x)</span><br><span class="line">		foreach T.f = y ∈ S_m do</span><br><span class="line">			AddEdge(y, T.f)</span><br><span class="line">		foreach y = T.f ∈ S_m do</span><br><span class="line">			AddEdge(T.f, y)</span><br><span class="line">		foreach l: x = T.k(a1,...,an) ∈ S_m do</span><br><span class="line">			f = Dispatch(_, k)</span><br><span class="line">			if l → f ∉ CG then</span><br><span class="line">				add l → f to CG</span><br><span class="line">				AddReachable(f)</span><br><span class="line">				foreach parameter p_i of f do</span><br><span class="line">					AddEdge(a_i, p_i)</span><br><span class="line">				AddEdge(f_ret, x)</span><br><span class="line">				</span><br><span class="line">ProcessCall(x, o):</span><br><span class="line">	foreach l: r = x.k(a1,...,an) ∈ S_m do</span><br><span class="line">		m = Dispatch(o, k)</span><br><span class="line">		add &lt;m_this, &#123;o&#125;&gt; to WL</span><br><span class="line">		if l → m ∉ CG then</span><br><span class="line">			add l → f to CG</span><br><span class="line">				AddReachable(m)</span><br><span class="line">				foreach parameter p_i of m do</span><br><span class="line">					AddEdge(a_i, p_i)</span><br><span class="line">				AddEdge(m_ret, r)</span><br><span class="line">				</span><br><span class="line">AddEdge(s, t):</span><br><span class="line">	if s → t ∉ PFG then</span><br><span class="line">		add s → t to PFG</span><br><span class="line">		if pt(s) is not empty then</span><br><span class="line">			add &lt;t, pt(s)&gt; to WL</span><br><span class="line">			</span><br><span class="line">Propagate(n, pts):</span><br><span class="line">	if pts is not empty then</span><br><span class="line">		pt(n) ∪= pts</span><br><span class="line">		foreach n → s ∈ PFG do</span><br><span class="line">			add &lt;s, pts&gt; to WL</span><br></pre></td></tr></table></figure>

<h4 id="A6"><a href="#A6" class="headerlink" title="A6"></a>A6</h4><ul>
<li>为 Java 实现一个上下文敏感的指针分析框架</li>
<li>作为指针分析的一部分，随着指针分析一起实现调用图（call graph）构建</li>
<li>实现几种常见的上下文敏感策略（context sensitivity variants）</li>
</ul>
<p>与 A5 相似，注意上下文的正确对应即可</p>
<h4 id="A7"><a href="#A7" class="headerlink" title="A7"></a>A7</h4><blockquote>
<p>开放性作业</p>
</blockquote>
<ul>
<li>为 Java 实现一个 alias-aware 的过程间常量传播分析</li>
</ul>
<p>在 A4 的基础上，利用 A6 中实现的指针分析的分析结果，得到更精确的过程间常量传播分析</p>
<p>A4 在 A3 的基础上，解决了把所有方法调用的返回值全部置为 <em>NAC</em> 的问题</p>
<p>A7 在 A4 的基础上，解决了把所有 <em>load</em> 语句（e.g. x = y.f）给变量的赋值全部置为 <em>NAC</em> 的问题</p>
<p>简言之就是，对于 <em>load</em> 语句 <em>x = y.f</em>，找出所有形如 <em>z.f = w</em>（<em>z.f</em> 满足条件是 <em>y.f</em> 的别名）的 <em>store</em> 语句，将所有变量 <em>w</em> 对应的值做 <em>meet</em> 操作并赋值给 <em>x</em></p>
<p>满足互为别名的条件：</p>
<ul>
<li>实例字段（<em>x.f</em> 和 <em>y.g</em>）<ul>
<li>字段 <em>f</em> 和字段 <em>g</em> 相同</li>
<li>变量 <em>x</em> 和变量 <em>y</em> 对应的指针集有交集</li>
</ul>
</li>
<li>静态字段（<em>T.f</em> 和 <em>Q.g</em>）<ul>
<li>字段 <em>f</em> 和字段 <em>g</em> 相同</li>
<li>类 <em>T</em> 和类 <em>Q</em> 相同</li>
</ul>
</li>
<li>数组元素（<em>a[i]</em> 和 *b[j]*）<ul>
<li>变量 <em>a</em> 和变量 <em>b</em> 对应的指针集有交集</li>
<li>变量 <em>i</em> 和变量 <em>j</em> 都不是 <em>UNDEF</em> 并且变量 <em>i</em> 和变量 <em>j</em> 都是常量时其值相等</li>
</ul>
</li>
</ul>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208101501773.png" alt="image-20220810150109665" style="zoom:50%;" />

<p>修改 <em>transferNonCallNode</em> 方法，对所有 <strong><em>load</em> 语句和 <em>store</em> 语句</strong>进行单独处理：</p>
<ul>
<li>对于 <em>load</em> 语句，不做 A4 中的常量传播，找出将所有满足别名关系的 <em>store</em> 语句加以处理</li>
<li>对于 <em>store</em> 语句，需要将所有满足别名关系的 <em>load</em> 语句加入到 <em>solver</em> 的 <em>worklist</em> 中（本质上来讲，满足别名关系的 <em>load</em> 语句会动态地成为对应 <em>store</em> 语句的后继）</li>
</ul>
<h4 id="A8"><a href="#A8" class="headerlink" title="A8"></a>A8</h4><blockquote>
<p>开放性作业</p>
</blockquote>
<ul>
<li>为 Java 实现污点分析</li>
</ul>
<p>污点分析和指针分析的不同之处在于，污点可以在对象之间传播（因为污点和数据内容相关），所以不仅需要在方法调用处处理 <em>sources</em> 和 <em>sinks</em>（获取污点数据/得到污点流），还需要额外进行污点传播</p>
<p>在方法调用中特殊的污点传播：由 <em>base</em> 变量传给 <em>result</em>；由参数传给 <em>base</em> 变量；由参数传给 <em>result</em>，这些规则会在初始化的时候作为输入给出，可以通过 <em>TaintConfig</em> 类的 <em>getTransfer</em> 方法调用</p>
<p>总的来说，污点分析需要与 A6 中实现的指针分析相结合，并实现以下规则：</p>
<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208111805794.png" alt="image-20220811180518725" style="zoom:50%;" />

<img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202208111806418.png" alt="image-20220811180603335" style="zoom:50%;" />

<h5 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h5><ul>
<li><p><em>TaintAnalysiss</em> 中添加（实现）的主要 API：</p>
<ul>
<li><em>captureTaintObj</em>：执行 <em>Call(source)</em> 规则，返回一个新的污点对象</li>
<li><em>captureTaintTransfer</em>：执行特殊的污点传播规则，方法内部调用链三个私有方法 <em>captureBaseToResult</em>、<em>captureArgToBase</em> 和 <em>captureArgToResult</em>，分别执行规则 *Call(base-to-result)*、 <em>Call(arg-to-base)</em> 和 <em>Call(arg-to-result)</em>  </li>
<li><em>collectTaintFlows</em>：执行 <em>Call(sink)</em> 规则，返回一个污点流的集合，即污点分析的结果</li>
</ul>
</li>
<li><p>在分析有返回值的方法调用时，调用 <em>taintAnalysis.captureTaintObj</em> 获取污点对象，并将其加入 <em>result</em> 变量的指针集中</p>
</li>
<li><p>在分析方法调用时，调用 <em>taintAnalysis.captureTaintTransfer</em> 处理污点传播</p>
</li>
</ul>
<h5 id="出现的问题及解决方式："><a href="#出现的问题及解决方式：" class="headerlink" title="出现的问题及解决方式："></a>出现的问题及解决方式：</h5><p>当污点对象传播到某个变量的指针集中时，以该变量作为参数的方法调用可能已经被分析过，并且可能不会被再一次加入 <em>worklist</em>，导致分析结果有所遗漏（方法调用中特殊的污点传播的分析是安插在指针分析过程中的）</p>
<p>对 <em>propagate</em> 方法进行改进，若一个变量的指针集中有新流入污点对象，则从现有的调用图中获取所有的调用点，找到以该变量作为参数的调用点，并对该调用点单独执行一次 <em>captureTaintTransfer</em></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Yoson Ling</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/NJU/"># NJU</a>
                    
                        <a href="/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"># 静态分析</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/08/03/About-UniRLTest/">关于 UniRLTest</a>
            
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Yoson Ling | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>